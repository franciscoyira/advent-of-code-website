[
  {
    "objectID": "fonts/LICENSE.html",
    "href": "fonts/LICENSE.html",
    "title": "iA Writer Typeface",
    "section": "",
    "text": "iA Writer Typeface\nCopyright ¬© 2018 Information Architects Inc.¬†with Reserved Font Name ‚ÄúiA Writer‚Äù\n\n\nBased on IBM Plex Typeface\nCopyright ¬© 2017 IBM Corp.¬†with Reserved Font Name ‚ÄúPlex‚Äù\n\n\nLicense\nThis Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL\n\n\n\nSIL OPEN FONT LICENSE Version 1.1 - 26 February 2007\n\n\n\nPREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.\nThe OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.\nDEFINITIONS ‚ÄúFont Software‚Äù refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.\n‚ÄúReserved Font Name‚Äù refers to any names specified as such after the copyright statement(s).\n‚ÄúOriginal Version‚Äù refers to the collection of Font Software components as distributed by the Copyright Holder(s).\n‚ÄúModified Version‚Äù refers to any derivative made by adding to, deleting, or substituting ‚Äì in part or in whole ‚Äì any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.\n‚ÄúAuthor‚Äù refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.\nPERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:\n\nNeither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.\nOriginal or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.\nNo Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.\nThe name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.\nThe Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.\n\nTERMINATION This license becomes null and void if any of the above conditions are not met.\nDISCLAIMER THE FONT SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE."
  },
  {
    "objectID": "2023.html",
    "href": "2023.html",
    "title": "2023",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2023: Introduction\n\n\nintro\n\n\n\n\n2023: Day 1\n\n\nR,stringr\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "2023/day/2023-introduction/index.html",
    "href": "2023/day/2023-introduction/index.html",
    "title": "2023: Introduction",
    "section": "",
    "text": "Welcome to my Advent of Code 2023 journey! This year, I‚Äôve decided to put a bit of extra-whimsy on this already whimsical set of puzzles by using a ‚Äúspinning wheel‚Äù to decide whether I‚Äôll attempt to solve each day‚Äôs puzzle using R or Python:\n\n\n\nSpinning wheel in the TinyDecisions app\n\n\nThis method allows me to both strengthen my already substantial R skills and also improve my fluency in Python, a language in which I have more progress to make.\nAlso, in previous years, the Advent of Code challenges often caught me unprepared schedule-wise, either due to time constraints or other commitments. However, this year, I‚Äôve planned ahead to ensure I can engage at least with half of the puzzles throughout December (committing to solve ALL the puzzles in December is still too much because some are very challenging, and, well, work and life continue).\nI‚Äôll aim to post the solutions in a conversational, narrative manner, sharing not only the final code, but also the thought process I followed to solve each problem."
  },
  {
    "objectID": "2022.html",
    "href": "2022.html",
    "title": "2022",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2022: Day 1\n\n\nbase R,lists\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "2022/day/1/index.html",
    "href": "2022/day/1/index.html",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#setup",
    "href": "2022/day/1/index.html#setup",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#part-1",
    "href": "2022/day/1/index.html#part-1",
    "title": "2022: Day 1",
    "section": "Part 1",
    "text": "Part 1\nI‚Äôm including this post in the website example to demonstrate what a typical post will look like, using post-template, in the _templates directory as a starting point. This post is created by a call to aoc_new_day(1, 2022). It can be deleted with a call to aoc_delete_day(1, 2022), or all posts and the listing for the year can be deleted with aoc_delete_year(2022).\n\n\n\n\n\n\nNote\n\n\n\nThis is Ella Kaye‚Äôs solution1, with her puzzle input. If attempting this challenge yourself, your solution will be different.\n\n\n\n\nCode\nlibrary(aochelpers)\ninput &lt;- aoc_input_vector(1, 2022, \"numeric\")\n\n\nI‚Äôm using the aoc_input_vector() function from the aochelpers package to read in the data, but otherwise using base R functions (including the native pipe, |&gt;) for this puzzle.\nIn this challenge, we‚Äôre given groups of numbers and we need to find the sum of each group. Our solution is the largest of these. The groups are separated by a blank line. When reading in the input as a numeric vector, these are coerced to NA. We can identify the new groups by the NA values, produce an index for them with cumsum(is.na(input)), which increments when a new NA is reached, then use this with split() to split the input into a list of vectors, one for each group. We need the argument na.rm = TRUE in sapply() because each vector, other than the first, starts with NA, as that‚Äôs where it was split.\n\n\nCode\ntotals &lt;- split(input, cumsum(is.na(input))) |&gt; \n  sapply(sum, na.rm = TRUE) \n\nmax(totals)\n\n\n[1] 66719"
  },
  {
    "objectID": "2022/day/1/index.html#part-2",
    "href": "2022/day/1/index.html#part-2",
    "title": "2022: Day 1",
    "section": "Part 2",
    "text": "Part 2\nThis is similar, except we want to find the sum of the sums of the top three groups.\n\n\nCode\ntotals |&gt; \n  sort() |&gt; \n  tail(3) |&gt; \n  sum()\n\n\n[1] 198551"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code",
    "section": "",
    "text": "Hi there! Welcome to this mini-site where I‚Äôll be sharing my solutions to the Advent of Code puzzles. Advent of Code is a series of increasingly difficult programming challenges, released daily each year throughout December in the run-up to Christmas.\nTo see my solutions and notes, just click on the corresponding year in the top navigation bar (though, as of now, I‚Äôve only published solutions for 2023).\nThis website is created using the EllaKaye/advent-of-code-website-template template repository. In the README of the repo you can find documentation on how to use it and adapt it, in case you can to publish your solutions in a similar format (which you should totally do üòÅ)."
  },
  {
    "objectID": "2023/day/1/index.html",
    "href": "2023/day/1/index.html",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a ‚Äúcalibration document‚Äù\nHas been ‚Äúamended‚Äù by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#setup",
    "href": "2023/day/1/index.html#setup",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a ‚Äúcalibration document‚Äù\nHas been ‚Äúamended‚Äù by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#part-1",
    "href": "2023/day/1/index.html#part-1",
    "title": "2023: Day 1",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlibrary(tidyverse)\nlibrary(here)\n\n\nTransforming the data to an appropriate data structure:\n\n\nCode\namended &lt;- read_lines(here('2023', 'day', '1', 'input'))\namended[1:10]\n\n\n [1] \"nqninenmvnpsz874\"                          \n [2] \"8twofpmpxkvvdnpdnlpkhseven4ncgkb\"          \n [3] \"six8shdkdcdgseven8xczqrnnmthreecckfive\"    \n [4] \"qlcnz54dd75nine7jfnlfgz\"                   \n [5] \"7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr\"\n [6] \"cdhmktwo6kjqbprvfour8\"                     \n [7] \"ninekkvkeight9three\"                       \n [8] \"ms9five71lrfpqxqlbj\"                       \n [9] \"9five9sevenldshqfgcnq\"                     \n[10] \"1one4seven\"                                \n\n\n\nSolving for a particular case\n\n\nCode\n(first_case &lt;- amended[1])\n\n\n[1] \"nqninenmvnpsz874\"\n\n\nExtracting the numbers\n\n\nCode\n(matrix_str_numbers &lt;-\n  str_extract_all(first_case, pattern = '\\\\d', simplify = TRUE))\n\n\n     [,1] [,2] [,3]\n[1,] \"8\"  \"7\"  \"4\" \n\n\nExtracting all the rows from columns one and three (the first and last number of each row)\n\n\nCode\nnumbers_i_want &lt;- matrix_str_numbers[, c(1,3)]\nnumbers_i_want\n\n\n[1] \"8\" \"4\"\n\n\n(This code will generalise ONLY IF all the other rows have 3 numbers too).\nThe following code returns the first and last number ‚Äúpasted‚Äù together and converts the result from string to numeric.\n\n\nCode\nstringr::str_flatten(numbers_i_want) %&gt;%\n  as.numeric()\n\n\n[1] 84\n\n\nNow let‚Äôs try to generalise to all input rows:\n\n\nCode\namended %&gt;%\n  str_extract_all(pattern = '\\\\d', simplify = TRUE) %&gt;%\n  head(5)\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n[1,] \"8\"  \"7\"  \"4\"  \"\"   \"\"   \"\"   \"\"  \n[2,] \"8\"  \"4\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[3,] \"8\"  \"8\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[4,] \"5\"  \"4\"  \"7\"  \"5\"  \"7\"  \"\"   \"\"  \n[5,] \"7\"  \"2\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n\n\nOh no. Rows have a different quantity of digits.\nMaybe using simplify=TRUE was a mistake here. Given that each element has a different quantity of digits, a list seems to be a more suitable data structure:\n\n\nCode\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(5)\n\nlist_digits_preview\n\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nNow, how can I extract the first and last element from each element of the list? My gut feeling is that I‚Äôll need purrr for this:\npluck and keep_at seem to be useful functions for this task\n\n\nCode\nlist_digits_preview %&gt;%\n  # This should extract the first and last digit from each element of the list \n  map(~keep_at(., c(1, length(.))))\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nIt is working!!\nNow I‚Äôll apply the action to the whole list:\n\n\nCode\nlist_useful_digits &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(~keep_at(., c(1, length(.))))\n\nlist_useful_digits[1:10]\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nHmmm‚Ä¶ Why does element 7 have only 1 digit?\n\n\nCode\namended[7]\n\n\n[1] \"ninekkvkeight9three\"\n\n\nIt‚Äôs got just one digit as a number, but there are other digits written out in words. Should we count those? The prompt isn‚Äôt really clear about this. But since the example only talks about digits as numbers, I guess I‚Äôll just go with those for now. If I‚Äôve got this wrong and my solution gets rejected, well, I can always give it another shot\nNow let‚Äôs concatenate the digits row-wise, turn them into a number and add them up:\n\n\nCode\nsolution &lt;- \n  list_useful_digits %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution\n\n\n[1] 39347\n\n\nüëéüèΩ Solution was rejected. The website says it‚Äôs too low ü§î\nThe most likely suspect here is the way map(~keep_at(., c(1, length(.)))) is handling the rows with only one digit.\nSome alternatives I could try:\n\nIf the input row has only one digit, then use it as first AND last digit when building the number (e.g.¬†if the row only contains 7, the number I would obtain from that row should be 77).\nTake into account digits that are written as words (e.g.¬†‚Äúthree‚Äù). This is less likely to work and it would be weird for the exercise to expect people to do this and not mentioning it explicitely in the prompt or the examples.\n\nI‚Äôll go with alternative 1.\n\n\nHandling rows with just one digit\nI‚Äôll take a slice from the first 10 rows, as the first case with one digit appears in row 7:\n\n\nCode\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(10)\n\nlist_digits_preview\n\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"7\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nI have a feeling that purrr::pluck may do the trick here:\n\n\nCode\nget_first_and_last &lt;- function(x) {\n  c(pluck(x, 1), pluck(x, length(x)))\n}\n\nlist_digits_preview %&gt;%\n  map(get_first_and_last)\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\" \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nThis function does what I want (and yes, using pluck is a bit unnecessary since I could just have used regular subsetting, e.g.¬†x[[1]] and x[[length(x)]], but I‚Äôm doing this with the purrr cheat sheet in front of me, so pluck was what came to my mind).\n2nd attempt, this time using get_first_and_last.\n\n\nCode\nsolution2 &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution2\n\n\n[1] 56397\n\n\nThis is the correct solution!! ü•≥ü•≥ü•≥\nOnto the second part!"
  },
  {
    "objectID": "2023/day/1/index.html#part-2",
    "href": "2023/day/1/index.html#part-2",
    "title": "2023: Day 1",
    "section": "Part 2",
    "text": "Part 2\nSaw this one coming: now I need to tackle the digits spelled out as words üò¨.\n\nFirst (naive) attempt\nIMHO the simplest approach is to write a function that converts digits spelled out in a string into their numeric form. Then, I can incorporate this function into my pipeline using a map call, right before str_extract_all.\n\n\nCode\ncase_with_spelled_digit &lt;- amended[7]\ncase_with_spelled_digit\n\n\n[1] \"ninekkvkeight9three\"\n\n\n\n\nCode\ncase_with_spelled_digit %&gt;%\n  str_replace_all(\n    c(\n      \"nine\" = \"9\",\n      \"eight\" = \"8\",\n      \"three\" = \"3\"\n    )\n  )\n\n\n[1] \"9kkvk893\"\n\n\nWorking as expected.\nNow let‚Äôs apply the function to the full data.\nI‚Äôll start by creating the replacement vector (although I‚Äôm pretty sure it‚Äôs already a part of some R package that‚Äôs slipping my mind right now).\n\n\nCode\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\"\n)\n\n\n\n\nCode\nsolution3 &lt;- \n  amended %&gt;%\n  str_replace_all(pattern = digits) %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution3\n\n\n[1] 55266\n\n\nThe solution wasn‚Äôt right.\n\n\nSecond attempt: handling overlapping patterns\nTime to take a closer look at the pipeline using a tibble.\n\n\nCode\ntibble(\n  original = amended,\n  new = original %&gt;%\n    str_replace_all(pattern = digits),\n  digits = amended %&gt;%\n    str_replace_all(pattern = digits) %&gt;%\n    str_extract_all(pattern = '\\\\d') %&gt;%\n    map(get_first_and_last) %&gt;%\n    map(str_flatten) %&gt;%\n    as_vector()\n)\n\n\n# A tibble: 1,000 √ó 3\n   original                                   new                         digits\n   &lt;chr&gt;                                      &lt;chr&gt;                       &lt;chr&gt; \n 1 nqninenmvnpsz874                           nq9nmvnpsz874               94    \n 2 8twofpmpxkvvdnpdnlpkhseven4ncgkb           82fpmpxkvvdnpdnlpkh74ncgkb  84    \n 3 six8shdkdcdgseven8xczqrnnmthreecckfive     68shdkdcdg78xczqrnnm3cck5   65    \n 4 qlcnz54dd75nine7jfnlfgz                    qlcnz54dd7597jfnlfgz        57    \n 5 7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr 7vrdhggdkqbnltlgpkkvsdxn2m‚Ä¶ 72    \n 6 cdhmktwo6kjqbprvfour8                      cdhmk26kjqbprv48            28    \n 7 ninekkvkeight9three                        9kkvk893                    93    \n 8 ms9five71lrfpqxqlbj                        ms9571lrfpqxqlbj            91    \n 9 9five9sevenldshqfgcnq                      9597ldshqfgcnq              97    \n10 1one4seven                                 1147                        17    \n# ‚Ñπ 990 more rows\n\n\nHypothesis: The issue might arise in instances like \"zoneight234\", where the spellings of two numbers are overlapping.\n\n\nCode\nstr_replace_all(\"zoneight234\", pattern = digits)\n\n\n[1] \"z1ight234\"\n\n\nI‚Äôll try to handle these cases to make sure that every spelled-out digit in the text is returned, even if they overlap.\nMaybe I can get closer to that by using the stringi package?\n\n\nCode\nstringi::stri_replace_all_regex(\"zoneight234\", pattern = names(digits), replacement = digits, vectorize_all = FALSE)\n\n\n[1] \"z1ight234\"\n\n\nThis is not working.\nSomething else I could try:\n\nUsing the _first and _last functions from stringi to identify digits, whether they are numerically written or spelled out.\n\n\nThen, replacing the spelled-out digits that appear at either the beginning or end of the string.\n\n\n\nCode\nproblematic_string &lt;- \"zone2344oneight\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\nall_digits_vector &lt;- c(\n  names(digits),\n  0:9\n)\n\nstringi::stri_extract_last_regex(\n  str = problematic_string,\n  pattern = all_digits_vector\n)\n\n\n [1] \"one\"   NA      NA      NA      NA      NA      NA      \"eight\" NA     \n[10] NA      NA      \"2\"     \"3\"     \"4\"     NA      NA      NA      NA     \n[19] NA     \n\n\nOkay, this method DOES return all the digits that appear in the string, but I end up losing details about where the digits are positioned, which is needed for identifying the first and last digits in each row.\nMore ideas:\n\nUsing str_localte_all, a stringr function that allows matching each digit as an separate pattern (thus avoiding the overlap problem) and gives information about the POSITION of the pattern. Then use that info to find the first and the last match in each row.\n\nExample:\n\n\nCode\nstringr::str_locate_all(\n  string = problematic_string,\n  pattern = all_digits_vector\n)[1:8]\n\n\n[[1]]\n     start end\n[1,]     2   4\n[2,]     9  11\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n\n[[4]]\n     start end\n\n[[5]]\n     start end\n\n[[6]]\n     start end\n\n[[7]]\n     start end\n\n[[8]]\n     start end\n[1,]    11  15\n\n\n\nCRAZY IDEA!!! What if I reverse the string, and then look for first match of the reversed names of the digits??\n\nAfter all, the only matches that matter for solving this puzzle are the first one and the last one. For the first match, overlapping is not a real problem because it causes the second digit not to match (example: ‚Äúeight‚Äù in ‚Äúoneight‚Äù, here ‚Äúone‚Äù is always matched or detected).\nReversing the strings and their patterns could mirror this dynamic when matching the last digit.\n\n\nCode\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nvector_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\n\nIn this example, I should be able to match ‚Äúeight‚Äù as the last string, despite it overlapping with ‚Äúone‚Äù.\n\n\nCode\nproblematic_string\n\n\n[1] \"zone2344oneight\"\n\n\nMy strategy is to invert it and then look for ‚Äúthgie‚Äù üòÇüíÄ\n\n\nCode\nreversed_problematic_string &lt;- \n  stringi::stri_reverse(\n  problematic_string\n)\nreversed_problematic_string\n\n\n[1] \"thgieno4432enoz\"\n\n\n\n\nCode\nfound_reversed_string &lt;- str_extract(\n  reversed_problematic_string,\n  \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n)\n\nfound_reversed_string\n\n\n[1] \"thgie\"\n\n\nAfter finding it, I can use the following code to get back the original number\n\n\nCode\nvector_reversed[found_reversed_string]\n\n\nthgie \n  \"8\" \n\n\nIt‚Äôs working. Now, let‚Äôs wrap this pipeline in a function to apply it to whole dataset:\n\n\nCode\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\ndigits_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\nget_last_number &lt;- function(x) {\n  found_reversed_string &lt;-\n    stringi::stri_reverse(x) %&gt;%\n    str_extract(regex_reversed)\n\n  digits_reversed[found_reversed_string] %&gt;%\n    set_names(NULL)\n}\n\nget_first_number &lt;- function(x) {\n  found_string &lt;- str_extract(\n    x,\n    all_digits_regex\n  )\n\n  digits[found_string] %&gt;%\n    set_names(NULL)\n\n}\nget_first_number(problematic_string)\n\n\n[1] \"1\"\n\n\nCode\nget_last_number(problematic_string)\n\n\n[1] \"8\"\n\n\nIt‚Äôs working as intended, now let‚Äôs generalise it:\n\n\nCode\ntibble(\n  amended = amended,\n  first_digit = get_first_number(amended),\n  last_digit = get_last_number(amended),\n  combined = as.integer(str_c(first_digit, last_digit))\n) %&gt;%\n  pull(combined) %&gt;%\n  sum()\n\n\n[1] 55701\n\n\nIT WORKED!! THIS WAS THE RIGHT ANSWER!!! ü•≥ü•≥ü•πü•π"
  },
  {
    "objectID": "fonts/Readme.html",
    "href": "fonts/Readme.html",
    "title": "iA-Fonts",
    "section": "",
    "text": "iA-Fonts\nThe iA Writer fonts comes bundled with iA Writer for for Android, Windows, Mac, iPadOS and iOS\nFor in depth explanation of iA Writer Mono, Duo, and Quattro please read our blog entry on Duospace and on iA Writer Mono, Duo, and Quattro\nThis is a modification of IBM‚Äôs Plex font. The upstream project is here Please read the licensing file before working with it.\nIf you fork or use our fonts, please reference iA Writer clearly. Use them creatively.\nDon‚Äôt be a copycat. With or without the fonts, do not clone our products or our website. Selling our work under your name is blatantly disrespectful and criminal. Distributing knockoffs of our work for free doesn‚Äôt make you Robin Hood either. We do not approve of free plugins or themes for other apps and other counterfeits that imitate our products. They‚Äôre poor quality, they undermine our business, and they openly violate our copyright. Due to their poor quality, they tarnish our reputation. They‚Äôre unethical, illegal, and lame."
  }
]