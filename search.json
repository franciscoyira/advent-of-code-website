[
  {
    "objectID": "2023/day/4/index.html",
    "href": "2023/day/4/index.html",
    "title": "2023: Day 4",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/4/index.html#setup",
    "href": "2023/day/4/index.html#setup",
    "title": "2023: Day 4",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/4/index.html#part-1",
    "href": "2023/day/4/index.html#part-1",
    "title": "2023: Day 4",
    "section": "Part 1",
    "text": "Part 1\nThere are a bunch of cards, which get points based on how many winning numbers do they have. I have to calculate how many points are the cards worth in total.\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\nNumbers to the right of the vertical bar | are the winning numbers. The first winning number to the left of the bar makes the card worth 1 point, and each sucesive winning number doubles the points the card is worth.\n\n\nToggle the code\nlibrary(tidyverse)\nlibrary(here)\n\n\nReading the input as a vector\n\n\nToggle the code\ninput &lt;- read_lines(here(\"2023/day/4/input\"))\ninput[1:10]\n\n\n [1] \"Card   1: 69 12 75 19 83 56 73 53 52 91 | 83 63 56 30 77 94 12 81 42 69 52 70  6 97 20 43 61 22 75 19 73 32 74 53 91\"\n [2] \"Card   2: 23 55 24 84 90 10 87 73 74 45 | 20 66 51 78  9 76 86 96 72 70 84 35 74 90 56 55 23 38 58 45 87  2 80  8 10\"\n [3] \"Card   3: 70 32 38 23 86 54 26 16  9  1 | 67 50 39 70 59 77 63 30  3 45 23 16 72  1 86  7  9 32 26 68 38 54 65 34 64\"\n [4] \"Card   4: 33 50 19 63 92  1 58 34 84  8 | 35 61 49 86 40 20 22 71 84 51 64 62 33 85 45  3 54 83  1 29 82 19 92  8 11\"\n [5] \"Card   5: 74  9 54 83 22 15 81 64 47 70 | 21 74 59 85 17 36  5 79 87  7 13 23 47 45 96 29 68 65  3 22  4 34 46 90 40\"\n [6] \"Card   6: 29 55 56 13 58 71 36 30 15 11 | 99 17 90 29 22 68 61 55 11 13 37 94 30 60 56 92 44 71 42 31  8 26 14 51 35\"\n [7] \"Card   7: 92 70 97 62 33 45 85 59 82 73 | 92 35 11 49 88 14 85 42 40 41 69 51 82 73  5 87 60 62 33 97 70 16 59 13 45\"\n [8] \"Card   8:  5 22 64 46 32 90 57 83 37 38 | 87 47 91 35 39 64 73 83 71 22 10 45  1 76 37 13 20 66 67 21 86 92 38 12 52\"\n [9] \"Card   9:  7 49 62 79 37 91  3 58 74 19 | 17  7 58  2 53 95 52 62 83 41 42 36  4 94 64 97 20 32  3 73 81 22 57 37  9\"\n[10] \"Card  10: 84 33 81 45 99 96 76 97 40  2 | 81 26 11 34 83 25 45 76  2 85 33 64 57 99 93 75 96  8 84 44 79 87 97 40 70\"\n\n\nTrying to parse the input as tidy data:\n\n\nToggle the code\ncard_data &lt;- tibble(\n  input = input\n) %&gt;%\n  separate(\n    input,\n    into = c(\"id\", \"data\"),\n    sep = \": \"\n  ) %&gt;%\n  mutate(\n    id = as.integer(str_extract(id, \"\\\\d+\"))\n  )\n\ncard_data\n\n\n# A tibble: 212 √ó 2\n      id data                                                                   \n   &lt;int&gt; &lt;chr&gt;                                                                  \n 1     1 \"69 12 75 19 83 56 73 53 52 91 | 83 63 56 30 77 94 12 81 42 69 52 70  ‚Ä¶\n 2     2 \"23 55 24 84 90 10 87 73 74 45 | 20 66 51 78  9 76 86 96 72 70 84 35 7‚Ä¶\n 3     3 \"70 32 38 23 86 54 26 16  9  1 | 67 50 39 70 59 77 63 30  3 45 23 16 7‚Ä¶\n 4     4 \"33 50 19 63 92  1 58 34 84  8 | 35 61 49 86 40 20 22 71 84 51 64 62 3‚Ä¶\n 5     5 \"74  9 54 83 22 15 81 64 47 70 | 21 74 59 85 17 36  5 79 87  7 13 23 4‚Ä¶\n 6     6 \"29 55 56 13 58 71 36 30 15 11 | 99 17 90 29 22 68 61 55 11 13 37 94 3‚Ä¶\n 7     7 \"92 70 97 62 33 45 85 59 82 73 | 92 35 11 49 88 14 85 42 40 41 69 51 8‚Ä¶\n 8     8 \" 5 22 64 46 32 90 57 83 37 38 | 87 47 91 35 39 64 73 83 71 22 10 45  ‚Ä¶\n 9     9 \" 7 49 62 79 37 91  3 58 74 19 | 17  7 58  2 53 95 52 62 83 41 42 36  ‚Ä¶\n10    10 \"84 33 81 45 99 96 76 97 40  2 | 81 26 11 34 83 25 45 76  2 85 33 64 5‚Ä¶\n# ‚Ñπ 202 more rows\n\n\n\n\nToggle the code\ncard_data_split &lt;- card_data %&gt;%\n  separate(\n    data,\n    into = c(\"my_numbers\", \"winning_numbers\"),\n    sep = \" \\\\| \"\n  )\n\ncard_data_split\n\n\n# A tibble: 212 √ó 3\n      id my_numbers                      winning_numbers                        \n   &lt;int&gt; &lt;chr&gt;                           &lt;chr&gt;                                  \n 1     1 \"69 12 75 19 83 56 73 53 52 91\" 83 63 56 30 77 94 12 81 42 69 52 70  6‚Ä¶\n 2     2 \"23 55 24 84 90 10 87 73 74 45\" 20 66 51 78  9 76 86 96 72 70 84 35 74‚Ä¶\n 3     3 \"70 32 38 23 86 54 26 16  9  1\" 67 50 39 70 59 77 63 30  3 45 23 16 72‚Ä¶\n 4     4 \"33 50 19 63 92  1 58 34 84  8\" 35 61 49 86 40 20 22 71 84 51 64 62 33‚Ä¶\n 5     5 \"74  9 54 83 22 15 81 64 47 70\" 21 74 59 85 17 36  5 79 87  7 13 23 47‚Ä¶\n 6     6 \"29 55 56 13 58 71 36 30 15 11\" 99 17 90 29 22 68 61 55 11 13 37 94 30‚Ä¶\n 7     7 \"92 70 97 62 33 45 85 59 82 73\" 92 35 11 49 88 14 85 42 40 41 69 51 82‚Ä¶\n 8     8 \" 5 22 64 46 32 90 57 83 37 38\" 87 47 91 35 39 64 73 83 71 22 10 45  1‚Ä¶\n 9     9 \" 7 49 62 79 37 91  3 58 74 19\" 17  7 58  2 53 95 52 62 83 41 42 36  4‚Ä¶\n10    10 \"84 33 81 45 99 96 76 97 40  2\" 81 26 11 34 83 25 45 76  2 85 33 64 57‚Ä¶\n# ‚Ñπ 202 more rows\n\n\nCreating a function that parses the sequences of numbers as numeric vectors:\n\n\nToggle the code\nto_numbers &lt;- function(x) {\n  str_extract_all(x, \"\\\\d+\") %&gt;%\n  map(as.numeric)\n}\n\n\nFunction that takes two vectors and calcultes how many elements from the first one are in the second one:\n\n\nToggle the code\ncalculate_n_winning &lt;- function(x, y) {\n  keep(x, ~magrittr::is_in(., y)) %&gt;%\n  length()\n}\n\n\n\n\nToggle the code\ncard_data_processed &lt;-\n  card_data_split %&gt;%\n  mutate(across(c(my_numbers, winning_numbers), to_numbers)) %&gt;%\n  mutate(n_winning = map2_dbl(my_numbers, winning_numbers, calculate_n_winning))\n\ncard_data_processed\n\n\n# A tibble: 212 √ó 4\n      id my_numbers winning_numbers n_winning\n   &lt;int&gt; &lt;list&gt;     &lt;list&gt;              &lt;dbl&gt;\n 1     1 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n 2     2 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              8\n 3     3 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n 4     4 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              6\n 5     5 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              3\n 6     6 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              7\n 7     7 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n 8     8 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              5\n 9     9 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              5\n10    10 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n# ‚Ñπ 202 more rows\n\n\nNow I need a function that doubles its output for each integer greater than 1. Specifically, the function should behave as follows:\n\nf(0) = 0\nf(1) = 1\nf(2) = 2\nf(3) = 4\nf(4) = 8\n\n\n\nToggle the code\ncalculate_points &lt;- function(x) {\n  if (x == 0) {\n    return(0)\n  } else {\n    return(2^(x-1))\n  }\n}\n\n\nApplying the function to calculate how many points the cards are worth:\n\n\nToggle the code\ncard_data_processed %&gt;%\n  mutate(points = map_dbl(n_winning, calculate_points)) %&gt;%\n  count(wt = points)\n\n\n# A tibble: 1 √ó 1\n      n\n  &lt;dbl&gt;\n1 25231\n\n\nThe solution is correct ü•≥"
  },
  {
    "objectID": "2023/day/4/index.html#part-2",
    "href": "2023/day/4/index.html#part-2",
    "title": "2023: Day 4",
    "section": "Part 2",
    "text": "Part 2\nHere I think I need to use some form of recursion:\n\n‚Äúyou win copies of the scratchcards below the winning card equal to the number of matches. So, if card 10 were to have 5 matching numbers, you would win one copy each of cards 11, 12, 13, 14, and 15.‚Äù\n\n\n‚ÄúCopies of scratchcards are scored like normal scratchcards and have the same card number as the card they copied. So, if you win a copy of card 10 and it has 5 matching numbers, it would then win a copy of the same cards that the original card 10 won: cards 11, 12, 13, 14, and 15. This process repeats until none of the copies cause you to win any more cards. (Cards will never make you copy a card past the end of the table.)‚Äù\n\nIt seems that the only column I need is n_winning, along with a new column to keep track of how many copies of the cards I have. I‚Äôll store the data in a matrix to access and modify it using indices.\n\n\nToggle the code\ncard_data_pt2 &lt;-\n  card_data_processed %&gt;%\n  transmute(\n    n_matches = n_winning,\n    count = 1\n  ) %&gt;%\n  as.matrix()\n\ncard_data_pt2[1:10]\n\n\n [1] 10  8 10  6  3  7 10  5  5 10\n\n\nNow I need to code a procedure that captures the logic described in the prompt:\n\n\nToggle the code\nn_original_cards &lt;- nrow(card_data_pt2)\n\nfor (i in 1:n_original_cards) {\n  n_matches_i &lt;- card_data_pt2[i, 1]\n  count_i &lt;- card_data_pt2[i, 2]\n\n  if (n_matches_i == 0) next\n\n  # If I have N copies of the current card, I'll win copies of the cards below N times\n  for (n in 1:count_i) {\n    for (j in 1:n_matches_i) {\n      if (i+j &lt;= n_original_cards) {\n        # Adding one copy of each of the j cards below\n        card_data_pt2[i+j, 2] = card_data_pt2[i+j, 2] + 1\n      }\n    }\n  } \n}\n\n\nAdding up the scratchcards using the count column:\n\n\nToggle the code\nsum(card_data_pt2[,2])\n\n\n[1] 9721255"
  },
  {
    "objectID": "2023/day/3/index.html",
    "href": "2023/day/3/index.html",
    "title": "2023: Day 3",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/3/index.html#setup",
    "href": "2023/day/3/index.html#setup",
    "title": "2023: Day 3",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/3/index.html#part-1",
    "href": "2023/day/3/index.html#part-1",
    "title": "2023: Day 3",
    "section": "Part 1",
    "text": "Part 1\nNotes:\n\nA part is missing from an engine; we have to figure out which one using the numbers in the engine schematic (puzzle input).\nAny number adjacent to a symbol, even diagonally, is a ‚Äúpart number‚Äù and should be included in the sum.\nPeriods do not count as a symbol.\n\nExample\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\nIn this schematic, two numbers are not part numbers because they are not adjacent to a symbol: 114 (top right) and 58 (middle right). Every other number is adjacent to a symbol and so is a part number; their sum is 4361.\n\nProblems I see:\n\nThe input is a sort of matrix/grid, but we‚Äôre working with multi-digit numbers that occupy several slots/cells of the matrix.\nComputations need to span both vertical and horizontal axes (so dataframe-oriented methods and functions may not be suitable here).\n\nAt this moment, I have no idea which data structure to use for this problem.\nThe only thing that comes to mind is to put the data in a numpy array, then use a nested for loop to check certain conditions.\n\n\nToggle the code\nimport numpy as np\nimport pandas as pd\n\n\nImporting the data in a numpy array where each element is a character of the input file.\n\n\nToggle the code\n# Inspiration for this: https://stackoverflow.com/a/75643841/7221164\nwith open('input', 'r') as f:\n    input = np.stack([np.fromiter(list(line.strip()), dtype=\"object\") for line in f])\n    print(input)\n\n\n[['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '1' ... '.' '.' '.']\n ...\n ['.' '.' '.' ... '1' '3' '.']\n ['.' '9' '6' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']]\n\n\n\n\nToggle the code\ninput.shape\n\n\n(140, 140)\n\n\nImplementing my for loop\n\nIn current_number, I‚Äôll add the digits I find as I iterate (will reset when a period or a line break is found).\nis_valid is a flag indicating whether the current_number should be counted in the sum (i.e., if any of its digits is adjacent to a symbol).\nrunning_sum keeps track of the total of all valid numbers.\n\n\n\nToggle the code\ndebugging_array = []\ncurrent_number = None\nis_valid = False\nrunning_sum = 0\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\n# Inspiration for this: https://stackoverflow.com/a/49360371\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n\n    if not value.isdigit() or (ix == 0 and iy &gt; 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        if is_valid:\n          debugging_array.append(str(current_number) + \" is valid\")\n          running_sum += current_number\n          is_valid = False\n        else:\n          debugging_array.append(str(current_number) + \" is NOT valid\")\n\n        # reset current_numner\n        current_number = None\n    \n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n\n      # check the surrounding elements to know if there is a symbol (only if is_valid = False, otherwise it's not necessary)\n      if is_valid is False:\n        for offset_y, offset_x in np.ndindex((3,3)):\n          curr_y=iy+offset_y-1\n          curr_x=ix+offset_x-1\n\n          # Exception when the \"neighbour\" would be out of the array\n          if curr_y &lt; 0 or curr_x &lt; 0 or curr_y &gt; max_y or curr_x &gt; max_x:\n            continue\n\n          # Exception when we're on the same number\n          if curr_y == iy and curr_x == ix:\n            continue\n\n          # The check itself\n          # If one of the surrounding elements is not a dot or a digit, the flag switches to True and the for loop ends\n          if input[curr_y, curr_x] != \".\" and not input[curr_y, curr_x].isdigit():\n            is_valid = True\n            break \n\n\nInspecting how the first numbers from the input were classified:\n\n\nToggle the code\ndebugging_array[:10]\n\n\n['401 is valid',\n '425 is NOT valid',\n '323 is NOT valid',\n '791 is valid',\n '697 is valid',\n '963 is NOT valid',\n '420 is NOT valid',\n '290 is valid',\n '492 is NOT valid',\n '656 is valid']\n\n\nChecking my solution:\n\n\nToggle the code\nprint(running_sum)\n\n\n543867\n\n\nThe code is very ugly (for my taste), but the solution is correct!!"
  },
  {
    "objectID": "2023/day/3/index.html#part-2",
    "href": "2023/day/3/index.html#part-2",
    "title": "2023: Day 3",
    "section": "Part 2",
    "text": "Part 2\n\nOne of the gears in the engine is malfunctioning. A gear is represented by a ‚Äô*‚Äô symbol, and it must be adjacent to exactly two part numbers. The gear ratio is calculated by multiplying these two numbers together.\nTask is to determine the gear ratio for each gear and then add them up.\n\nExample:\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\nHere there are two gears. The first one is located in the top left corner, with part numbers 467 and 35, resulting in a gear ratio of 16345. The second gear is in the lower right corner, and its gear ratio is 451490. (Note that the ‚Äô*‚Äô adjacent to 617 is not a gear because it‚Äôs only adjacent to one part number.)\n\n\nTo find the total sum of all the gear ratios in your engine schematic, simply add them up.\n\nIdea to solve this part: each time a number is valid, put it in the corresponding position of a new array that has the same dimensions as the input array.\nThen, iterate over the input array with a new for loop that searches for ‚Äú*‚Äù and counts the N of valid numbers surrounding it.\n\n\nToggle the code\narr_pt2 = np.zeros(input.shape)\n\ncurrent_number = None\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n    \n    # Case when the element is a * (potentially a gear)\n    if value == \"*\":\n      arr_pt2[iy, ix] = -1\n\n    # Checking if a number just ended\n    if not value.isdigit() or (ix == 0 and iy &gt; 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        # I need to write the current_number on the previous positions of arr_pt2\n        # Things to take into account:\n        # 1. overflowing across rows\n        # 2. I need to write the number on as many cells as digits the number has \n\n        for i in range(len(str(current_number))):\n          # ex: for a 3 digit number, offset will take values -1, -2 and -3\n          offset = -1 - i\n          # we first try to go back one cell in the x axis\n          # (move to the left across the same row)\n          ix_offset = ix + offset\n          iy_offset = iy\n\n          # case when we overflow the beginning of the row\n          if ix_offset &lt; 0:\n            # we move up in the y-axis\n            iy_offset = iy_offset-1\n\n            # when ix_offset == -1, we add 140 to end up with 139\n            ix_offset=ix_offset+input.shape[1]\n\n            # example\n            # if iy_offset, ix_offset == 10, -1\n            # we end up in 9, 139\n          arr_pt2[iy_offset, ix_offset] = current_number\n\n        # reset current_numner\n        current_number = None\n\n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n\n\nAfter this rather messy for loop, I should be able to identify gears by looking at the surrounding cells of all the ‚Äò-1‚Äô values in the array, which represent ‚Äô*‚Äô.\n\n\nToggle the code\nmax_y = arr_pt2.shape[0] -1\nmax_x = arr_pt2.shape[1] -1\n\nrunning_sum = 0\n\nfor iy, ix in np.ndindex(arr_pt2.shape):\n  value = arr_pt2[iy, ix]\n\n  neighbours = set()\n\n  if value == -1:\n    for offset_y, offset_x in np.ndindex((3,3)):\n      curr_y=iy+offset_y-1\n      curr_x=ix+offset_x-1\n\n      # Exception when the \"neighbour\" would be out of the array\n      if curr_y &lt; 0 or curr_x &lt; 0 or curr_y &gt; max_y or curr_x &gt; max_x:\n        continue\n\n      # Exception when we're on the same number\n      if curr_y == iy and curr_x == ix:\n        continue\n\n      # The check itself\n      # if a surrounding cell is a number, then I'll add it to the `neighbours` set (this data structure handles duplicated numbers automatically)\n      if arr_pt2[curr_y, curr_x] &gt; 0:\n        neighbours.add(arr_pt2[curr_y, curr_x])\n\n  \n  if len(neighbours) == 2:\n    # multiply the neighbours\n    running_sum += neighbours.pop() * neighbours.pop()\n\n\nChecking my solution:\n\n\nToggle the code\nprint(running_sum)\n\n\n79613331.0\n\n\nIt was correct!"
  },
  {
    "objectID": "2023/day/2023-introduction/index.html",
    "href": "2023/day/2023-introduction/index.html",
    "title": "2023: Introduction",
    "section": "",
    "text": "Welcome to my Advent of Code 2023 journey! This year, I‚Äôve decided to put a bit of extra-whimsy on this already whimsical set of puzzles by using a ‚Äúspinning wheel‚Äù to decide whether I‚Äôll attempt to solve each day‚Äôs puzzle using R or Python:\nThis method allows me to both strengthen my already substantial R skills and also improve my fluency in Python, a language in which I have more progress to make.\nI‚Äôll aim to post the solutions in a conversational, narrative manner, sharing not only the final code, but also the thought process I followed to solve each problem."
  },
  {
    "objectID": "2023/day/2023-introduction/index.html#on-llms-usage",
    "href": "2023/day/2023-introduction/index.html#on-llms-usage",
    "title": "2023: Introduction",
    "section": "On LLMs usage",
    "text": "On LLMs usage\nI‚Äôm adhering to the guidelines and suggestions made by the Advent of Code team regarding the use of LLMs like ChatGPT to solve the puzzles. That means I‚Äôm not using ChatGPT‚Äôs help to arrive at the solutions I‚Äôm posting on this website. However, once I‚Äôm done with a problem (that means, either solving it or giving up), I may use LLMs to seek feedback or explore alternative approaches."
  },
  {
    "objectID": "fonts/Readme.html",
    "href": "fonts/Readme.html",
    "title": "iA-Fonts",
    "section": "",
    "text": "iA-Fonts\nThe iA Writer fonts comes bundled with iA Writer for for Android, Windows, Mac, iPadOS and iOS\nFor in depth explanation of iA Writer Mono, Duo, and Quattro please read our blog entry on Duospace and on iA Writer Mono, Duo, and Quattro\nThis is a modification of IBM‚Äôs Plex font. The upstream project is here Please read the licensing file before working with it.\nIf you fork or use our fonts, please reference iA Writer clearly. Use them creatively.\nDon‚Äôt be a copycat. With or without the fonts, do not clone our products or our website. Selling our work under your name is blatantly disrespectful and criminal. Distributing knockoffs of our work for free doesn‚Äôt make you Robin Hood either. We do not approve of free plugins or themes for other apps and other counterfeits that imitate our products. They‚Äôre poor quality, they undermine our business, and they openly violate our copyright. Due to their poor quality, they tarnish our reputation. They‚Äôre unethical, illegal, and lame."
  },
  {
    "objectID": "2022.html",
    "href": "2022.html",
    "title": "2022",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2022: Day 1\n\n\nbase R, lists\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code",
    "section": "",
    "text": "Hi there! Welcome to this mini-site where I‚Äôll be sharing my solutions to the Advent of Code puzzles. Advent of Code is a series of increasingly difficult programming challenges, released daily each year throughout December in the run-up to Christmas.\nTo see my solutions and notes, just click on the corresponding year in the top navigation bar (though, as of now, I‚Äôve only published solutions for 2023).\nThis website is created using the EllaKaye/advent-of-code-website-template template repository. In the README of the repo you can find documentation on how to use it and adapt it, in case you can to publish your solutions in a similar format (which you should totally do üòÅ)."
  },
  {
    "objectID": "index.html#on-llms-usage",
    "href": "index.html#on-llms-usage",
    "title": "Advent of Code",
    "section": "On LLMs usage",
    "text": "On LLMs usage\nI‚Äôm adhering to the guidelines and suggestions made by the Advent of Code team regarding the use of LLMs like ChatGPT to solve the puzzles. That means I‚Äôm not using ChatGPT‚Äôs help to arrive at the solutions I‚Äôm posting on this website. However, once I‚Äôm done with a problem (that means, either solving it or giving up), I may use LLMs to seek feedback or explore alternative approaches."
  },
  {
    "objectID": "2023.html",
    "href": "2023.html",
    "title": "2023",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2023: Introduction\n\n\nintro\n\n\n\n\n2023: Day 1\n\n\nR, stringr\n\n\n\n\n2023: Day 2\n\n\nR, stringr\n\n\n\n\n2023: Day 3\n\n\npython, arrays\n\n\n\n\n2023: Day 4\n\n\nR, matrices\n\n\n\n\n2023: Day 6\n\n\npython, optimisation\n\n\n\n\n2023: Day 8\n\n\npython, graphs\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "2022/day/1/index.html",
    "href": "2022/day/1/index.html",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#setup",
    "href": "2022/day/1/index.html#setup",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#part-1",
    "href": "2022/day/1/index.html#part-1",
    "title": "2022: Day 1",
    "section": "Part 1",
    "text": "Part 1\nI‚Äôm including this post in the website example to demonstrate what a typical post will look like, using post-template, in the _templates directory as a starting point. This post is created by a call to aoc_new_day(1, 2022). It can be deleted with a call to aoc_delete_day(1, 2022), or all posts and the listing for the year can be deleted with aoc_delete_year(2022).\n\n\n\n\n\n\nNote\n\n\n\nThis is Ella Kaye‚Äôs solution1, with her puzzle input. If attempting this challenge yourself, your solution will be different.\n\n\n\n\nToggle the code\nlibrary(aochelpers)\ninput &lt;- aoc_input_vector(1, 2022, \"numeric\")\n\n\nI‚Äôm using the aoc_input_vector() function from the aochelpers package to read in the data, but otherwise using base R functions (including the native pipe, |&gt;) for this puzzle.\nIn this challenge, we‚Äôre given groups of numbers and we need to find the sum of each group. Our solution is the largest of these. The groups are separated by a blank line. When reading in the input as a numeric vector, these are coerced to NA. We can identify the new groups by the NA values, produce an index for them with cumsum(is.na(input)), which increments when a new NA is reached, then use this with split() to split the input into a list of vectors, one for each group. We need the argument na.rm = TRUE in sapply() because each vector, other than the first, starts with NA, as that‚Äôs where it was split.\n\n\nToggle the code\ntotals &lt;- split(input, cumsum(is.na(input))) |&gt; \n  sapply(sum, na.rm = TRUE) \n\nmax(totals)\n\n\n[1] 66719"
  },
  {
    "objectID": "2022/day/1/index.html#part-2",
    "href": "2022/day/1/index.html#part-2",
    "title": "2022: Day 1",
    "section": "Part 2",
    "text": "Part 2\nThis is similar, except we want to find the sum of the sums of the top three groups.\n\n\nToggle the code\ntotals |&gt; \n  sort() |&gt; \n  tail(3) |&gt; \n  sum()\n\n\n[1] 198551"
  },
  {
    "objectID": "2022/day/1/index.html#footnotes",
    "href": "2022/day/1/index.html#footnotes",
    "title": "2022: Day 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nElla is the author of this website template and of the aochelpers package, and the author of this demo post.‚Ü©Ô∏é"
  },
  {
    "objectID": "fonts/LICENSE.html",
    "href": "fonts/LICENSE.html",
    "title": "iA Writer Typeface",
    "section": "",
    "text": "iA Writer Typeface\nCopyright ¬© 2018 Information Architects Inc.¬†with Reserved Font Name ‚ÄúiA Writer‚Äù\n\n\nBased on IBM Plex Typeface\nCopyright ¬© 2017 IBM Corp.¬†with Reserved Font Name ‚ÄúPlex‚Äù\n\n\nLicense\nThis Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL\n\n\n\nSIL OPEN FONT LICENSE Version 1.1 - 26 February 2007\n\n\n\nPREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.\nThe OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.\nDEFINITIONS ‚ÄúFont Software‚Äù refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.\n‚ÄúReserved Font Name‚Äù refers to any names specified as such after the copyright statement(s).\n‚ÄúOriginal Version‚Äù refers to the collection of Font Software components as distributed by the Copyright Holder(s).\n‚ÄúModified Version‚Äù refers to any derivative made by adding to, deleting, or substituting ‚Äì in part or in whole ‚Äì any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.\n‚ÄúAuthor‚Äù refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.\nPERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:\n\nNeither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.\nOriginal or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.\nNo Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.\nThe name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.\nThe Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.\n\nTERMINATION This license becomes null and void if any of the above conditions are not met.\nDISCLAIMER THE FONT SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE."
  },
  {
    "objectID": "2023/day/2/index.html",
    "href": "2023/day/2/index.html",
    "title": "2023: Day 2",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nThere are three types of cubes: green, red, and blue.\nSecret number of each type in a bag, have to figure out number.\nWe have ‚Äúsample data‚Äù from the bag.\nThe input includes info (samples) from previous games.\nGames are identified by an ID (e.g., Game 11).\n\nExample:\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\nIn Game 1, three sets of cubes are sampled from the bag (then returned). The first set contains 3 blue and 4 red cubes; the second set has 1 red cube, 2 green cubes, and 6 blue cubes; the third set consists solely of 2 green cubes.\nWhich games would have been possible if the bag had contained only 12 red cubes, 13 green cubes, and 14 blue cubes? Game 3 would have been impossible as it required 20 red cubes at one point.\nAfter filtering out the impossible games, we can sum their IDs (for instance, in this example, we would obtain a total of 8)."
  },
  {
    "objectID": "2023/day/2/index.html#setup",
    "href": "2023/day/2/index.html#setup",
    "title": "2023: Day 2",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nThere are three types of cubes: green, red, and blue.\nSecret number of each type in a bag, have to figure out number.\nWe have ‚Äúsample data‚Äù from the bag.\nThe input includes info (samples) from previous games.\nGames are identified by an ID (e.g., Game 11).\n\nExample:\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\nIn Game 1, three sets of cubes are sampled from the bag (then returned). The first set contains 3 blue and 4 red cubes; the second set has 1 red cube, 2 green cubes, and 6 blue cubes; the third set consists solely of 2 green cubes.\nWhich games would have been possible if the bag had contained only 12 red cubes, 13 green cubes, and 14 blue cubes? Game 3 would have been impossible as it required 20 red cubes at one point.\nAfter filtering out the impossible games, we can sum their IDs (for instance, in this example, we would obtain a total of 8)."
  },
  {
    "objectID": "2023/day/2/index.html#part-1",
    "href": "2023/day/2/index.html#part-1",
    "title": "2023: Day 2",
    "section": "Part 1",
    "text": "Part 1\n\nDetermine which games would have been possible if the bag had been loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?\n\n\n\nToggle the code\nlibrary(tidyverse)\nlibrary(here)\n\ninput &lt;- read_file(here(\"2023/day/2/input\")) %&gt;%\n  str_split_1(pattern = '\\n') %&gt;%\n  magrittr::extract(1:100)\n\ninput[1:10]\n\n\n [1] \"Game 1: 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"                                                \n [2] \"Game 2: 11 green, 7 blue, 15 red; 13 red, 6 green, 2 blue; 7 green, 9 red, 10 blue; 5 blue, 1 red, 11 green; 4 blue, 18 green; 4 red, 8 blue, 18 green\"\n [3] \"Game 3: 7 red, 10 green, 4 blue; 2 blue, 3 green, 5 red; 9 red, 7 green, 3 blue; 3 blue, 6 green, 18 red\"                                              \n [4] \"Game 4: 1 blue, 2 green, 5 red; 10 red, 1 blue, 3 green; 14 red\"                                                                                       \n [5] \"Game 5: 16 red, 4 green, 19 blue; 13 blue, 9 red; 7 green, 14 red, 2 blue; 5 green, 18 blue, 4 red; 7 red, 2 blue, 3 green; 8 blue, 12 green\"          \n [6] \"Game 6: 3 blue, 8 green; 4 red, 5 green; 5 red, 8 blue, 5 green; 8 blue, 4 green; 3 red, 7 green, 2 blue\"                                              \n [7] \"Game 7: 7 red, 2 blue; 5 red, 6 green; 10 red; 2 blue, 12 red, 2 green; 4 red, 1 blue, 1 green; 9 green, 2 blue, 10 red\"                               \n [8] \"Game 8: 3 red, 7 green, 3 blue; 2 green, 3 blue, 3 red; 3 blue, 4 green, 1 red; 3 blue, 3 red; 2 blue, 6 green; 2 red, 7 green, 1 blue\"                \n [9] \"Game 9: 5 red, 6 green; 6 red; 2 blue, 3 green, 9 red; 6 green, 2 blue\"                                                                                \n[10] \"Game 10: 5 red, 8 blue, 5 green; 15 red, 6 green, 7 blue; 8 blue, 6 red, 5 green; 5 green, 2 blue; 12 red, 6 blue; 6 green, 16 red, 6 blue\"            \n\n\nWhat is the most suitable data structure for solving this problem?\nI believe I need only this information:\n\nThe ID of the game.\nThe maximum number of cubes for each colour.\n\nRegarding the number of cubes: is the maximum alone sufficient?\nConsider there are 10 red cubes.\nIf the maximum is 10 or less, the game was possible. If the maximum is 11 or more, the game was impossible.\nIndeed, I just need the maximum number of cubes for each colour in each game.\nI think a tibble would be a suitable data structure to store this information.\nLet‚Äôs start with the first game:\n\n\nToggle the code\nfirst_game &lt;- input[1]\nfirst_game\n\n\n[1] \"Game 1: 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"\n\n\nSpecial characters to handle:\n\n:\n,\n`;\n\n\n\nToggle the code\ngame_data &lt;-\n  tibble(\n    input = input\n  ) %&gt;%\n    separate(\n      input,\n      into = c(\"id\", \"data\"),\n      sep = \": \"\n    ) %&gt;%\n    mutate(\n      id = as.integer(str_extract(id, \"\\\\d+\"))\n    )\n\ngame_data\n\n\n# A tibble: 100 √ó 2\n      id data                                                                   \n   &lt;int&gt; &lt;chr&gt;                                                                  \n 1     1 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue‚Ä¶\n 2     2 11 green, 7 blue, 15 red; 13 red, 6 green, 2 blue; 7 green, 9 red, 10 ‚Ä¶\n 3     3 7 red, 10 green, 4 blue; 2 blue, 3 green, 5 red; 9 red, 7 green, 3 blu‚Ä¶\n 4     4 1 blue, 2 green, 5 red; 10 red, 1 blue, 3 green; 14 red                \n 5     5 16 red, 4 green, 19 blue; 13 blue, 9 red; 7 green, 14 red, 2 blue; 5 g‚Ä¶\n 6     6 3 blue, 8 green; 4 red, 5 green; 5 red, 8 blue, 5 green; 8 blue, 4 gre‚Ä¶\n 7     7 7 red, 2 blue; 5 red, 6 green; 10 red; 2 blue, 12 red, 2 green; 4 red,‚Ä¶\n 8     8 3 red, 7 green, 3 blue; 2 green, 3 blue, 3 red; 3 blue, 4 green, 1 red‚Ä¶\n 9     9 5 red, 6 green; 6 red; 2 blue, 3 green, 9 red; 6 green, 2 blue         \n10    10 5 red, 8 blue, 5 green; 15 red, 6 green, 7 blue; 8 blue, 6 red, 5 gree‚Ä¶\n# ‚Ñπ 90 more rows\n\n\nI need to obtain the number of cubes that have appeared for each colour:\n\n\nToggle the code\ngame_data_1 &lt;- game_data[[\"data\"]][[1]]\ngame_data_1\n\n\n[1] \"8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"\n\n\nI think I can use str_match_all with a capturing pattern associated with the colours and simply ignore everything else.\n\n\nToggle the code\nn_cubes_colour &lt;- \n  str_match_all(\n    game_data_1,\n    \"(\\\\d+) ([red|green|blue]+)\"\n  )[[1]][,2:3]\n\ncolnames(n_cubes_colour) &lt;- c(\"n\", \"colour\")\n\nn_cubes_colour %&gt;%\n  as_tibble() %&gt;%\n  group_by(colour) %&gt;%\n  summarise(n = max(as.numeric(n)))\n\n\n# A tibble: 3 √ó 2\n  colour     n\n  &lt;chr&gt;  &lt;dbl&gt;\n1 blue       4\n2 green      8\n3 red        8\n\n\nNow it‚Äôs time to wrap the code above into a function and apply it to all the games:\n\n\nToggle the code\nget_count_cubes &lt;-\n  function(x) {\n    matrix_count_cubes &lt;-\n    str_match_all(\n      x,\n      \"(\\\\d+) ([red|green|blue]+)\"\n    )[[1]][,2:3]\n\n    colnames(matrix_count_cubes) &lt;- c(\"n\", \"colour\")\n\n    matrix_count_cubes %&gt;%\n      as_tibble() %&gt;%\n      group_by(colour) %&gt;%\n      summarise(n = max(as.numeric(n)))\n}\n\n\n(I‚Äôm concerned this approach may not scale effectively if the input for the second part is significantly larger.)\n\n\nToggle the code\ngame_data_tidy &lt;- \n  game_data %&gt;%\n  mutate(data = map(data, get_count_cubes)) %&gt;%\n  unnest(data) %&gt;%\n  pivot_wider(\n    id_cols = id,\n    names_from = colour,\n    values_from = n\n  )\n\n\nMy attempted solution to determine which games would have been possible if the bag had been loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?.\n\n\nToggle the code\ngame_data_tidy %&gt;%\n  filter(red &lt;= 12, green &lt;= 13, blue &lt;= 14) %&gt;%\n  pull(id) %&gt;%\n  sum()\n\n\n[1] 2085\n\n\nIT IS CORRECT!!! ü•≥ü•≥ü•≥ü•≥"
  },
  {
    "objectID": "2023/day/2/index.html#part-2",
    "href": "2023/day/2/index.html#part-2",
    "title": "2023: Day 2",
    "section": "Part 2",
    "text": "Part 2\n\nIn each game you played, what is the fewest number of cubes of each color that could have been in the bag to make the game possible?\n\n\nThe power of a set of cubes is equal to the numbers of red, green, and blue cubes multiplied together. The power of the minimum set of cubes in game 1 is 48. In games 2-5 it was 12, 1560, 630, and 36, respectively. Adding up these five powers produces the sum 2286.\n\n\nFor each game, find the minimum set of cubes that must have been present. What is the sum of the power of these sets?\n\nGiven the data structure I‚Äôm using, this second part seems easy.\n\n\nToggle the code\ngame_data_tidy %&gt;%\n  summarise(sum(red*green*blue))\n\n\n# A tibble: 1 √ó 1\n  `sum(red * green * blue)`\n                      &lt;dbl&gt;\n1                     79315\n\n\nIt is correct too!!"
  },
  {
    "objectID": "2023/day/6/index.html",
    "href": "2023/day/6/index.html",
    "title": "2023: Day 6",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nWe arrive to Island Island\nThere should be a large pile of sand but there isn‚Äôt\nBoat races to win trip to Desert Island: fixed amount of time and boat has to travel as far as it can\nInput: time allowed for each race and best distance until now\nTo win, we need to go farther than each current record holder\nBoats are toy boats: we press a button to charge them, and release them to allow them to move.\n\n\nBoats move faster if their button was held longer, but time spent holding the button counts against the total race time. You can only hold the button at the start of the race, and boats don‚Äôt move until the button is released.\n\n\nYour toy boat has a starting speed of zero millimeters per millisecond. For each whole millisecond you spend at the beginning of the race holding down the button, the boat‚Äôs speed increases by one millimeter per millisecond.\n\n\nThis is an optimisation problem.\nFor each problem, we have several ways (amount of time we can press the button) that allow us to beat the current record holder.\n\n\nTo see how much margin of error you have, determine the number of ways you can beat the record in each race; in this example, if you multiply these values together, you get 288 (4 * 8 * 9)."
  },
  {
    "objectID": "2023/day/6/index.html#setup",
    "href": "2023/day/6/index.html#setup",
    "title": "2023: Day 6",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nWe arrive to Island Island\nThere should be a large pile of sand but there isn‚Äôt\nBoat races to win trip to Desert Island: fixed amount of time and boat has to travel as far as it can\nInput: time allowed for each race and best distance until now\nTo win, we need to go farther than each current record holder\nBoats are toy boats: we press a button to charge them, and release them to allow them to move.\n\n\nBoats move faster if their button was held longer, but time spent holding the button counts against the total race time. You can only hold the button at the start of the race, and boats don‚Äôt move until the button is released.\n\n\nYour toy boat has a starting speed of zero millimeters per millisecond. For each whole millisecond you spend at the beginning of the race holding down the button, the boat‚Äôs speed increases by one millimeter per millisecond.\n\n\nThis is an optimisation problem.\nFor each problem, we have several ways (amount of time we can press the button) that allow us to beat the current record holder.\n\n\nTo see how much margin of error you have, determine the number of ways you can beat the record in each race; in this example, if you multiply these values together, you get 288 (4 * 8 * 9)."
  },
  {
    "objectID": "2023/day/6/index.html#part-1",
    "href": "2023/day/6/index.html#part-1",
    "title": "2023: Day 6",
    "section": "Part 1",
    "text": "Part 1\n\n\nToggle the code\nimport pandas as pd\nimport numpy as np\n\n\n\n\nToggle the code\nf = open(\"input\", \"r\")\ninput = f.readlines()\n# input is a list\n\n\nExtracting the times:\n\n\nToggle the code\nimport re\ntimes = re.findall('[0-9]+', input[0])\ntimes = list(map(int, times))\n\n\nExtracting the distances:\n\n\nToggle the code\ndistances = re.findall('[0-9]+', input[1])\ndistances = list(map(int, distances))\n\n\nNext, I think I could write a function that, for any pair of times and distances, returns the count of different values of time that allow to surpass the current record.\nFirst, let‚Äôs write the code of a particular case (using the example in the prompt)\n\n\nToggle the code\ntime = 7\ndistance = 9\nn_possible_wins = 0\n\nfor i in range(time):\n  speed = i\n  available_time = time - i\n  my_distance = speed*available_time\n\n  if my_distance &gt; distance:\n    n_possible_wins += 1\n\nprint(n_possible_wins)\n\n\n4\n\n\n\n\nToggle the code\ndef calculate_n_ways_to_win(time, distance):\n  n_possible_wins = 0\n\n  for i in range(time):\n    speed = i\n    available_time = time - i\n    my_distance = speed*available_time\n\n    if my_distance &gt; distance:\n      n_possible_wins += 1\n\n  return(n_possible_wins)\n\n\n\n\nToggle the code\ncalculate_n_ways_to_win(7, 9)\n\n\n4\n\n\nNow I need to iterate across the two lists. I would like to do that using something similar to map2, instead of a for loop\n\n\nToggle the code\nn_ways = list(map(calculate_n_ways_to_win, times, distances))\n\n\n\n\nToggle the code\nimport operator\nfrom functools import reduce\n\nreduce(operator.mul, n_ways)\n\n\n1660968"
  },
  {
    "objectID": "2023/day/6/index.html#part-2",
    "href": "2023/day/6/index.html#part-2",
    "title": "2023: Day 6",
    "section": "Part 2",
    "text": "Part 2\nThe input interpretation changed and all the values of time and distance now actually represent two big numbers.\n\n\nToggle the code\ncalculate_n_ways_to_win(47986698, 400121310111540)\n\n\n26499773"
  },
  {
    "objectID": "2023/day/1/index.html",
    "href": "2023/day/1/index.html",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a ‚Äúcalibration document‚Äù\nHas been ‚Äúamended‚Äù by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#setup",
    "href": "2023/day/1/index.html#setup",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a ‚Äúcalibration document‚Äù\nHas been ‚Äúamended‚Äù by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#part-1",
    "href": "2023/day/1/index.html#part-1",
    "title": "2023: Day 1",
    "section": "Part 1",
    "text": "Part 1\n\n\nToggle the code\nlibrary(tidyverse)\nlibrary(here)\n\n\nTransforming the data to an appropriate data structure:\n\n\nToggle the code\namended &lt;- read_lines(here('2023', 'day', '1', 'input'))\namended[1:10]\n\n\n [1] \"nqninenmvnpsz874\"                          \n [2] \"8twofpmpxkvvdnpdnlpkhseven4ncgkb\"          \n [3] \"six8shdkdcdgseven8xczqrnnmthreecckfive\"    \n [4] \"qlcnz54dd75nine7jfnlfgz\"                   \n [5] \"7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr\"\n [6] \"cdhmktwo6kjqbprvfour8\"                     \n [7] \"ninekkvkeight9three\"                       \n [8] \"ms9five71lrfpqxqlbj\"                       \n [9] \"9five9sevenldshqfgcnq\"                     \n[10] \"1one4seven\"                                \n\n\n\nSolving for a particular case\n\n\nToggle the code\n(first_case &lt;- amended[1])\n\n\n[1] \"nqninenmvnpsz874\"\n\n\nExtracting the numbers\n\n\nToggle the code\n(matrix_str_numbers &lt;-\n  str_extract_all(first_case, pattern = '\\\\d', simplify = TRUE))\n\n\n     [,1] [,2] [,3]\n[1,] \"8\"  \"7\"  \"4\" \n\n\nExtracting all the rows from columns one and three (the first and last number of each row)\n\n\nToggle the code\nnumbers_i_want &lt;- matrix_str_numbers[, c(1,3)]\nnumbers_i_want\n\n\n[1] \"8\" \"4\"\n\n\n(This code will generalise ONLY IF all the other rows have 3 numbers too).\nThe following code returns the first and last number ‚Äúpasted‚Äù together and converts the result from string to numeric.\n\n\nToggle the code\nstringr::str_flatten(numbers_i_want) %&gt;%\n  as.numeric()\n\n\n[1] 84\n\n\nNow let‚Äôs try to generalise to all input rows:\n\n\nToggle the code\namended %&gt;%\n  str_extract_all(pattern = '\\\\d', simplify = TRUE) %&gt;%\n  head(5)\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n[1,] \"8\"  \"7\"  \"4\"  \"\"   \"\"   \"\"   \"\"  \n[2,] \"8\"  \"4\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[3,] \"8\"  \"8\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[4,] \"5\"  \"4\"  \"7\"  \"5\"  \"7\"  \"\"   \"\"  \n[5,] \"7\"  \"2\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n\n\nOh no. Rows have a different quantity of digits.\nMaybe using simplify=TRUE was a mistake here. Given that each element has a different quantity of digits, a list seems to be a more suitable data structure:\n\n\nToggle the code\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(5)\n\nlist_digits_preview\n\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nNow, how can I extract the first and last element from each element of the list? My gut feeling is that I‚Äôll need purrr for this:\npluck and keep_at seem to be useful functions for this task\n\n\nToggle the code\nlist_digits_preview %&gt;%\n  # This should extract the first and last digit from each element of the list \n  map(~keep_at(., c(1, length(.))))\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nIt is working!!\nNow I‚Äôll apply the action to the whole list:\n\n\nToggle the code\nlist_useful_digits &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(~keep_at(., c(1, length(.))))\n\nlist_useful_digits[1:10]\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nHmmm‚Ä¶ Why does element 7 have only 1 digit?\n\n\nToggle the code\namended[7]\n\n\n[1] \"ninekkvkeight9three\"\n\n\nIt‚Äôs got just one digit as a number, but there are other digits written out in words. Should we count those? The prompt isn‚Äôt really clear about this. But since the example only talks about digits as numbers, I guess I‚Äôll just go with those for now. If I‚Äôve got this wrong and my solution gets rejected, well, I can always give it another shot\nNow let‚Äôs concatenate the digits row-wise, turn them into a number and add them up:\n\n\nToggle the code\nsolution &lt;- \n  list_useful_digits %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution\n\n\n[1] 39347\n\n\nüëéüèΩ Solution was rejected. The website says it‚Äôs too low ü§î\nThe most likely suspect here is the way map(~keep_at(., c(1, length(.)))) is handling the rows with only one digit.\nSome alternatives I could try:\n\nIf the input row has only one digit, then use it as first AND last digit when building the number (e.g.¬†if the row only contains 7, the number I would obtain from that row should be 77).\nTake into account digits that are written as words (e.g.¬†‚Äúthree‚Äù). This is less likely to work and it would be weird for the exercise to expect people to do this and not mentioning it explicitely in the prompt or the examples.\n\nI‚Äôll go with alternative 1.\n\n\nHandling rows with just one digit\nI‚Äôll take a slice from the first 10 rows, as the first case with one digit appears in row 7:\n\n\nToggle the code\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(10)\n\nlist_digits_preview\n\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"7\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nI have a feeling that purrr::pluck may do the trick here:\n\n\nToggle the code\nget_first_and_last &lt;- function(x) {\n  c(pluck(x, 1), pluck(x, length(x)))\n}\n\nlist_digits_preview %&gt;%\n  map(get_first_and_last)\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\" \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nThis function does what I want (and yes, using pluck is a bit unnecessary since I could just have used regular subsetting, e.g.¬†x[[1]] and x[[length(x)]], but I‚Äôm doing this with the purrr cheat sheet in front of me, so pluck was what came to my mind).\n2nd attempt, this time using get_first_and_last.\n\n\nToggle the code\nsolution2 &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution2\n\n\n[1] 56397\n\n\nThis is the correct solution!! ü•≥ü•≥ü•≥\nOnto the second part!"
  },
  {
    "objectID": "2023/day/1/index.html#part-2",
    "href": "2023/day/1/index.html#part-2",
    "title": "2023: Day 1",
    "section": "Part 2",
    "text": "Part 2\nSaw this one coming: now I need to tackle the digits spelled out as words üò¨.\n\nFirst (naive) attempt\nIMHO the simplest approach is to write a function that converts digits spelled out in a string into their numeric form. Then, I can incorporate this function into my pipeline using a map call, right before str_extract_all.\n\n\nToggle the code\ncase_with_spelled_digit &lt;- amended[7]\ncase_with_spelled_digit\n\n\n[1] \"ninekkvkeight9three\"\n\n\n\n\nToggle the code\ncase_with_spelled_digit %&gt;%\n  str_replace_all(\n    c(\n      \"nine\" = \"9\",\n      \"eight\" = \"8\",\n      \"three\" = \"3\"\n    )\n  )\n\n\n[1] \"9kkvk893\"\n\n\nWorking as expected.\nNow let‚Äôs apply the function to the full data.\nI‚Äôll start by creating the replacement vector (although I‚Äôm pretty sure it‚Äôs already a part of some R package that‚Äôs slipping my mind right now).\n\n\nToggle the code\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\"\n)\n\n\n\n\nToggle the code\nsolution3 &lt;- \n  amended %&gt;%\n  str_replace_all(pattern = digits) %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution3\n\n\n[1] 55266\n\n\nThe solution wasn‚Äôt right.\n\n\nSecond attempt: handling overlapping patterns\nTime to take a closer look at the pipeline using a tibble.\n\n\nToggle the code\ntibble(\n  original = amended,\n  new = original %&gt;%\n    str_replace_all(pattern = digits),\n  digits = amended %&gt;%\n    str_replace_all(pattern = digits) %&gt;%\n    str_extract_all(pattern = '\\\\d') %&gt;%\n    map(get_first_and_last) %&gt;%\n    map(str_flatten) %&gt;%\n    as_vector()\n)\n\n\n# A tibble: 1,000 √ó 3\n   original                                   new                         digits\n   &lt;chr&gt;                                      &lt;chr&gt;                       &lt;chr&gt; \n 1 nqninenmvnpsz874                           nq9nmvnpsz874               94    \n 2 8twofpmpxkvvdnpdnlpkhseven4ncgkb           82fpmpxkvvdnpdnlpkh74ncgkb  84    \n 3 six8shdkdcdgseven8xczqrnnmthreecckfive     68shdkdcdg78xczqrnnm3cck5   65    \n 4 qlcnz54dd75nine7jfnlfgz                    qlcnz54dd7597jfnlfgz        57    \n 5 7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr 7vrdhggdkqbnltlgpkkvsdxn2m‚Ä¶ 72    \n 6 cdhmktwo6kjqbprvfour8                      cdhmk26kjqbprv48            28    \n 7 ninekkvkeight9three                        9kkvk893                    93    \n 8 ms9five71lrfpqxqlbj                        ms9571lrfpqxqlbj            91    \n 9 9five9sevenldshqfgcnq                      9597ldshqfgcnq              97    \n10 1one4seven                                 1147                        17    \n# ‚Ñπ 990 more rows\n\n\nHypothesis: The issue might arise in instances like \"zoneight234\", where the spellings of two numbers are overlapping.\n\n\nToggle the code\nstr_replace_all(\"zoneight234\", pattern = digits)\n\n\n[1] \"z1ight234\"\n\n\nI‚Äôll try to handle these cases to make sure that every spelled-out digit in the text is returned, even if they overlap.\nMaybe I can get closer to that by using the stringi package?\n\n\nToggle the code\nstringi::stri_replace_all_regex(\"zoneight234\", pattern = names(digits), replacement = digits, vectorize_all = FALSE)\n\n\n[1] \"z1ight234\"\n\n\nThis is not working.\nSomething else I could try:\n\nUsing the _first and _last functions from stringi to identify digits, whether they are numerically written or spelled out.\n\n\nThen, replacing the spelled-out digits that appear at either the beginning or end of the string.\n\n\n\nToggle the code\nproblematic_string &lt;- \"zone2344oneight\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\nall_digits_vector &lt;- c(\n  names(digits),\n  0:9\n)\n\nstringi::stri_extract_last_regex(\n  str = problematic_string,\n  pattern = all_digits_vector\n)\n\n\n [1] \"one\"   NA      NA      NA      NA      NA      NA      \"eight\" NA     \n[10] NA      NA      \"2\"     \"3\"     \"4\"     NA      NA      NA      NA     \n[19] NA     \n\n\nOkay, this method DOES return all the digits that appear in the string, but I end up losing details about where the digits are positioned, which is needed for identifying the first and last digits in each row.\nMore ideas:\n\nUsing str_localte_all, a stringr function that allows matching each digit as an separate pattern (thus avoiding the overlap problem) and gives information about the POSITION of the pattern. Then use that info to find the first and the last match in each row.\n\nExample:\n\n\nToggle the code\nstringr::str_locate_all(\n  string = problematic_string,\n  pattern = all_digits_vector\n)[1:8]\n\n\n[[1]]\n     start end\n[1,]     2   4\n[2,]     9  11\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n\n[[4]]\n     start end\n\n[[5]]\n     start end\n\n[[6]]\n     start end\n\n[[7]]\n     start end\n\n[[8]]\n     start end\n[1,]    11  15\n\n\n\nCRAZY IDEA!!! What if I reverse the string, and then look for first match of the reversed names of the digits??\n\nAfter all, the only matches that matter for solving this puzzle are the first one and the last one. For the first match, overlapping is not a real problem because it causes the second digit not to match (example: ‚Äúeight‚Äù in ‚Äúoneight‚Äù, here ‚Äúone‚Äù is always matched or detected).\nReversing the strings and their patterns could mirror this dynamic when matching the last digit.\n\n\nToggle the code\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nvector_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\n\nIn this example, I should be able to match ‚Äúeight‚Äù as the last string, despite it overlapping with ‚Äúone‚Äù.\n\n\nToggle the code\nproblematic_string\n\n\n[1] \"zone2344oneight\"\n\n\nMy strategy is to invert it and then look for ‚Äúthgie‚Äù üòÇüíÄ\n\n\nToggle the code\nreversed_problematic_string &lt;- \n  stringi::stri_reverse(\n  problematic_string\n)\nreversed_problematic_string\n\n\n[1] \"thgieno4432enoz\"\n\n\n\n\nToggle the code\nfound_reversed_string &lt;- str_extract(\n  reversed_problematic_string,\n  \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n)\n\nfound_reversed_string\n\n\n[1] \"thgie\"\n\n\nAfter finding it, I can use the following code to get back the original number\n\n\nToggle the code\nvector_reversed[found_reversed_string]\n\n\nthgie \n  \"8\" \n\n\nIt‚Äôs working. Now, let‚Äôs wrap this pipeline in a function to apply it to whole dataset:\n\n\nToggle the code\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\ndigits_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\nget_last_number &lt;- function(x) {\n  found_reversed_string &lt;-\n    stringi::stri_reverse(x) %&gt;%\n    str_extract(regex_reversed)\n\n  digits_reversed[found_reversed_string] %&gt;%\n    set_names(NULL)\n}\n\nget_first_number &lt;- function(x) {\n  found_string &lt;- str_extract(\n    x,\n    all_digits_regex\n  )\n\n  digits[found_string] %&gt;%\n    set_names(NULL)\n\n}\nget_first_number(problematic_string)\n\n\n[1] \"1\"\n\n\nToggle the code\nget_last_number(problematic_string)\n\n\n[1] \"8\"\n\n\nIt‚Äôs working as intended, now let‚Äôs generalise it:\n\n\nToggle the code\ntibble(\n  amended = amended,\n  first_digit = get_first_number(amended),\n  last_digit = get_last_number(amended),\n  combined = as.integer(str_c(first_digit, last_digit))\n) %&gt;%\n  pull(combined) %&gt;%\n  sum()\n\n\n[1] 55701\n\n\nIT WORKED!! THIS WAS THE RIGHT ANSWER!!! ü•≥ü•≥ü•πü•π"
  },
  {
    "objectID": "2023/day/8/index.html",
    "href": "2023/day/8/index.html",
    "title": "2023: Day 8",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nInput has left/right instructions and a network of labelled nodes.\nWe‚Äôre meant to use the left/right instructions to navigate the network.\nAAA is where we are and ZZZ is where we‚Äôre going.\n\nExample of how the nodes are navigated:\nRL\n\nAAA = (BBB, CCC)\nBBB = (DDD, EEE)\nCCC = (ZZZ, GGG)\nDDD = (DDD, DDD)\nEEE = (EEE, EEE)\nGGG = (GGG, GGG)\nZZZ = (ZZZ, ZZZ)\n\nStarting with AAA, you need to look up the next element based on the next left/right instruction in your input. In this example, start with AAA and go right (R) by choosing the right element of AAA, CCC. Then, L means to choose the left element of CCC, ZZZ. By following the left/right instructions, you reach ZZZ in 2 steps.\n\n\nyou might not find ZZZ right away. If you run out of left/right instructions, repeat the whole sequence of instructions as necessary: RL really means RLRLRLRLRLRLRLRL‚Ä¶ and so on\n\nThe Question:\n\nStarting at AAA, follow the left/right instructions. How many steps are required to reach ZZZ?"
  },
  {
    "objectID": "2023/day/8/index.html#setup",
    "href": "2023/day/8/index.html#setup",
    "title": "2023: Day 8",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nInput has left/right instructions and a network of labelled nodes.\nWe‚Äôre meant to use the left/right instructions to navigate the network.\nAAA is where we are and ZZZ is where we‚Äôre going.\n\nExample of how the nodes are navigated:\nRL\n\nAAA = (BBB, CCC)\nBBB = (DDD, EEE)\nCCC = (ZZZ, GGG)\nDDD = (DDD, DDD)\nEEE = (EEE, EEE)\nGGG = (GGG, GGG)\nZZZ = (ZZZ, ZZZ)\n\nStarting with AAA, you need to look up the next element based on the next left/right instruction in your input. In this example, start with AAA and go right (R) by choosing the right element of AAA, CCC. Then, L means to choose the left element of CCC, ZZZ. By following the left/right instructions, you reach ZZZ in 2 steps.\n\n\nyou might not find ZZZ right away. If you run out of left/right instructions, repeat the whole sequence of instructions as necessary: RL really means RLRLRLRLRLRLRLRL‚Ä¶ and so on\n\nThe Question:\n\nStarting at AAA, follow the left/right instructions. How many steps are required to reach ZZZ?"
  },
  {
    "objectID": "2023/day/8/index.html#part-1",
    "href": "2023/day/8/index.html#part-1",
    "title": "2023: Day 8",
    "section": "Part 1",
    "text": "Part 1\n\n\nToggle the code\nimport pandas as pd\nimport numpy as np\n\n\nFirst I need to load the data in a suitable data structure:\nI‚Äôm going to load the instructions as an array:\n\n\nToggle the code\ninput = open('input', 'r')\ninstructions = input.readline().splitlines()\ninstructions = np.array(list(instructions[0]), dtype='object')\ninstructions\n\n\narray(['L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'L', 'L', 'R', 'R',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L',\n       'L', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'L', 'R', 'R', 'R', 'L', 'R', 'L', 'L', 'R', 'R', 'L', 'R',\n       'L', 'L', 'R', 'L', 'R', 'L', 'L', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'L', 'R', 'R', 'R', 'L', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'L', 'R', 'L', 'L', 'L', 'L', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R',\n       'R', 'L', 'R', 'R', 'L', 'L', 'R', 'L', 'R', 'L', 'R', 'R', 'L',\n       'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R',\n       'R', 'R', 'L', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L',\n       'R', 'R', 'R', 'L', 'R', 'L', 'R', 'R', 'R', 'L', 'L', 'R', 'L',\n       'R', 'L', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R',\n       'R', 'L', 'R', 'L', 'L', 'R', 'R', 'R', 'R'], dtype=object)\n\n\nNow, I need to load the node information.\nGiven that the node names appear to be unique, I could use a dictionary with the node names as keys. The value of each key could be another dictionary with ‚ÄòL‚Äô and ‚ÄòR‚Äô as keys, simplifying navigation through the nodes based on the instructions (I hope).\n\n\nToggle the code\n# Loading the node information in a numpy array\nnodes = np.loadtxt('input', skiprows=2, dtype='str')\n\n# Removing column that doesn't contain useful information\nnodes = nodes[:, [0, 2, 3]]\nnodes = np.char.replace(nodes, '(', '')\nnodes = np.char.replace(nodes, ')', '')\nnodes = np.char.replace(nodes, ',', '')\nnodes[:10]\n\n\narray([['CTK', 'JLT', 'HRF'],\n       ['TQH', 'DKT', 'HGB'],\n       ['HQM', 'XPV', 'TTR'],\n       ['DLL', 'MFK', 'HHS'],\n       ['BVD', 'BXB', 'FDB'],\n       ['TTR', 'BJG', 'MTF'],\n       ['RPR', 'CQL', 'KHJ'],\n       ['KND', 'TVL', 'QMF'],\n       ['SQH', 'XNP', 'MRD'],\n       ['RXM', 'HTR', 'BXT']], dtype='&lt;U3')\n\n\nConverting the numpy array into a dictionary through iteration.\nI‚Äôll create a function that receives a row of the array and creates a key-value pair with ‚ÄòL‚Äô and ‚ÄòR‚Äô keys:\n\n\nToggle the code\ndef create_dict(node):\n  my_dict = {node[0]: {'L': node[1], 'R': node[2]}}\n  return my_dict\n\nnodes_array = np.apply_along_axis(create_dict, axis=1, arr=nodes)\n\nfrom collections import ChainMap\nnodes_dict = dict(ChainMap(*nodes_array))\n\n# Example\nnodes_dict['XLV']\n\n\n{'L': 'VTR', 'R': 'TGD'}\n\n\nNext step is (indefinitely) iterating through the instructions until reaching \"ZZZ\", while keeping track of the number of steps required to do so.\n\n\nToggle the code\nsteps = 0\ncurrent_node = 'AAA'\nlength_instructions = len(instructions)\n\nwhile current_node != 'ZZZ':\n  i_current_instruction = steps % length_instructions \n  current_instruction = instructions[i_current_instruction]\n  current_node = nodes_dict[current_node][current_instruction]\n  steps += 1\n\nprint(f'It took {steps} steps')\n\n\nIt took 16409 steps\n\n\nIt was correct!"
  },
  {
    "objectID": "2023/day/8/index.html#part-2",
    "href": "2023/day/8/index.html#part-2",
    "title": "2023: Day 8",
    "section": "Part 2",
    "text": "Part 2\n\nThe number of nodes with names ending in A is equal to the number ending in Z! If you were a ghost, you‚Äôd probably just start at every node that ends with A and follow all of the paths at the same time until they all simultaneously end up at nodes that end with Z.\n\nFor example:\nLR\n\n11A = (11B, XXX)\n11B = (XXX, 11Z)\n11Z = (11B, XXX)\n22A = (22B, XXX)\n22B = (22C, 22C)\n22C = (22Z, 22Z)\n22Z = (22B, 22B)\nXXX = (XXX, XXX)\n\nHere, there are two starting nodes, 11A and 22A (because they both end with A). As you follow each left/right instruction, use that instruction to simultaneously navigate away from both nodes you‚Äôre currently on. Repeat this process until all of the nodes you‚Äôre currently on end with Z.\n\n\n(If only some of the nodes you‚Äôre on end with Z, they act like any other node and you continue as normal.)\n\n\nSimultaneously start on every node that ends with A. How many steps does it take before you‚Äôre only on nodes that end with Z?\n\nI THINK I can work this out making changes only to the logic and keeping the data structures of the input (instructions and nodes_dict) as they are right now.\nThe initialisation of the current node requires modification, since now we have to start simultaneously from all the nodes that end in ‚ÄòA‚Äô.\n\n\nToggle the code\n# current_node = 'AAA'\nall_nodes = list(nodes_dict.keys())\n\nimport re\npatA = re.compile(r'[A-Z0-9]{2}A')\nstarting_nodes = [node for node in all_nodes if patA.match(node)]\nstarting_nodes\n\n\n['AAA', 'PPA', 'QQA', 'TDA', 'PDA', 'QXA']\n\n\n\n\nToggle the code\nsteps = 0\n\ncurrent_nodes = starting_nodes\n\npatZ = re.compile(r'[A-Z0-9]{2}Z')\nall_z = False\n\nwhile all_z is False:\n  # Code related to iterating thorugh instructions doesn't change\n  # I changed the names to make them more succinct\n  i_curr_ins = steps % length_instructions \n  curr_ins = instructions[i_curr_ins]\n\n  # This code has to change\n  # current_node = nodes_dict[current_node][current_instruction]\n  current_nodes = [nodes_dict[node][curr_ins] for node in current_nodes]\n\n  steps += 1\n  is_z = [bool(patZ.match(node)) for node in current_nodes]\n  all_z = all(is_z)\n  if sum(is_z) &gt; 4:\n    print(current_nodes)\n    print(steps)\n\n\nEven though this code might technically reach the right answer given enough time, it takes way too long to be considered a viable solution.\nI wasn‚Äôt able to come up with a better solution on my own ü•≤ so I took a hint from Reddit where they suggested identifying patterns on the number of steps required to reach a node ending in ‚ÄòZ‚Äô from each of the starting nodes, and then using those patterns to identify a common number in the series.\n\n\nToggle the code\n# Initialization values\nsteps = 0\ncurrent_nodes = starting_nodes\npatZ = re.compile(r'[A-Z0-9]{2}Z')\nall_z = False\n\n# Dictionary of empty lists with the starting nodes as keys\nsteps_ending_z = {}\nfor node in starting_nodes:\n  steps_ending_z[node] = []\n\nsteps_ending_z\n\n\n{'AAA': [], 'PPA': [], 'QQA': [], 'TDA': [], 'PDA': [], 'QXA': []}\n\n\n\n\nToggle the code\nwhile all_z is False and steps &lt; 1000000:\n  # This code is necessary for appropriately reading the instructions\n  i_curr_ins = steps % length_instructions \n  curr_ins = instructions[i_curr_ins]\n\n  current_nodes = [nodes_dict[node][curr_ins] for node in current_nodes]\n\n  # For any node that ends in Z,\n  # add the current value of `steps` to the corresponding list of the dictionary\n  is_z = [False] * len(current_nodes)\n  for i, node in enumerate(current_nodes):\n    if patZ.match(node):\n      is_z[i] = True\n      steps_ending_z[starting_nodes[i]].append(steps)\n  \n  all_z = all(is_z)\n\n  steps += 1\n\n\n\n\nToggle the code\nfor i, node in enumerate(steps_ending_z):\n  print('Starting node:', node)\n  print('Steps to be in node where last letter was Z:\\n', steps_ending_z[node][:10])\n  print('Steps between nodes ending in Z:')\n  print(np.diff(steps_ending_z[node][:15]))\n  print('\\n')\n\n\nStarting node: AAA\nSteps to be in node where last letter was Z:\n [16408, 32817, 49226, 65635, 82044, 98453, 114862, 131271, 147680, 164089]\nSteps between nodes ending in Z:\n[16409 16409 16409 16409 16409 16409 16409 16409 16409 16409 16409 16409\n 16409 16409]\n\n\nStarting node: PPA\nSteps to be in node where last letter was Z:\n [19636, 39273, 58910, 78547, 98184, 117821, 137458, 157095, 176732, 196369]\nSteps between nodes ending in Z:\n[19637 19637 19637 19637 19637 19637 19637 19637 19637 19637 19637 19637\n 19637 19637]\n\n\nStarting node: QQA\nSteps to be in node where last letter was Z:\n [18022, 36045, 54068, 72091, 90114, 108137, 126160, 144183, 162206, 180229]\nSteps between nodes ending in Z:\n[18023 18023 18023 18023 18023 18023 18023 18023 18023 18023 18023 18023\n 18023 18023]\n\n\nStarting node: TDA\nSteps to be in node where last letter was Z:\n [15870, 31741, 47612, 63483, 79354, 95225, 111096, 126967, 142838, 158709]\nSteps between nodes ending in Z:\n[15871 15871 15871 15871 15871 15871 15871 15871 15871 15871 15871 15871\n 15871 15871]\n\n\nStarting node: PDA\nSteps to be in node where last letter was Z:\n [14256, 28513, 42770, 57027, 71284, 85541, 99798, 114055, 128312, 142569]\nSteps between nodes ending in Z:\n[14257 14257 14257 14257 14257 14257 14257 14257 14257 14257 14257 14257\n 14257 14257]\n\n\nStarting node: QXA\nSteps to be in node where last letter was Z:\n [12642, 25285, 37928, 50571, 63214, 75857, 88500, 101143, 113786, 126429]\nSteps between nodes ending in Z:\n[12643 12643 12643 12643 12643 12643 12643 12643 12643 12643 12643 12643\n 12643 12643]\n\n\n\n\nWe can see that for each starting node, there is a regular pattern of number of steps taken before reaching again a node ending in Z.\nLet‚Äôs take the MCM of these numbers (steps between nodes ending in Z):\n\n\nToggle the code\ndef get_steps_between(node, steps_ending_z):\n  return np.unique(np.diff(steps_ending_z[node]))\n\nsteps_between= [get_steps_between(node, steps_ending_z) for node in steps_ending_z]\n\nsteps_between = np.concatenate(steps_between)\n\nsolution = np.lcm.reduce(steps_between)\nsolution\n\n\n11795205644011\n\n\nYay! That was the correct solution!"
  }
]