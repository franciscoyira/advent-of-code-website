[
  {
    "objectID": "2023.html",
    "href": "2023.html",
    "title": "2023",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2023: Introduction\n\n\nintro\n\n\n\n\n2023: Day 1\n\n\nR\n\n\n\n\n2023: Day 2\n\n\nR\n\n\n\n\n2023: Day 3\n\n\npython\n\n\n\n\n2023: Day 4\n\n\nR\n\n\n\n\n2023: Day 5\n\n\nR\n\n\n\n\n2023: Day 6\n\n\npython\n\n\n\n\n2023: Day 7\n\n\npython\n\n\n\n\n2023: Day 8\n\n\npython\n\n\n\n\n2023: Day 9\n\n\nR\n\n\n\n\n2023: Day 10\n\n\nR\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code Solutions",
    "section": "",
    "text": "Hi there! Welcome to this mini-site where I‚Äôll be sharing my solutions to the Advent of Code puzzles. Advent of Code is a series of increasingly difficult programming challenges, released daily each year throughout December in the run-up to Christmas.\nTo see my solutions and notes, just click on the corresponding year in the top navigation bar (though, as of now, I‚Äôve only published solutions for 2023).\nThis website is created using the EllaKaye/advent-of-code-website-template template repository. In the README of the repo you can find documentation on how to use it and adapt it, in case you can to publish your solutions in a similar format (which you should totally do üòÅ)."
  },
  {
    "objectID": "index.html#on-llms-usage",
    "href": "index.html#on-llms-usage",
    "title": "Advent of Code Solutions",
    "section": "On LLMs usage",
    "text": "On LLMs usage\nI‚Äôm adhering to the guidelines and suggestions made by the Advent of Code team regarding the use of LLMs like ChatGPT to solve the puzzles. That means I‚Äôm not using ChatGPT‚Äôs help to arrive at the solutions I‚Äôm posting on this website. However, once I‚Äôm done with a problem (that means, either solving it or giving up), I may use LLMs to seek feedback or explore alternative approaches."
  },
  {
    "objectID": "fonts/Readme.html",
    "href": "fonts/Readme.html",
    "title": "iA-Fonts",
    "section": "",
    "text": "iA-Fonts\nThe iA Writer fonts comes bundled with iA Writer for for Android, Windows, Mac, iPadOS and iOS\nFor in depth explanation of iA Writer Mono, Duo, and Quattro please read our blog entry on Duospace and on iA Writer Mono, Duo, and Quattro\nThis is a modification of IBM‚Äôs Plex font. The upstream project is here Please read the licensing file before working with it.\nIf you fork or use our fonts, please reference iA Writer clearly. Use them creatively.\nDon‚Äôt be a copycat. With or without the fonts, do not clone our products or our website. Selling our work under your name is blatantly disrespectful and criminal. Distributing knockoffs of our work for free doesn‚Äôt make you Robin Hood either. We do not approve of free plugins or themes for other apps and other counterfeits that imitate our products. They‚Äôre poor quality, they undermine our business, and they openly violate our copyright. Due to their poor quality, they tarnish our reputation. They‚Äôre unethical, illegal, and lame."
  },
  {
    "objectID": "2023/day/7/index.html",
    "href": "2023/day/7/index.html",
    "title": "2023: Day 7",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/7/index.html#setup",
    "href": "2023/day/7/index.html#setup",
    "title": "2023: Day 7",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/7/index.html#part-1",
    "href": "2023/day/7/index.html#part-1",
    "title": "2023: Day 7",
    "section": "Part 1",
    "text": "Part 1\nNotes:\n\nDesert Island uses machines to make sand out of rocks but the machines have broken down because they‚Äôre not getting the parts needed for periodical repairs.\nHave to play Camel Cards during the journey to figure out why the parts deliveries have stopped.\n\n\nIn Camel Cards, you get a list of hands, and your goal is to order them based on the strength of each hand. A hand consists of five cards labeled one of A, K, Q, J, T, 9, 8, 7, 6, 5, 4, 3, or 2. The relative strength of each card follows this order, where A is the highest and 2 is the lowest.\n\n\nEvery hand is exactly one type. From strongest to weakest, they are:\n\n\n\nFive of a kind, where all five cards have the same label: AAAAA\nFour of a kind, where four cards have the same label and one card has a different label: AA8AA\nFull house, where three cards have the same label, and the remaining two cards share a different label: 23332\nThree of a kind, where three cards have the same label, and the remaining two cards are each different from any other card in the hand: TTT98\nTwo pair, where two cards share one label, two other cards share a second - label, and the remaining card has a third label: 23432\nOne pair, where two cards share one label, and the other three cards have a different label from the pair and each other: A23A4\nHigh card, where all cards‚Äô labels are distinct: 23456\n\n\n\nHands are ordered first by type. Then, the following rule applies:\n\n\nStart by comparing the first card in each hand. If these cards are different, the hand with the stronger first card is considered stronger. If the first card in each hand have the same label, however, then move on to considering the second card in each hand. If they differ, the hand with the higher second card wins; otherwise, continue with the third card in each hand, then the fourth, then the fifth.\n\n\nSo, 33332 and 2AAAA are both four of a kind hands, but 33332 is stronger because its first card is stronger. Similarly, 77888 and 77788 are both a full house, but 77888 is stronger because its third card is stronger (and both hands have the same first and second card).\n\nAlso, there is a bid for each hand. In the example input:\n32T3K 765\nT55J5 684\nKK677 28\nKTJJT 220\nQQQJA 483\n\nEach hand wins an amount equal to its bid multiplied by its rank, where the weakest hand gets rank 1, the second-weakest hand gets rank 2, and so on up to the strongest hand. Because there are five hands in this example, the strongest hand will have rank 5 and its bid will be multiplied by 5.\n\nIn this example, we first need to put the hands in order of strength.\n\n\n32T3K is the only one pair and the other hands are all a stronger type, so it gets rank 1.\nKK677 and KTJJT are both two pair. Their first cards both have the same label, but the second card of KK677 is stronger (K vs T), so KTJJT gets rank 2 and KK677 gets rank 3.\nT55J5 and QQQJA are both three of a kind. QQQJA has a stronger first card, so it gets rank 5 and T55J5 gets rank 4.\n\n\nAfter doing that, we then multiply these ranks by their corresponding bids to calculate the total winnings.\nTotal winnings = (765 * 1 + 220 * 2 + 28 * 3 + 684 * 4 + 483 * 5) = 6440.\nThe prompt asks to obtain the number of total winnings the input data.\n\nimport numpy as np\nimport pandas as pd\n\n\nImporting the data\nFirst, I‚Äôm loading all the puzzle input as a numpy array of strings/characters:\n\ninput = np.loadtxt('input', dtype = 'object')\ninput[:5]\n\narray([['99898', '978'],\n       ['T99A9', '198'],\n       ['43Q34', '550'],\n       ['KK8QK', '418'],\n       ['Q6Q57', '767']], dtype=object)\n\n\nThe input array is kind of problematic since it combines cards and bids, which need to be processed differently. So, let‚Äôs split the data into two lists, one for the cards, another one for the bids.\n\ncards = list(input[:, 0])\nbids = list(map(int, list(input[:, 1])))\n\n\n\nRanking the hands\nLet‚Äôs assign points to the hands based on the rules and then sort or rank them based on those points.\nThe algorithm would be something like this:\n\nIdentify the TYPE of the hand: five of a kind &gt; four of a kind &gt; full house &gt; three of a kind &gt; two pair &gt; one pair &gt; high card. Assign points based on that.\nThen, assign points based on the value of each of the cards of the hand, from left to right, using this sorting: (highest score) A, K, Q, J, T, 9, 8, 7, 6, 5, 4, 3, 2 (lowest score).\n\nA reasonable way of doing this would be to create a DataFrame where each row is a hand, then add a column with the points based on type, followed by additional columns for each card‚Äôs points. Finally, perform a sort_values(), first by the hand type column, and then using the card columns to the right to break any ties.\n\n\nFunction for Assigning Points Based on Hand Type\nLet‚Äôs start solving for a particular case: identifying ‚ÄòAAAAA‚Äô as a Five of a Kind:\n\n# Helper function\ndef n_distinct_cards(hand):\n  return len(set(list(hand)))\n\nexample_card = 'AAAAA'\n\nmy_n_diff_cards = n_distinct_cards(example_card)\nmy_n_diff_cards\n\n1\n\n\n\nfrom collections import Counter\n# Frequency (count) of the most common card in the hand\nmax_n_cards = max(Counter(list(example_card)).values())\nmax_n_cards\n\n5\n\n\n\n# Logic for assigning points to the hand \nif (my_n_diff_cards == 1):\n  print('Five of a kind')\nelif (my_n_diff_cards == 2):\n  # In this case, the hand could either be four of a kind or full house\n  if (max_n_cards == 4):\n    print('Four of a kind')\n  else:\n    print('Full house')\nelif (my_n_diff_cards == 3):\n  # could be: three of a kind OR two pair\n  if (max_n_cards == 3):\n    print('Three of a kind')\n  else:\n    print('Two pair')\nelif (my_n_diff_cards == 4):\n  print('One pair')\nelse:\n  print('High card')\n\nFive of a kind\n\n\nIt seems to work as expected.\nLet‚Äôs wrap the procedure into a function (and make it return the corresponding points instead of the name of the hand):\n\ndef points_by_type(hand):\n  my_n_diff_cards = n_distinct_cards(hand)\n  max_n_cards = max(Counter(list(hand)).values())\n\n  if (my_n_diff_cards == 1):\n    #'Five of a kind'\n    return 7\n  elif (my_n_diff_cards == 2):\n    # In this case, the hand could either be four of a kind or full house\n    if (max_n_cards == 4):\n      # Four of a kind\n      return 6\n    else:\n      return 5\n  elif (my_n_diff_cards == 3):\n    # could be: three of a kind OR two pair\n    if (max_n_cards == 3):\n      # Three of a kind\n      return 4\n    else:\n      # Two pair\n      return 3\n  elif (my_n_diff_cards == 4):\n    # One pair\n    return 2\n  else:\n    # High card\n    return 1\n\nTesting the function with some hands from the input:\n\nprint(cards[:5])\nprint(list(map(points_by_type, cards[:5])))\n\n['99898', 'T99A9', '43Q34', 'KK8QK', 'Q6Q57']\n[5, 4, 3, 4, 2]\n\n\n\n\nFunction for Assigning Points Based on Each Card\nI‚Äôll sort the kinds by their strength and then determine their points based on their positions in the list.\n\nkinds_cards = list(\"AKQJT98765432\"[::-1])\n\nmy_card = 'A'\npoints_by_card = kinds_cards.index(my_card)\npoints_by_card\n\n12\n\n\nNow let‚Äôs create a function that, given an entire hand, returns a score that allows sorting them based on the points of their individual cards.\n\ndef points_by_card(hand):\n  points_by_cards = 0\n  my_cards = list(hand)\n\n  for card in my_cards:\n    points_by_cards = points_by_cards*13 + kinds_cards.index(card)\n\n  return points_by_cards\n\nCreating a DataFrame where hand is a row:\n\ndf = pd.DataFrame({\n  'hands': cards,\n  'bids': bids\n})\n\ndf.head(3)\n\n\n\n\n\n\n\n\n\nhands\nbids\n\n\n\n\n0\n99898\n978\n\n\n1\nT99A9\n198\n\n\n2\n43Q34\n550\n\n\n\n\n\n\n\n\nCalculating the points of each hand (both by hand type and based on individual cards):\n\ndf1 = df.assign(\n  points_type = list(map(points_by_type, df.hands)),\n  points_cards = list(map(points_by_card, df.hands)))\\\n    .sort_values(by = ['points_type', 'points_cards'])\n\ndf1.head(3)\n\n\n\n\n\n\n\n\n\nhands\nbids\npoints_type\npoints_cards\n\n\n\n\n64\n236Q8\n82\n1\n3009\n\n\n986\n237T4\n883\n1\n3148\n\n\n136\n2397K\n106\n1\n3456\n\n\n\n\n\n\n\n\nCreating the rank column:\n\ndf1.reset_index(drop = True, inplace = True)\ndf1['rank'] = df1.index + 1\ndf1.head(3)\n\n\n\n\n\n\n\n\n\nhands\nbids\npoints_type\npoints_cards\nrank\n\n\n\n\n0\n236Q8\n82\n1\n3009\n1\n\n\n1\n237T4\n883\n1\n3148\n2\n\n\n2\n2397K\n106\n1\n3456\n3\n\n\n\n\n\n\n\n\nThe only step left is to multiply the ranks by the bids and sum up the totals:\n\nsum(df1[\"bids\"] * df1[\"rank\"])\n\n246163188\n\n\nThe solution is correct ‚úÖüôåüèΩ"
  },
  {
    "objectID": "2023/day/7/index.html#part-2",
    "href": "2023/day/7/index.html#part-2",
    "title": "2023: Day 7",
    "section": "Part 2",
    "text": "Part 2\n\nNow, J cards are jokers - wildcards that can act like whatever card would make the hand the strongest type possible.\n\n\nTo balance this, J cards are now the weakest individual cards, weaker even than 2. The other cards stay in the same order: A, K, Q, T, 9, 8, 7, 6, 5, 4, 3, 2, J.\n\nImplementing this change in the points_by_card function is straightforward. I just need to re-arrange the list that maps the cards to their scores.\n\nkinds_cards = list(\"AKQT98765432J\"[::-1])\n\nBut I suspect incorporating this new logic into the points_by_type function will be more complicated. For each joker, we have to explore what is, potentially, the best type each hand could be if we could swap that joker for any other kind of card.\nIdea: create a function that receives as input the number of jokers in a hand, along with the original hand type (ignoring the joker rule) and returns the hand type considering the joker rule.\nFirst, let‚Äôs see if this function is feasible and how it would work:\n\nFive of a kind &gt; This is the best hand possible, so it can‚Äôt improve.\nFour of a kind &gt; two scenarios\n\n4 jokers: the jokers can be swaped to match the odd card. Hand type would go up to Five of a kind.\n1 joker: the joker can be swaped to match the other 4 cards. Hand type goes up too.\n\nFull house &gt; two scenarios\n\n3 jokers: hand becomes Five of a kind.\n2 jokers: hand becomes Five of a kind too.\n\nThree of a kind &gt; two scenarios\n\n3 jokers: hand becomes Four of a kind.\n1 joker: hand becomes Four of a kind too.\n\nTwo pair &gt; two scenarios\n\n2 jokers: hand becomes Four of a kind.\n1 joker: hand becomes Full House.\n\nOne pair &gt; two scenarios\n\n2 jokers: hand becomes Three of a kind.\n1 joker: hand becomes Three of a kind too.\n\nHigh card &gt; There can only be one joker by definition, which would turn the hand into One Pair.\n\nWe‚Äôve confirmed that, depending on the number of jokers and the initial hand type, we can predict how the hand‚Äôs type will change under these new rules (good news!).\nNow let‚Äôs implement this logic as a function named new_type:\n\ndef new_type(points_type, n_jokers):\n  if n_jokers == 0 or points_type == 7:\n    return points_type\n\n  # Four of a kind becomes five of a kind\n  if points_type == 6:\n    return 7\n\n  # Full house becomes five of a Kind\n  if points_type == 5:\n    return 7\n\n  # Three of a kind becomes four of a kind\n  if points_type == 4:\n    return 6\n\n  # Two pair can become four of a kind or full house\n  if points_type == 3:\n    if n_jokers == 2:\n      return 6\n    else:\n      return 5\n  \n  # One pair becomes three of a kind\n  if points_type == 2:\n    return 4\n\n  # High card becomes one pair\n  if points_type == 1:\n    return 2\n\nWe also need a function that counts jokers:\n\n# Example case\nexample_card = 'JAJAJ'\nCounter(list(example_card))['J']\n\n3\n\n\n\ndef joker_counter(hand):\n  return Counter(list(hand))['J']\n\nNext steps:\n\nAdd a column to df1 indicating the n_jokers in each hand.\nCombine that new column with the existing points_type to determine the new_points_type.\nUse the updated points_by_card function to calculate the new_points_card.\n\n\ndf1 = df1.assign(\n  n_jokers = list(map(joker_counter, df1.hands)))\n\ndf1 = df1.assign(\n  new_points_type = list(map(new_type, df1.points_type, df1.n_jokers)),\n  # Here I can apply the same function as before because I changed the value of kinds_cards\n  new_points_cards = list(map(points_by_card, df1.hands))\n)\n\ndf1.head(3)\n\n\n\n\n\n\n\n\n\nhands\nbids\npoints_type\npoints_cards\nrank\nn_jokers\nnew_points_type\nnew_points_cards\n\n\n\n\n0\n236Q8\n82\n1\n3009\n1\n0\n1\n33937\n\n\n1\n237T4\n883\n1\n3148\n2\n0\n1\n34089\n\n\n2\n2397K\n106\n1\n3456\n3\n0\n1\n34396\n\n\n\n\n\n\n\n\nFinally, just compute the new ranks and re-calculate the total points (sum() of rank times the bids)\n\ndf2 = df1.sort_values(by = ['new_points_type', 'new_points_cards'])\\\n  .reset_index(drop = True)\n\n\ndf2['rank'] = df2.index + 1\n\nsum(df2[\"bids\"] * df2[\"rank\"])\n\n245794069\n\n\nThe solution is correct! üëåüèΩ"
  },
  {
    "objectID": "2023/day/1/index.html",
    "href": "2023/day/1/index.html",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a ‚Äúcalibration document‚Äù\nHas been ‚Äúamended‚Äù by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#setup",
    "href": "2023/day/1/index.html#setup",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a ‚Äúcalibration document‚Äù\nHas been ‚Äúamended‚Äù by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#part-1",
    "href": "2023/day/1/index.html#part-1",
    "title": "2023: Day 1",
    "section": "Part 1",
    "text": "Part 1\n\nlibrary(tidyverse)\nlibrary(here)\n\nTransforming the data to an appropriate data structure:\n\namended &lt;- read_lines(here('2023', 'day', '1', 'input'))\namended[1:10]\n\n [1] \"nqninenmvnpsz874\"                          \n [2] \"8twofpmpxkvvdnpdnlpkhseven4ncgkb\"          \n [3] \"six8shdkdcdgseven8xczqrnnmthreecckfive\"    \n [4] \"qlcnz54dd75nine7jfnlfgz\"                   \n [5] \"7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr\"\n [6] \"cdhmktwo6kjqbprvfour8\"                     \n [7] \"ninekkvkeight9three\"                       \n [8] \"ms9five71lrfpqxqlbj\"                       \n [9] \"9five9sevenldshqfgcnq\"                     \n[10] \"1one4seven\"                                \n\n\n\nSolving for a particular case\n\n(first_case &lt;- amended[1])\n\n[1] \"nqninenmvnpsz874\"\n\n\nExtracting the numbers\n\n(matrix_str_numbers &lt;-\n  str_extract_all(first_case, pattern = '\\\\d', simplify = TRUE))\n\n     [,1] [,2] [,3]\n[1,] \"8\"  \"7\"  \"4\" \n\n\nExtracting all the rows from columns one and three (the first and last number of each row)\n\nnumbers_i_want &lt;- matrix_str_numbers[, c(1,3)]\nnumbers_i_want\n\n[1] \"8\" \"4\"\n\n\n(This code will generalise ONLY IF all the other rows have 3 numbers too).\nThe following code returns the first and last number ‚Äúpasted‚Äù together and converts the result from string to numeric.\n\nstringr::str_flatten(numbers_i_want) %&gt;%\n  as.numeric()\n\n[1] 84\n\n\nNow let‚Äôs try to generalise to all input rows:\n\namended %&gt;%\n  str_extract_all(pattern = '\\\\d', simplify = TRUE) %&gt;%\n  head(5)\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n[1,] \"8\"  \"7\"  \"4\"  \"\"   \"\"   \"\"   \"\"  \n[2,] \"8\"  \"4\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[3,] \"8\"  \"8\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[4,] \"5\"  \"4\"  \"7\"  \"5\"  \"7\"  \"\"   \"\"  \n[5,] \"7\"  \"2\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n\n\nOh no. Rows have a different quantity of digits.\nMaybe using simplify=TRUE was a mistake here. Given that each element has a different quantity of digits, a list seems to be a more suitable data structure:\n\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(5)\n\nlist_digits_preview\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nNow, how can I extract the first and last element from each element of the list? My gut feeling is that I‚Äôll need purrr for this:\npluck and keep_at seem to be useful functions for this task\n\nlist_digits_preview %&gt;%\n  # This should extract the first and last digit from each element of the list \n  map(~keep_at(., c(1, length(.))))\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nIt is working!!\nNow I‚Äôll apply the action to the whole list:\n\nlist_useful_digits &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(~keep_at(., c(1, length(.))))\n\nlist_useful_digits[1:10]\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nHmmm‚Ä¶ Why does element 7 have only 1 digit?\n\namended[7]\n\n[1] \"ninekkvkeight9three\"\n\n\nIt‚Äôs got just one digit as a number, but there are other digits written out in words. Should we count those? The prompt isn‚Äôt really clear about this. But since the example only talks about digits as numbers, I guess I‚Äôll just go with those for now. If I‚Äôve got this wrong and my solution gets rejected, well, I can always give it another shot\nNow let‚Äôs concatenate the digits row-wise, turn them into a number and add them up:\n\nsolution &lt;- \n  list_useful_digits %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution\n\n[1] 39347\n\n\nüëéüèΩ Solution was rejected. The website says it‚Äôs too low ü§î\nThe most likely suspect here is the way map(~keep_at(., c(1, length(.)))) is handling the rows with only one digit.\nSome alternatives I could try:\n\nIf the input row has only one digit, then use it as first AND last digit when building the number (e.g.¬†if the row only contains 7, the number I would obtain from that row should be 77).\nTake into account digits that are written as words (e.g.¬†‚Äúthree‚Äù). This is less likely to work and it would be weird for the exercise to expect people to do this and not mentioning it explicitely in the prompt or the examples.\n\nI‚Äôll go with alternative 1.\n\n\nHandling rows with just one digit\nI‚Äôll take a slice from the first 10 rows, as the first case with one digit appears in row 7:\n\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(10)\n\nlist_digits_preview\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"7\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nI have a feeling that purrr::pluck may do the trick here:\n\nget_first_and_last &lt;- function(x) {\n  c(pluck(x, 1), pluck(x, length(x)))\n}\n\nlist_digits_preview %&gt;%\n  map(get_first_and_last)\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\" \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nThis function does what I want (and yes, using pluck is a bit unnecessary since I could just have used regular subsetting, e.g.¬†x[[1]] and x[[length(x)]], but I‚Äôm doing this with the purrr cheat sheet in front of me, so pluck was what came to my mind).\n2nd attempt, this time using get_first_and_last.\n\nsolution2 &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution2\n\n[1] 56397\n\n\nThis is the correct solution!! ü•≥ü•≥ü•≥\nOnto the second part!"
  },
  {
    "objectID": "2023/day/1/index.html#part-2",
    "href": "2023/day/1/index.html#part-2",
    "title": "2023: Day 1",
    "section": "Part 2",
    "text": "Part 2\nSaw this one coming: now I need to tackle the digits spelled out as words üò¨.\n\nFirst (naive) attempt\nIMHO the simplest approach is to write a function that converts digits spelled out in a string into their numeric form. Then, I can incorporate this function into my pipeline using a map call, right before str_extract_all.\n\ncase_with_spelled_digit &lt;- amended[7]\ncase_with_spelled_digit\n\n[1] \"ninekkvkeight9three\"\n\n\n\ncase_with_spelled_digit %&gt;%\n  str_replace_all(\n    c(\n      \"nine\" = \"9\",\n      \"eight\" = \"8\",\n      \"three\" = \"3\"\n    )\n  )\n\n[1] \"9kkvk893\"\n\n\nWorking as expected.\nNow let‚Äôs apply the function to the full data.\nI‚Äôll start by creating the replacement vector (although I‚Äôm pretty sure it‚Äôs already a part of some R package that‚Äôs slipping my mind right now).\n\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\"\n)\n\n\nsolution3 &lt;- \n  amended %&gt;%\n  str_replace_all(pattern = digits) %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution3\n\n[1] 55266\n\n\nThe solution wasn‚Äôt right.\n\n\nSecond attempt: handling overlapping patterns\nTime to take a closer look at the pipeline using a tibble.\n\ntibble(\n  original = amended,\n  new = original %&gt;%\n    str_replace_all(pattern = digits),\n  digits = amended %&gt;%\n    str_replace_all(pattern = digits) %&gt;%\n    str_extract_all(pattern = '\\\\d') %&gt;%\n    map(get_first_and_last) %&gt;%\n    map(str_flatten) %&gt;%\n    as_vector()\n)\n\n# A tibble: 1,000 √ó 3\n   original                                   new                         digits\n   &lt;chr&gt;                                      &lt;chr&gt;                       &lt;chr&gt; \n 1 nqninenmvnpsz874                           nq9nmvnpsz874               94    \n 2 8twofpmpxkvvdnpdnlpkhseven4ncgkb           82fpmpxkvvdnpdnlpkh74ncgkb  84    \n 3 six8shdkdcdgseven8xczqrnnmthreecckfive     68shdkdcdg78xczqrnnm3cck5   65    \n 4 qlcnz54dd75nine7jfnlfgz                    qlcnz54dd7597jfnlfgz        57    \n 5 7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr 7vrdhggdkqbnltlgpkkvsdxn2m‚Ä¶ 72    \n 6 cdhmktwo6kjqbprvfour8                      cdhmk26kjqbprv48            28    \n 7 ninekkvkeight9three                        9kkvk893                    93    \n 8 ms9five71lrfpqxqlbj                        ms9571lrfpqxqlbj            91    \n 9 9five9sevenldshqfgcnq                      9597ldshqfgcnq              97    \n10 1one4seven                                 1147                        17    \n# ‚Ñπ 990 more rows\n\n\nHypothesis: The issue might arise in instances like \"zoneight234\", where the spellings of two numbers are overlapping.\n\nstr_replace_all(\"zoneight234\", pattern = digits)\n\n[1] \"z1ight234\"\n\n\nI‚Äôll try to handle these cases to make sure that every spelled-out digit in the text is returned, even if they overlap.\nMaybe I can get closer to that by using the stringi package?\n\nstringi::stri_replace_all_regex(\"zoneight234\", pattern = names(digits), replacement = digits, vectorize_all = FALSE)\n\n[1] \"z1ight234\"\n\n\nThis is not working.\nSomething else I could try:\n\nUsing the _first and _last functions from stringi to identify digits, whether they are numerically written or spelled out.\n\n\nThen, replacing the spelled-out digits that appear at either the beginning or end of the string.\n\n\nproblematic_string &lt;- \"zone2344oneight\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\nall_digits_vector &lt;- c(\n  names(digits),\n  0:9\n)\n\nstringi::stri_extract_last_regex(\n  str = problematic_string,\n  pattern = all_digits_vector\n)\n\n [1] \"one\"   NA      NA      NA      NA      NA      NA      \"eight\" NA     \n[10] NA      NA      \"2\"     \"3\"     \"4\"     NA      NA      NA      NA     \n[19] NA     \n\n\nOkay, this method DOES return all the digits that appear in the string, but I end up losing details about where the digits are positioned, which is needed for identifying the first and last digits in each row.\nMore ideas:\n\nUsing str_localte_all, a stringr function that allows matching each digit as an separate pattern (thus avoiding the overlap problem) and gives information about the POSITION of the pattern. Then use that info to find the first and the last match in each row.\n\nExample:\n\nstringr::str_locate_all(\n  string = problematic_string,\n  pattern = all_digits_vector\n)[1:8]\n\n[[1]]\n     start end\n[1,]     2   4\n[2,]     9  11\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n\n[[4]]\n     start end\n\n[[5]]\n     start end\n\n[[6]]\n     start end\n\n[[7]]\n     start end\n\n[[8]]\n     start end\n[1,]    11  15\n\n\n\nCRAZY IDEA!!! What if I reverse the string, and then look for first match of the reversed names of the digits??\n\nAfter all, the only matches that matter for solving this puzzle are the first one and the last one. For the first match, overlapping is not a real problem because it causes the second digit not to match (example: ‚Äúeight‚Äù in ‚Äúoneight‚Äù, here ‚Äúone‚Äù is always matched or detected).\nReversing the strings and their patterns could mirror this dynamic when matching the last digit.\n\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nvector_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\nIn this example, I should be able to match ‚Äúeight‚Äù as the last string, despite it overlapping with ‚Äúone‚Äù.\n\nproblematic_string\n\n[1] \"zone2344oneight\"\n\n\nMy strategy is to invert it and then look for ‚Äúthgie‚Äù üòÇüíÄ\n\nreversed_problematic_string &lt;- \n  stringi::stri_reverse(\n  problematic_string\n)\nreversed_problematic_string\n\n[1] \"thgieno4432enoz\"\n\n\n\nfound_reversed_string &lt;- str_extract(\n  reversed_problematic_string,\n  \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n)\n\nfound_reversed_string\n\n[1] \"thgie\"\n\n\nAfter finding it, I can use the following code to get back the original number\n\nvector_reversed[found_reversed_string]\n\nthgie \n  \"8\" \n\n\nIt‚Äôs working. Now, let‚Äôs wrap this pipeline in a function to apply it to whole dataset:\n\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\ndigits_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\nget_last_number &lt;- function(x) {\n  found_reversed_string &lt;-\n    stringi::stri_reverse(x) %&gt;%\n    str_extract(regex_reversed)\n\n  digits_reversed[found_reversed_string] %&gt;%\n    set_names(NULL)\n}\n\nget_first_number &lt;- function(x) {\n  found_string &lt;- str_extract(\n    x,\n    all_digits_regex\n  )\n\n  digits[found_string] %&gt;%\n    set_names(NULL)\n\n}\nget_first_number(problematic_string)\n\n[1] \"1\"\n\nget_last_number(problematic_string)\n\n[1] \"8\"\n\n\nIt‚Äôs working as intended, now let‚Äôs generalise it:\n\ntibble(\n  amended = amended,\n  first_digit = get_first_number(amended),\n  last_digit = get_last_number(amended),\n  combined = as.integer(str_c(first_digit, last_digit))\n) %&gt;%\n  pull(combined) %&gt;%\n  sum()\n\n[1] 55701\n\n\nIT WORKED!! THIS WAS THE RIGHT ANSWER!!! ü•≥ü•≥ü•πü•π"
  },
  {
    "objectID": "2023/day/6/index.html",
    "href": "2023/day/6/index.html",
    "title": "2023: Day 6",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nWe arrive to Island Island\nThere should be a large pile of sand but there isn‚Äôt\nBoat races to win trip to Desert Island: fixed amount of time and boat has to travel as far as it can\nInput: time allowed for each race and best distance until now\nTo win, we need to go farther than each current record holder\nBoats are toy boats: we press a button to charge them, and release them to allow them to move.\n\n\nBoats move faster if their button was held longer, but time spent holding the button counts against the total race time. You can only hold the button at the start of the race, and boats don‚Äôt move until the button is released.\n\n\nYour toy boat has a starting speed of zero millimeters per millisecond. For each whole millisecond you spend at the beginning of the race holding down the button, the boat‚Äôs speed increases by one millimeter per millisecond.\n\n\nThis is an optimisation problem.\nFor each problem, we have several ways (amount of time we can press the button) that allow us to beat the current record holder.\n\n\nTo see how much margin of error you have, determine the number of ways you can beat the record in each race; in this example, if you multiply these values together, you get 288 (4 * 8 * 9)."
  },
  {
    "objectID": "2023/day/6/index.html#setup",
    "href": "2023/day/6/index.html#setup",
    "title": "2023: Day 6",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nWe arrive to Island Island\nThere should be a large pile of sand but there isn‚Äôt\nBoat races to win trip to Desert Island: fixed amount of time and boat has to travel as far as it can\nInput: time allowed for each race and best distance until now\nTo win, we need to go farther than each current record holder\nBoats are toy boats: we press a button to charge them, and release them to allow them to move.\n\n\nBoats move faster if their button was held longer, but time spent holding the button counts against the total race time. You can only hold the button at the start of the race, and boats don‚Äôt move until the button is released.\n\n\nYour toy boat has a starting speed of zero millimeters per millisecond. For each whole millisecond you spend at the beginning of the race holding down the button, the boat‚Äôs speed increases by one millimeter per millisecond.\n\n\nThis is an optimisation problem.\nFor each problem, we have several ways (amount of time we can press the button) that allow us to beat the current record holder.\n\n\nTo see how much margin of error you have, determine the number of ways you can beat the record in each race; in this example, if you multiply these values together, you get 288 (4 * 8 * 9)."
  },
  {
    "objectID": "2023/day/6/index.html#part-1",
    "href": "2023/day/6/index.html#part-1",
    "title": "2023: Day 6",
    "section": "Part 1",
    "text": "Part 1\n\nimport pandas as pd\nimport numpy as np\n\n\nf = open(\"input\", \"r\")\ninput = f.readlines()\n# input is a list\n\nExtracting the times:\n\nimport re\ntimes = re.findall('[0-9]+', input[0])\ntimes = list(map(int, times))\n\nExtracting the distances:\n\ndistances = re.findall('[0-9]+', input[1])\ndistances = list(map(int, distances))\n\nNext, I think I could write a function that, for any pair of times and distances, returns the count of different values of time that allow to surpass the current record.\nFirst, let‚Äôs write the code of a particular case (using the example in the prompt)\n\ntime = 7\ndistance = 9\nn_possible_wins = 0\n\nfor i in range(time):\n  speed = i\n  available_time = time - i\n  my_distance = speed*available_time\n\n  if my_distance &gt; distance:\n    n_possible_wins += 1\n\nprint(n_possible_wins)\n\n4\n\n\n\ndef calculate_n_ways_to_win(time, distance):\n  n_possible_wins = 0\n\n  for i in range(time):\n    speed = i\n    available_time = time - i\n    my_distance = speed*available_time\n\n    if my_distance &gt; distance:\n      n_possible_wins += 1\n\n  return(n_possible_wins)\n\n\ncalculate_n_ways_to_win(7, 9)\n\n4\n\n\nNow I need to iterate across the two lists. I would like to do that using something similar to map2, instead of a for loop\n\nn_ways = list(map(calculate_n_ways_to_win, times, distances))\n\n\nimport operator\nfrom functools import reduce\n\nreduce(operator.mul, n_ways)\n\n1660968"
  },
  {
    "objectID": "2023/day/6/index.html#part-2",
    "href": "2023/day/6/index.html#part-2",
    "title": "2023: Day 6",
    "section": "Part 2",
    "text": "Part 2\nThe input interpretation changed and all the values of time and distance now actually represent two big numbers.\n\ncalculate_n_ways_to_win(47986698, 400121310111540)\n\n26499773"
  },
  {
    "objectID": "2023/day/3/index.html",
    "href": "2023/day/3/index.html",
    "title": "2023: Day 3",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/3/index.html#setup",
    "href": "2023/day/3/index.html#setup",
    "title": "2023: Day 3",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/3/index.html#part-1",
    "href": "2023/day/3/index.html#part-1",
    "title": "2023: Day 3",
    "section": "Part 1",
    "text": "Part 1\nNotes:\n\nA part is missing from an engine; we have to figure out which one using the numbers in the engine schematic (puzzle input).\nAny number adjacent to a symbol, even diagonally, is a ‚Äúpart number‚Äù and should be included in the sum.\nPeriods do not count as a symbol.\n\nExample\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\nIn this schematic, two numbers are not part numbers because they are not adjacent to a symbol: 114 (top right) and 58 (middle right). Every other number is adjacent to a symbol and so is a part number; their sum is 4361.\n\nProblems I see:\n\nThe input is a sort of matrix/grid, but we‚Äôre working with multi-digit numbers that occupy several slots/cells of the matrix.\nComputations need to span both vertical and horizontal axes (so dataframe-oriented methods and functions may not be suitable here).\n\nAt this moment, I have no idea which data structure to use for this problem.\nThe only thing that comes to mind is to put the data in a numpy array, then use a nested for loop to check certain conditions.\n\nimport numpy as np\nimport pandas as pd\n\nImporting the data in a numpy array where each element is a character of the input file.\n\n# Inspiration for this: https://stackoverflow.com/a/75643841/7221164\nwith open('input', 'r') as f:\n    input = np.stack([np.fromiter(list(line.strip()), dtype=\"object\") for line in f])\n    print(input)\n\n[['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '1' ... '.' '.' '.']\n ...\n ['.' '.' '.' ... '1' '3' '.']\n ['.' '9' '6' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']]\n\n\n\ninput.shape\n\n(140, 140)\n\n\nImplementing my for loop\n\nIn current_number, I‚Äôll add the digits I find as I iterate (will reset when a period or a line break is found).\nis_valid is a flag indicating whether the current_number should be counted in the sum (i.e., if any of its digits is adjacent to a symbol).\nrunning_sum keeps track of the total of all valid numbers.\n\n\ndebugging_array = []\ncurrent_number = None\nis_valid = False\nrunning_sum = 0\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\n# Inspiration for this: https://stackoverflow.com/a/49360371\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n\n    if not value.isdigit() or (ix == 0 and iy &gt; 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        if is_valid:\n          debugging_array.append(str(current_number) + \" is valid\")\n          running_sum += current_number\n          is_valid = False\n        else:\n          debugging_array.append(str(current_number) + \" is NOT valid\")\n\n        # reset current_numner\n        current_number = None\n    \n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n\n      # check the surrounding elements to know if there is a symbol (only if is_valid = False, otherwise it's not necessary)\n      if is_valid is False:\n        for offset_y, offset_x in np.ndindex((3,3)):\n          curr_y=iy+offset_y-1\n          curr_x=ix+offset_x-1\n\n          # Exception when the \"neighbour\" would be out of the array\n          if curr_y &lt; 0 or curr_x &lt; 0 or curr_y &gt; max_y or curr_x &gt; max_x:\n            continue\n\n          # Exception when we're on the same number\n          if curr_y == iy and curr_x == ix:\n            continue\n\n          # The check itself\n          # If one of the surrounding elements is not a dot or a digit, the flag switches to True and the for loop ends\n          if input[curr_y, curr_x] != \".\" and not input[curr_y, curr_x].isdigit():\n            is_valid = True\n            break \n\nInspecting how the first numbers from the input were classified:\n\ndebugging_array[:10]\n\n['401 is valid',\n '425 is NOT valid',\n '323 is NOT valid',\n '791 is valid',\n '697 is valid',\n '963 is NOT valid',\n '420 is NOT valid',\n '290 is valid',\n '492 is NOT valid',\n '656 is valid']\n\n\nChecking my solution:\n\nprint(running_sum)\n\n543867\n\n\nThe code is very ugly (for my taste), but the solution is correct!!"
  },
  {
    "objectID": "2023/day/3/index.html#part-2",
    "href": "2023/day/3/index.html#part-2",
    "title": "2023: Day 3",
    "section": "Part 2",
    "text": "Part 2\n\nOne of the gears in the engine is malfunctioning. A gear is represented by a ‚Äô*‚Äô symbol, and it must be adjacent to exactly two part numbers. The gear ratio is calculated by multiplying these two numbers together.\nTask is to determine the gear ratio for each gear and then add them up.\n\nExample:\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\nHere there are two gears. The first one is located in the top left corner, with part numbers 467 and 35, resulting in a gear ratio of 16345. The second gear is in the lower right corner, and its gear ratio is 451490. (Note that the ‚Äô*‚Äô adjacent to 617 is not a gear because it‚Äôs only adjacent to one part number.)\n\n\nTo find the total sum of all the gear ratios in your engine schematic, simply add them up.\n\nIdea to solve this part: each time a number is valid, put it in the corresponding position of a new array that has the same dimensions as the input array.\nThen, iterate over the input array with a new for loop that searches for ‚Äú*‚Äù and counts the N of valid numbers surrounding it.\n\narr_pt2 = np.zeros(input.shape)\n\ncurrent_number = None\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n    \n    # Case when the element is a * (potentially a gear)\n    if value == \"*\":\n      arr_pt2[iy, ix] = -1\n\n    # Checking if a number just ended\n    if not value.isdigit() or (ix == 0 and iy &gt; 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        # I need to write the current_number on the previous positions of arr_pt2\n        # Things to take into account:\n        # 1. overflowing across rows\n        # 2. I need to write the number on as many cells as digits the number has \n\n        for i in range(len(str(current_number))):\n          # ex: for a 3 digit number, offset will take values -1, -2 and -3\n          offset = -1 - i\n          # we first try to go back one cell in the x axis\n          # (move to the left across the same row)\n          ix_offset = ix + offset\n          iy_offset = iy\n\n          # case when we overflow the beginning of the row\n          if ix_offset &lt; 0:\n            # we move up in the y-axis\n            iy_offset = iy_offset-1\n\n            # when ix_offset == -1, we add 140 to end up with 139\n            ix_offset=ix_offset+input.shape[1]\n\n            # example\n            # if iy_offset, ix_offset == 10, -1\n            # we end up in 9, 139\n          arr_pt2[iy_offset, ix_offset] = current_number\n\n        # reset current_numner\n        current_number = None\n\n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n\nAfter this rather messy for loop, I should be able to identify gears by looking at the surrounding cells of all the ‚Äò-1‚Äô values in the array, which represent ‚Äô*‚Äô.\n\nmax_y = arr_pt2.shape[0] -1\nmax_x = arr_pt2.shape[1] -1\n\nrunning_sum = 0\n\nfor iy, ix in np.ndindex(arr_pt2.shape):\n  value = arr_pt2[iy, ix]\n\n  neighbours = set()\n\n  if value == -1:\n    for offset_y, offset_x in np.ndindex((3,3)):\n      curr_y=iy+offset_y-1\n      curr_x=ix+offset_x-1\n\n      # Exception when the \"neighbour\" would be out of the array\n      if curr_y &lt; 0 or curr_x &lt; 0 or curr_y &gt; max_y or curr_x &gt; max_x:\n        continue\n\n      # Exception when we're on the same number\n      if curr_y == iy and curr_x == ix:\n        continue\n\n      # The check itself\n      # if a surrounding cell is a number, then I'll add it to the `neighbours` set (this data structure handles duplicated numbers automatically)\n      if arr_pt2[curr_y, curr_x] &gt; 0:\n        neighbours.add(arr_pt2[curr_y, curr_x])\n\n  \n  if len(neighbours) == 2:\n    # multiply the neighbours\n    running_sum += neighbours.pop() * neighbours.pop()\n\nChecking my solution:\n\nprint(running_sum)\n\n79613331.0\n\n\nIt was correct!"
  },
  {
    "objectID": "2023/day/2/index.html",
    "href": "2023/day/2/index.html",
    "title": "2023: Day 2",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nThere are three types of cubes: green, red, and blue.\nSecret number of each type in a bag, have to figure out number.\nWe have ‚Äúsample data‚Äù from the bag.\nThe input includes info (samples) from previous games.\nGames are identified by an ID (e.g., Game 11).\n\nExample:\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\nIn Game 1, three sets of cubes are sampled from the bag (then returned). The first set contains 3 blue and 4 red cubes; the second set has 1 red cube, 2 green cubes, and 6 blue cubes; the third set consists solely of 2 green cubes.\nWhich games would have been possible if the bag had contained only 12 red cubes, 13 green cubes, and 14 blue cubes? Game 3 would have been impossible as it required 20 red cubes at one point.\nAfter filtering out the impossible games, we can sum their IDs (for instance, in this example, we would obtain a total of 8)."
  },
  {
    "objectID": "2023/day/2/index.html#setup",
    "href": "2023/day/2/index.html#setup",
    "title": "2023: Day 2",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nThere are three types of cubes: green, red, and blue.\nSecret number of each type in a bag, have to figure out number.\nWe have ‚Äúsample data‚Äù from the bag.\nThe input includes info (samples) from previous games.\nGames are identified by an ID (e.g., Game 11).\n\nExample:\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\nIn Game 1, three sets of cubes are sampled from the bag (then returned). The first set contains 3 blue and 4 red cubes; the second set has 1 red cube, 2 green cubes, and 6 blue cubes; the third set consists solely of 2 green cubes.\nWhich games would have been possible if the bag had contained only 12 red cubes, 13 green cubes, and 14 blue cubes? Game 3 would have been impossible as it required 20 red cubes at one point.\nAfter filtering out the impossible games, we can sum their IDs (for instance, in this example, we would obtain a total of 8)."
  },
  {
    "objectID": "2023/day/2/index.html#part-1",
    "href": "2023/day/2/index.html#part-1",
    "title": "2023: Day 2",
    "section": "Part 1",
    "text": "Part 1\n\nDetermine which games would have been possible if the bag had been loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?\n\n\nlibrary(tidyverse)\nlibrary(here)\n\ninput &lt;- read_file(here(\"2023/day/2/input\")) %&gt;%\n  str_split_1(pattern = '\\n') %&gt;%\n  magrittr::extract(1:100)\n\ninput[1:10]\n\n [1] \"Game 1: 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"                                                \n [2] \"Game 2: 11 green, 7 blue, 15 red; 13 red, 6 green, 2 blue; 7 green, 9 red, 10 blue; 5 blue, 1 red, 11 green; 4 blue, 18 green; 4 red, 8 blue, 18 green\"\n [3] \"Game 3: 7 red, 10 green, 4 blue; 2 blue, 3 green, 5 red; 9 red, 7 green, 3 blue; 3 blue, 6 green, 18 red\"                                              \n [4] \"Game 4: 1 blue, 2 green, 5 red; 10 red, 1 blue, 3 green; 14 red\"                                                                                       \n [5] \"Game 5: 16 red, 4 green, 19 blue; 13 blue, 9 red; 7 green, 14 red, 2 blue; 5 green, 18 blue, 4 red; 7 red, 2 blue, 3 green; 8 blue, 12 green\"          \n [6] \"Game 6: 3 blue, 8 green; 4 red, 5 green; 5 red, 8 blue, 5 green; 8 blue, 4 green; 3 red, 7 green, 2 blue\"                                              \n [7] \"Game 7: 7 red, 2 blue; 5 red, 6 green; 10 red; 2 blue, 12 red, 2 green; 4 red, 1 blue, 1 green; 9 green, 2 blue, 10 red\"                               \n [8] \"Game 8: 3 red, 7 green, 3 blue; 2 green, 3 blue, 3 red; 3 blue, 4 green, 1 red; 3 blue, 3 red; 2 blue, 6 green; 2 red, 7 green, 1 blue\"                \n [9] \"Game 9: 5 red, 6 green; 6 red; 2 blue, 3 green, 9 red; 6 green, 2 blue\"                                                                                \n[10] \"Game 10: 5 red, 8 blue, 5 green; 15 red, 6 green, 7 blue; 8 blue, 6 red, 5 green; 5 green, 2 blue; 12 red, 6 blue; 6 green, 16 red, 6 blue\"            \n\n\nWhat is the most suitable data structure for solving this problem?\nI believe I need only this information:\n\nThe ID of the game.\nThe maximum number of cubes for each colour.\n\nRegarding the number of cubes: is the maximum alone sufficient?\nConsider there are 10 red cubes.\nIf the maximum is 10 or less, the game was possible. If the maximum is 11 or more, the game was impossible.\nIndeed, I just need the maximum number of cubes for each colour in each game.\nI think a tibble would be a suitable data structure to store this information.\nLet‚Äôs start with the first game:\n\nfirst_game &lt;- input[1]\nfirst_game\n\n[1] \"Game 1: 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"\n\n\nSpecial characters to handle:\n\n:\n,\n`;\n\n\ngame_data &lt;-\n  tibble(\n    input = input\n  ) %&gt;%\n    separate(\n      input,\n      into = c(\"id\", \"data\"),\n      sep = \": \"\n    ) %&gt;%\n    mutate(\n      id = as.integer(str_extract(id, \"\\\\d+\"))\n    )\n\ngame_data\n\n# A tibble: 100 √ó 2\n      id data                                                                   \n   &lt;int&gt; &lt;chr&gt;                                                                  \n 1     1 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue‚Ä¶\n 2     2 11 green, 7 blue, 15 red; 13 red, 6 green, 2 blue; 7 green, 9 red, 10 ‚Ä¶\n 3     3 7 red, 10 green, 4 blue; 2 blue, 3 green, 5 red; 9 red, 7 green, 3 blu‚Ä¶\n 4     4 1 blue, 2 green, 5 red; 10 red, 1 blue, 3 green; 14 red                \n 5     5 16 red, 4 green, 19 blue; 13 blue, 9 red; 7 green, 14 red, 2 blue; 5 g‚Ä¶\n 6     6 3 blue, 8 green; 4 red, 5 green; 5 red, 8 blue, 5 green; 8 blue, 4 gre‚Ä¶\n 7     7 7 red, 2 blue; 5 red, 6 green; 10 red; 2 blue, 12 red, 2 green; 4 red,‚Ä¶\n 8     8 3 red, 7 green, 3 blue; 2 green, 3 blue, 3 red; 3 blue, 4 green, 1 red‚Ä¶\n 9     9 5 red, 6 green; 6 red; 2 blue, 3 green, 9 red; 6 green, 2 blue         \n10    10 5 red, 8 blue, 5 green; 15 red, 6 green, 7 blue; 8 blue, 6 red, 5 gree‚Ä¶\n# ‚Ñπ 90 more rows\n\n\nI need to obtain the number of cubes that have appeared for each colour:\n\ngame_data_1 &lt;- game_data[[\"data\"]][[1]]\ngame_data_1\n\n[1] \"8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"\n\n\nI think I can use str_match_all with a capturing pattern associated with the colours and simply ignore everything else.\n\nn_cubes_colour &lt;- \n  str_match_all(\n    game_data_1,\n    \"(\\\\d+) ([red|green|blue]+)\"\n  )[[1]][,2:3]\n\ncolnames(n_cubes_colour) &lt;- c(\"n\", \"colour\")\n\nn_cubes_colour %&gt;%\n  as_tibble() %&gt;%\n  group_by(colour) %&gt;%\n  summarise(n = max(as.numeric(n)))\n\n# A tibble: 3 √ó 2\n  colour     n\n  &lt;chr&gt;  &lt;dbl&gt;\n1 blue       4\n2 green      8\n3 red        8\n\n\nNow it‚Äôs time to wrap the code above into a function and apply it to all the games:\n\nget_count_cubes &lt;-\n  function(x) {\n    matrix_count_cubes &lt;-\n    str_match_all(\n      x,\n      \"(\\\\d+) ([red|green|blue]+)\"\n    )[[1]][,2:3]\n\n    colnames(matrix_count_cubes) &lt;- c(\"n\", \"colour\")\n\n    matrix_count_cubes %&gt;%\n      as_tibble() %&gt;%\n      group_by(colour) %&gt;%\n      summarise(n = max(as.numeric(n)))\n}\n\n(I‚Äôm concerned this approach may not scale effectively if the input for the second part is significantly larger.)\n\ngame_data_tidy &lt;- \n  game_data %&gt;%\n  mutate(data = map(data, get_count_cubes)) %&gt;%\n  unnest(data) %&gt;%\n  pivot_wider(\n    id_cols = id,\n    names_from = colour,\n    values_from = n\n  )\n\nMy attempted solution to determine which games would have been possible if the bag had been loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?.\n\ngame_data_tidy %&gt;%\n  filter(red &lt;= 12, green &lt;= 13, blue &lt;= 14) %&gt;%\n  pull(id) %&gt;%\n  sum()\n\n[1] 2085\n\n\nIT IS CORRECT!!! ü•≥ü•≥ü•≥ü•≥"
  },
  {
    "objectID": "2023/day/2/index.html#part-2",
    "href": "2023/day/2/index.html#part-2",
    "title": "2023: Day 2",
    "section": "Part 2",
    "text": "Part 2\n\nIn each game you played, what is the fewest number of cubes of each color that could have been in the bag to make the game possible?\n\n\nThe power of a set of cubes is equal to the numbers of red, green, and blue cubes multiplied together. The power of the minimum set of cubes in game 1 is 48. In games 2-5 it was 12, 1560, 630, and 36, respectively. Adding up these five powers produces the sum 2286.\n\n\nFor each game, find the minimum set of cubes that must have been present. What is the sum of the power of these sets?\n\nGiven the data structure I‚Äôm using, this second part seems easy.\n\ngame_data_tidy %&gt;%\n  summarise(sum(red*green*blue))\n\n# A tibble: 1 √ó 1\n  `sum(red * green * blue)`\n                      &lt;dbl&gt;\n1                     79315\n\n\nIt is correct too!!"
  },
  {
    "objectID": "2023/day/8/index.html",
    "href": "2023/day/8/index.html",
    "title": "2023: Day 8",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nInput has left/right instructions and a network of labelled nodes.\nWe‚Äôre meant to use the left/right instructions to navigate the network.\nAAA is where we are and ZZZ is where we‚Äôre going.\n\nExample of how the nodes are navigated:\nRL\n\nAAA = (BBB, CCC)\nBBB = (DDD, EEE)\nCCC = (ZZZ, GGG)\nDDD = (DDD, DDD)\nEEE = (EEE, EEE)\nGGG = (GGG, GGG)\nZZZ = (ZZZ, ZZZ)\n\nStarting with AAA, you need to look up the next element based on the next left/right instruction in your input. In this example, start with AAA and go right (R) by choosing the right element of AAA, CCC. Then, L means to choose the left element of CCC, ZZZ. By following the left/right instructions, you reach ZZZ in 2 steps.\n\n\nyou might not find ZZZ right away. If you run out of left/right instructions, repeat the whole sequence of instructions as necessary: RL really means RLRLRLRLRLRLRLRL‚Ä¶ and so on\n\nThe Question:\n\nStarting at AAA, follow the left/right instructions. How many steps are required to reach ZZZ?"
  },
  {
    "objectID": "2023/day/8/index.html#setup",
    "href": "2023/day/8/index.html#setup",
    "title": "2023: Day 8",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nInput has left/right instructions and a network of labelled nodes.\nWe‚Äôre meant to use the left/right instructions to navigate the network.\nAAA is where we are and ZZZ is where we‚Äôre going.\n\nExample of how the nodes are navigated:\nRL\n\nAAA = (BBB, CCC)\nBBB = (DDD, EEE)\nCCC = (ZZZ, GGG)\nDDD = (DDD, DDD)\nEEE = (EEE, EEE)\nGGG = (GGG, GGG)\nZZZ = (ZZZ, ZZZ)\n\nStarting with AAA, you need to look up the next element based on the next left/right instruction in your input. In this example, start with AAA and go right (R) by choosing the right element of AAA, CCC. Then, L means to choose the left element of CCC, ZZZ. By following the left/right instructions, you reach ZZZ in 2 steps.\n\n\nyou might not find ZZZ right away. If you run out of left/right instructions, repeat the whole sequence of instructions as necessary: RL really means RLRLRLRLRLRLRLRL‚Ä¶ and so on\n\nThe Question:\n\nStarting at AAA, follow the left/right instructions. How many steps are required to reach ZZZ?"
  },
  {
    "objectID": "2023/day/8/index.html#part-1",
    "href": "2023/day/8/index.html#part-1",
    "title": "2023: Day 8",
    "section": "Part 1",
    "text": "Part 1\n\nimport pandas as pd\nimport numpy as np\n\nFirst I need to load the data in a suitable data structure:\nI‚Äôm going to load the instructions as an array:\n\ninput = open('input', 'r')\ninstructions = input.readline().splitlines()\ninstructions = np.array(list(instructions[0]), dtype='object')\ninstructions\n\narray(['L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'L', 'L', 'R', 'R',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L',\n       'L', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'L', 'R', 'R', 'R', 'L', 'R', 'L', 'L', 'R', 'R', 'L', 'R',\n       'L', 'L', 'R', 'L', 'R', 'L', 'L', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'L', 'R', 'R', 'R', 'L', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'L', 'R', 'L', 'L', 'L', 'L', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R',\n       'R', 'L', 'R', 'R', 'L', 'L', 'R', 'L', 'R', 'L', 'R', 'R', 'L',\n       'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R',\n       'R', 'R', 'L', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L',\n       'R', 'R', 'R', 'L', 'R', 'L', 'R', 'R', 'R', 'L', 'L', 'R', 'L',\n       'R', 'L', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R',\n       'R', 'L', 'R', 'L', 'L', 'R', 'R', 'R', 'R'], dtype=object)\n\n\nNow, I need to load the node information.\nGiven that the node names appear to be unique, I could use a dictionary with the node names as keys. The value of each key could be another dictionary with ‚ÄòL‚Äô and ‚ÄòR‚Äô as keys, simplifying navigation through the nodes based on the instructions (I hope).\n\n# Loading the node information in a numpy array\nnodes = np.loadtxt('input', skiprows=2, dtype='str')\n\n# Removing column that doesn't contain useful information\nnodes = nodes[:, [0, 2, 3]]\nnodes = np.char.replace(nodes, '(', '')\nnodes = np.char.replace(nodes, ')', '')\nnodes = np.char.replace(nodes, ',', '')\nnodes[:10]\n\narray([['CTK', 'JLT', 'HRF'],\n       ['TQH', 'DKT', 'HGB'],\n       ['HQM', 'XPV', 'TTR'],\n       ['DLL', 'MFK', 'HHS'],\n       ['BVD', 'BXB', 'FDB'],\n       ['TTR', 'BJG', 'MTF'],\n       ['RPR', 'CQL', 'KHJ'],\n       ['KND', 'TVL', 'QMF'],\n       ['SQH', 'XNP', 'MRD'],\n       ['RXM', 'HTR', 'BXT']], dtype='&lt;U3')\n\n\nConverting the numpy array into a dictionary through iteration.\nI‚Äôll create a function that receives a row of the array and creates a key-value pair with ‚ÄòL‚Äô and ‚ÄòR‚Äô keys:\n\ndef create_dict(node):\n  my_dict = {node[0]: {'L': node[1], 'R': node[2]}}\n  return my_dict\n\nnodes_array = np.apply_along_axis(create_dict, axis=1, arr=nodes)\n\nfrom collections import ChainMap\nnodes_dict = dict(ChainMap(*nodes_array))\n\n# Example\nnodes_dict['XLV']\n\n{'L': 'VTR', 'R': 'TGD'}\n\n\nNext step is (indefinitely) iterating through the instructions until reaching \"ZZZ\", while keeping track of the number of steps required to do so.\n\nsteps = 0\ncurrent_node = 'AAA'\nlength_instructions = len(instructions)\n\nwhile current_node != 'ZZZ':\n  i_current_instruction = steps % length_instructions \n  current_instruction = instructions[i_current_instruction]\n  current_node = nodes_dict[current_node][current_instruction]\n  steps += 1\n\nprint(f'It took {steps} steps')\n\nIt took 16409 steps\n\n\nIt was correct!"
  },
  {
    "objectID": "2023/day/8/index.html#part-2",
    "href": "2023/day/8/index.html#part-2",
    "title": "2023: Day 8",
    "section": "Part 2",
    "text": "Part 2\n\nThe number of nodes with names ending in A is equal to the number ending in Z! If you were a ghost, you‚Äôd probably just start at every node that ends with A and follow all of the paths at the same time until they all simultaneously end up at nodes that end with Z.\n\nFor example:\nLR\n\n11A = (11B, XXX)\n11B = (XXX, 11Z)\n11Z = (11B, XXX)\n22A = (22B, XXX)\n22B = (22C, 22C)\n22C = (22Z, 22Z)\n22Z = (22B, 22B)\nXXX = (XXX, XXX)\n\nHere, there are two starting nodes, 11A and 22A (because they both end with A). As you follow each left/right instruction, use that instruction to simultaneously navigate away from both nodes you‚Äôre currently on. Repeat this process until all of the nodes you‚Äôre currently on end with Z.\n\n\n(If only some of the nodes you‚Äôre on end with Z, they act like any other node and you continue as normal.)\n\n\nSimultaneously start on every node that ends with A. How many steps does it take before you‚Äôre only on nodes that end with Z?\n\nI THINK I can work this out making changes only to the logic and keeping the data structures of the input (instructions and nodes_dict) as they are right now.\nThe initialisation of the current node requires modification, since now we have to start simultaneously from all the nodes that end in ‚ÄòA‚Äô.\n\n# current_node = 'AAA'\nall_nodes = list(nodes_dict.keys())\n\nimport re\npatA = re.compile(r'[A-Z0-9]{2}A')\nstarting_nodes = [node for node in all_nodes if patA.match(node)]\nstarting_nodes\n\n['AAA', 'PPA', 'QQA', 'TDA', 'PDA', 'QXA']\n\n\n\nsteps = 0\n\ncurrent_nodes = starting_nodes\n\npatZ = re.compile(r'[A-Z0-9]{2}Z')\nall_z = False\n\nwhile all_z is False:\n  # Code related to iterating thorugh instructions doesn't change\n  # I changed the names to make them more succinct\n  i_curr_ins = steps % length_instructions \n  curr_ins = instructions[i_curr_ins]\n\n  # This code has to change\n  # current_node = nodes_dict[current_node][current_instruction]\n  current_nodes = [nodes_dict[node][curr_ins] for node in current_nodes]\n\n  steps += 1\n  is_z = [bool(patZ.match(node)) for node in current_nodes]\n  all_z = all(is_z)\n  if sum(is_z) &gt; 4:\n    print(current_nodes)\n    print(steps)\n\nEven though this code might technically reach the right answer given enough time, it takes way too long to be considered a viable solution.\nI wasn‚Äôt able to come up with a better solution on my own ü•≤ so I took a hint from Reddit where they suggested identifying patterns on the number of steps required to reach a node ending in ‚ÄòZ‚Äô from each of the starting nodes, and then using those patterns to identify a common number in the series.\n\n# Initialization values\nsteps = 0\ncurrent_nodes = starting_nodes\npatZ = re.compile(r'[A-Z0-9]{2}Z')\nall_z = False\n\n# Dictionary of empty lists with the starting nodes as keys\nsteps_ending_z = {}\nfor node in starting_nodes:\n  steps_ending_z[node] = []\n\nsteps_ending_z\n\n{'AAA': [], 'PPA': [], 'QQA': [], 'TDA': [], 'PDA': [], 'QXA': []}\n\n\n\nwhile all_z is False and steps &lt; 1000000:\n  # This code is necessary for appropriately reading the instructions\n  i_curr_ins = steps % length_instructions \n  curr_ins = instructions[i_curr_ins]\n\n  current_nodes = [nodes_dict[node][curr_ins] for node in current_nodes]\n\n  # For any node that ends in Z,\n  # add the current value of `steps` to the corresponding list of the dictionary\n  is_z = [False] * len(current_nodes)\n  for i, node in enumerate(current_nodes):\n    if patZ.match(node):\n      is_z[i] = True\n      steps_ending_z[starting_nodes[i]].append(steps)\n  \n  all_z = all(is_z)\n\n  steps += 1\n\n\nfor i, node in enumerate(steps_ending_z):\n  print('Starting node:', node)\n  print('Steps to be in node where last letter was Z:\\n', steps_ending_z[node][:10])\n  print('Steps between nodes ending in Z:')\n  print(np.diff(steps_ending_z[node][:15]))\n  print('\\n')\n\nStarting node: AAA\nSteps to be in node where last letter was Z:\n [16408, 32817, 49226, 65635, 82044, 98453, 114862, 131271, 147680, 164089]\nSteps between nodes ending in Z:\n[16409 16409 16409 16409 16409 16409 16409 16409 16409 16409 16409 16409\n 16409 16409]\n\n\nStarting node: PPA\nSteps to be in node where last letter was Z:\n [19636, 39273, 58910, 78547, 98184, 117821, 137458, 157095, 176732, 196369]\nSteps between nodes ending in Z:\n[19637 19637 19637 19637 19637 19637 19637 19637 19637 19637 19637 19637\n 19637 19637]\n\n\nStarting node: QQA\nSteps to be in node where last letter was Z:\n [18022, 36045, 54068, 72091, 90114, 108137, 126160, 144183, 162206, 180229]\nSteps between nodes ending in Z:\n[18023 18023 18023 18023 18023 18023 18023 18023 18023 18023 18023 18023\n 18023 18023]\n\n\nStarting node: TDA\nSteps to be in node where last letter was Z:\n [15870, 31741, 47612, 63483, 79354, 95225, 111096, 126967, 142838, 158709]\nSteps between nodes ending in Z:\n[15871 15871 15871 15871 15871 15871 15871 15871 15871 15871 15871 15871\n 15871 15871]\n\n\nStarting node: PDA\nSteps to be in node where last letter was Z:\n [14256, 28513, 42770, 57027, 71284, 85541, 99798, 114055, 128312, 142569]\nSteps between nodes ending in Z:\n[14257 14257 14257 14257 14257 14257 14257 14257 14257 14257 14257 14257\n 14257 14257]\n\n\nStarting node: QXA\nSteps to be in node where last letter was Z:\n [12642, 25285, 37928, 50571, 63214, 75857, 88500, 101143, 113786, 126429]\nSteps between nodes ending in Z:\n[12643 12643 12643 12643 12643 12643 12643 12643 12643 12643 12643 12643\n 12643 12643]\n\n\n\n\nWe can see that for each starting node, there is a regular pattern of number of steps taken before reaching again a node ending in Z.\nLet‚Äôs take the MCM of these numbers (steps between nodes ending in Z):\n\ndef get_steps_between(node, steps_ending_z):\n  return np.unique(np.diff(steps_ending_z[node]))\n\nsteps_between= [get_steps_between(node, steps_ending_z) for node in steps_ending_z]\n\nsteps_between = np.concatenate(steps_between)\n\nsolution = np.lcm.reduce(steps_between)\nsolution\n\n11795205644011\n\n\nYay! That was the correct solution!"
  },
  {
    "objectID": "2023/day/4/index.html",
    "href": "2023/day/4/index.html",
    "title": "2023: Day 4",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/4/index.html#setup",
    "href": "2023/day/4/index.html#setup",
    "title": "2023: Day 4",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/4/index.html#part-1",
    "href": "2023/day/4/index.html#part-1",
    "title": "2023: Day 4",
    "section": "Part 1",
    "text": "Part 1\nThere are a bunch of cards, which get points based on how many winning numbers do they have. I have to calculate how many points are the cards worth in total.\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\nNumbers to the right of the vertical bar | are the winning numbers. The first winning number to the left of the bar makes the card worth 1 point, and each sucesive winning number doubles the points the card is worth.\n\nlibrary(tidyverse)\nlibrary(here)\n\nReading the input as a vector\n\ninput &lt;- read_lines(here(\"2023/day/4/input\"))\ninput[1:10]\n\n [1] \"Card   1: 69 12 75 19 83 56 73 53 52 91 | 83 63 56 30 77 94 12 81 42 69 52 70  6 97 20 43 61 22 75 19 73 32 74 53 91\"\n [2] \"Card   2: 23 55 24 84 90 10 87 73 74 45 | 20 66 51 78  9 76 86 96 72 70 84 35 74 90 56 55 23 38 58 45 87  2 80  8 10\"\n [3] \"Card   3: 70 32 38 23 86 54 26 16  9  1 | 67 50 39 70 59 77 63 30  3 45 23 16 72  1 86  7  9 32 26 68 38 54 65 34 64\"\n [4] \"Card   4: 33 50 19 63 92  1 58 34 84  8 | 35 61 49 86 40 20 22 71 84 51 64 62 33 85 45  3 54 83  1 29 82 19 92  8 11\"\n [5] \"Card   5: 74  9 54 83 22 15 81 64 47 70 | 21 74 59 85 17 36  5 79 87  7 13 23 47 45 96 29 68 65  3 22  4 34 46 90 40\"\n [6] \"Card   6: 29 55 56 13 58 71 36 30 15 11 | 99 17 90 29 22 68 61 55 11 13 37 94 30 60 56 92 44 71 42 31  8 26 14 51 35\"\n [7] \"Card   7: 92 70 97 62 33 45 85 59 82 73 | 92 35 11 49 88 14 85 42 40 41 69 51 82 73  5 87 60 62 33 97 70 16 59 13 45\"\n [8] \"Card   8:  5 22 64 46 32 90 57 83 37 38 | 87 47 91 35 39 64 73 83 71 22 10 45  1 76 37 13 20 66 67 21 86 92 38 12 52\"\n [9] \"Card   9:  7 49 62 79 37 91  3 58 74 19 | 17  7 58  2 53 95 52 62 83 41 42 36  4 94 64 97 20 32  3 73 81 22 57 37  9\"\n[10] \"Card  10: 84 33 81 45 99 96 76 97 40  2 | 81 26 11 34 83 25 45 76  2 85 33 64 57 99 93 75 96  8 84 44 79 87 97 40 70\"\n\n\nTrying to parse the input as tidy data:\n\ncard_data &lt;- tibble(\n  input = input\n) %&gt;%\n  separate(\n    input,\n    into = c(\"id\", \"data\"),\n    sep = \": \"\n  ) %&gt;%\n  mutate(\n    id = as.integer(str_extract(id, \"\\\\d+\"))\n  )\n\ncard_data\n\n# A tibble: 212 √ó 2\n      id data                                                                   \n   &lt;int&gt; &lt;chr&gt;                                                                  \n 1     1 \"69 12 75 19 83 56 73 53 52 91 | 83 63 56 30 77 94 12 81 42 69 52 70  ‚Ä¶\n 2     2 \"23 55 24 84 90 10 87 73 74 45 | 20 66 51 78  9 76 86 96 72 70 84 35 7‚Ä¶\n 3     3 \"70 32 38 23 86 54 26 16  9  1 | 67 50 39 70 59 77 63 30  3 45 23 16 7‚Ä¶\n 4     4 \"33 50 19 63 92  1 58 34 84  8 | 35 61 49 86 40 20 22 71 84 51 64 62 3‚Ä¶\n 5     5 \"74  9 54 83 22 15 81 64 47 70 | 21 74 59 85 17 36  5 79 87  7 13 23 4‚Ä¶\n 6     6 \"29 55 56 13 58 71 36 30 15 11 | 99 17 90 29 22 68 61 55 11 13 37 94 3‚Ä¶\n 7     7 \"92 70 97 62 33 45 85 59 82 73 | 92 35 11 49 88 14 85 42 40 41 69 51 8‚Ä¶\n 8     8 \" 5 22 64 46 32 90 57 83 37 38 | 87 47 91 35 39 64 73 83 71 22 10 45  ‚Ä¶\n 9     9 \" 7 49 62 79 37 91  3 58 74 19 | 17  7 58  2 53 95 52 62 83 41 42 36  ‚Ä¶\n10    10 \"84 33 81 45 99 96 76 97 40  2 | 81 26 11 34 83 25 45 76  2 85 33 64 5‚Ä¶\n# ‚Ñπ 202 more rows\n\n\n\ncard_data_split &lt;- card_data %&gt;%\n  separate(\n    data,\n    into = c(\"my_numbers\", \"winning_numbers\"),\n    sep = \" \\\\| \"\n  )\n\ncard_data_split\n\n# A tibble: 212 √ó 3\n      id my_numbers                      winning_numbers                        \n   &lt;int&gt; &lt;chr&gt;                           &lt;chr&gt;                                  \n 1     1 \"69 12 75 19 83 56 73 53 52 91\" 83 63 56 30 77 94 12 81 42 69 52 70  6‚Ä¶\n 2     2 \"23 55 24 84 90 10 87 73 74 45\" 20 66 51 78  9 76 86 96 72 70 84 35 74‚Ä¶\n 3     3 \"70 32 38 23 86 54 26 16  9  1\" 67 50 39 70 59 77 63 30  3 45 23 16 72‚Ä¶\n 4     4 \"33 50 19 63 92  1 58 34 84  8\" 35 61 49 86 40 20 22 71 84 51 64 62 33‚Ä¶\n 5     5 \"74  9 54 83 22 15 81 64 47 70\" 21 74 59 85 17 36  5 79 87  7 13 23 47‚Ä¶\n 6     6 \"29 55 56 13 58 71 36 30 15 11\" 99 17 90 29 22 68 61 55 11 13 37 94 30‚Ä¶\n 7     7 \"92 70 97 62 33 45 85 59 82 73\" 92 35 11 49 88 14 85 42 40 41 69 51 82‚Ä¶\n 8     8 \" 5 22 64 46 32 90 57 83 37 38\" 87 47 91 35 39 64 73 83 71 22 10 45  1‚Ä¶\n 9     9 \" 7 49 62 79 37 91  3 58 74 19\" 17  7 58  2 53 95 52 62 83 41 42 36  4‚Ä¶\n10    10 \"84 33 81 45 99 96 76 97 40  2\" 81 26 11 34 83 25 45 76  2 85 33 64 57‚Ä¶\n# ‚Ñπ 202 more rows\n\n\nCreating a function that parses the sequences of numbers as numeric vectors:\n\nto_numbers &lt;- function(x) {\n  str_extract_all(x, \"\\\\d+\") %&gt;%\n  map(as.numeric)\n}\n\nFunction that takes two vectors and calcultes how many elements from the first one are in the second one:\n\ncalculate_n_winning &lt;- function(x, y) {\n  keep(x, ~magrittr::is_in(., y)) %&gt;%\n  length()\n}\n\n\ncard_data_processed &lt;-\n  card_data_split %&gt;%\n  mutate(across(c(my_numbers, winning_numbers), to_numbers)) %&gt;%\n  mutate(n_winning = map2_dbl(my_numbers, winning_numbers, calculate_n_winning))\n\ncard_data_processed\n\n# A tibble: 212 √ó 4\n      id my_numbers winning_numbers n_winning\n   &lt;int&gt; &lt;list&gt;     &lt;list&gt;              &lt;dbl&gt;\n 1     1 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n 2     2 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              8\n 3     3 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n 4     4 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              6\n 5     5 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              3\n 6     6 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              7\n 7     7 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n 8     8 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              5\n 9     9 &lt;dbl [10]&gt; &lt;dbl [25]&gt;              5\n10    10 &lt;dbl [10]&gt; &lt;dbl [25]&gt;             10\n# ‚Ñπ 202 more rows\n\n\nNow I need a function that doubles its output for each integer greater than 1. Specifically, the function should behave as follows:\n\nf(0) = 0\nf(1) = 1\nf(2) = 2\nf(3) = 4\nf(4) = 8\n\n\ncalculate_points &lt;- function(x) {\n  if (x == 0) {\n    return(0)\n  } else {\n    return(2^(x-1))\n  }\n}\n\nApplying the function to calculate how many points the cards are worth:\n\ncard_data_processed %&gt;%\n  mutate(points = map_dbl(n_winning, calculate_points)) %&gt;%\n  count(wt = points)\n\n# A tibble: 1 √ó 1\n      n\n  &lt;dbl&gt;\n1 25231\n\n\nThe solution is correct ü•≥"
  },
  {
    "objectID": "2023/day/4/index.html#part-2",
    "href": "2023/day/4/index.html#part-2",
    "title": "2023: Day 4",
    "section": "Part 2",
    "text": "Part 2\nHere I think I need to use some form of recursion:\n\n‚Äúyou win copies of the scratchcards below the winning card equal to the number of matches. So, if card 10 were to have 5 matching numbers, you would win one copy each of cards 11, 12, 13, 14, and 15.‚Äù\n\n\n‚ÄúCopies of scratchcards are scored like normal scratchcards and have the same card number as the card they copied. So, if you win a copy of card 10 and it has 5 matching numbers, it would then win a copy of the same cards that the original card 10 won: cards 11, 12, 13, 14, and 15. This process repeats until none of the copies cause you to win any more cards. (Cards will never make you copy a card past the end of the table.)‚Äù\n\nIt seems that the only column I need is n_winning, along with a new column to keep track of how many copies of the cards I have. I‚Äôll store the data in a matrix to access and modify it using indices.\n\ncard_data_pt2 &lt;-\n  card_data_processed %&gt;%\n  transmute(\n    n_matches = n_winning,\n    count = 1\n  ) %&gt;%\n  as.matrix()\n\ncard_data_pt2[1:10]\n\n [1] 10  8 10  6  3  7 10  5  5 10\n\n\nNow I need to code a procedure that captures the logic described in the prompt:\n\nn_original_cards &lt;- nrow(card_data_pt2)\n\nfor (i in 1:n_original_cards) {\n  n_matches_i &lt;- card_data_pt2[i, 1]\n  count_i &lt;- card_data_pt2[i, 2]\n\n  if (n_matches_i == 0) next\n\n  # If I have N copies of the current card, I'll win copies of the cards below N times\n  for (n in 1:count_i) {\n    for (j in 1:n_matches_i) {\n      if (i+j &lt;= n_original_cards) {\n        # Adding one copy of each of the j cards below\n        card_data_pt2[i+j, 2] = card_data_pt2[i+j, 2] + 1\n      }\n    }\n  } \n}\n\nAdding up the scratchcards using the count column:\n\nsum(card_data_pt2[,2])\n\n[1] 9721255"
  },
  {
    "objectID": "2023/day/9/index.html",
    "href": "2023/day/9/index.html",
    "title": "2023: Day 9",
    "section": "",
    "text": "The original challenge\nMy data\nPuzzle input: series of values about the oasis ecosystem. Each line corresponds to the history of a single value.\nFor example:\n0 3 6 9 12 15\n1 3 6 10 15 21\n10 13 16 21 30 45\nMust create environmental report with prediction of the next value in each series.\n\nTo do this, start by making a new sequence from the difference at each step of your history. If that sequence is not all zeroes, repeat this process, using the sequence you just generated as the input sequence. Once all of the values in your latest sequence are zeroes, you can extrapolate what the next value of the original history should be.\n\nExample:\n0   3   6   9  12  15\n  3   3   3   3   3\n    0   0   0   0\n\nTo extrapolate, start by adding a new zero to the end of your list of zeroes; because the zeroes represent differences between the two values above them, this also means there is now a placeholder in every sequence above it:\n\n0   3   6   9  12  15   B\n  3   3   3   3   3   A\n    0   0   0   0   0\nIn this example, the next value in sequence (B) is 18.\nNote that for each series it may be necessary to obtain a different number of sequences until reaching the all-zero differences.\n1   3   6  10  15  21\n  2   3   4   5   6\n    1   1   1   1\n      0   0   0\n\nAnalyze your OASIS report and extrapolate the next value for each history. What is the sum of these extrapolated values?"
  },
  {
    "objectID": "2023/day/9/index.html#setup-and-notes",
    "href": "2023/day/9/index.html#setup-and-notes",
    "title": "2023: Day 9",
    "section": "",
    "text": "The original challenge\nMy data\nPuzzle input: series of values about the oasis ecosystem. Each line corresponds to the history of a single value.\nFor example:\n0 3 6 9 12 15\n1 3 6 10 15 21\n10 13 16 21 30 45\nMust create environmental report with prediction of the next value in each series.\n\nTo do this, start by making a new sequence from the difference at each step of your history. If that sequence is not all zeroes, repeat this process, using the sequence you just generated as the input sequence. Once all of the values in your latest sequence are zeroes, you can extrapolate what the next value of the original history should be.\n\nExample:\n0   3   6   9  12  15\n  3   3   3   3   3\n    0   0   0   0\n\nTo extrapolate, start by adding a new zero to the end of your list of zeroes; because the zeroes represent differences between the two values above them, this also means there is now a placeholder in every sequence above it:\n\n0   3   6   9  12  15   B\n  3   3   3   3   3   A\n    0   0   0   0   0\nIn this example, the next value in sequence (B) is 18.\nNote that for each series it may be necessary to obtain a different number of sequences until reaching the all-zero differences.\n1   3   6  10  15  21\n  2   3   4   5   6\n    1   1   1   1\n      0   0   0\n\nAnalyze your OASIS report and extrapolate the next value for each history. What is the sum of these extrapolated values?"
  },
  {
    "objectID": "2023/day/9/index.html#part-1",
    "href": "2023/day/9/index.html#part-1",
    "title": "2023: Day 9",
    "section": "Part 1",
    "text": "Part 1\nI think it‚Äôs a good idea to load this data as a list of vectors (each row in the input would be a vector).\n\nlibrary(tidyverse)\nlibrary(here)\n\n\ninput &lt;- here(\"2023/day/9/input\")  %&gt;%\n  read_lines() %&gt;%\n  str_split(\" \") %&gt;%\n  map(as.numeric) %&gt;%\n  map(list)\n\ninput[1:5]\n\n[[1]]\n[[1]][[1]]\n [1]      3     10     23     46     99    234    563   1310   2904   6131\n[11]  12351  23745  43470  75464 123501 189097 268370 349700 418439 484617\n[21] 669380\n\n\n[[2]]\n[[2]][[1]]\n [1]     16     41     77    119    171    265    488   1017   2162   4417\n[11]   8519  15515  26837  44385  70618 108653 162372 236537 336913 470399\n[21] 645167\n\n\n[[3]]\n[[3]][[1]]\n [1]      20      45      91     182     351     648    1157    2027    3543\n[10]    6296   11556   22009   43088   85209  167316  322244  604526 1101399\n[19] 1947905 3347136 5596837\n\n\n[[4]]\n[[4]][[1]]\n [1]      24      50      87     141     223     341     487     621     653\n[10]     420    -352   -2121   -5670  -12365  -24598  -46505  -85074 -151786\n[19] -264963 -453031 -758943\n\n\n[[5]]\n[[5]][[1]]\n [1]       13       31       76      172      351      645     1075     1649\n [9]     2399     3508     5604    10347    21558    47460   105396   232221\n[17]   507493  1104469  2398816  5191706 11149877\n\n\nNow, for each item of the list, I should iteratively add diffs until all of the elements of the last diff are zero.\nLet‚Äôs do it for a base case:\n\nexample_case &lt;- input[[1]]\n\nlast_vector &lt;- example_case[[1]]\n\noutput &lt;- example_case\n\nwhile (any(last_vector) != 0) {\n  last_vector &lt;- diff(last_vector)\n  output &lt;- append(output, list(last_vector))\n}\n\noutput\n\n[[1]]\n [1]      3     10     23     46     99    234    563   1310   2904   6131\n[11]  12351  23745  43470  75464 123501 189097 268370 349700 418439 484617\n[21] 669380\n\n[[2]]\n [1]      7     13     23     53    135    329    747   1594   3227   6220\n[11]  11394  19725  31994  48037  65596  79273  81330  68739  66178 184763\n\n[[3]]\n [1]      6     10     30     82    194    418    847   1633   2993   5174\n[11]   8331  12269  16043  17559  13677   2057 -12591  -2561 118585\n\n[[4]]\n [1]      4     20     52    112    224    429    786   1360   2181   3157\n[11]   3938   3774   1516  -3882 -11620 -14648  10030 121146\n\n[[5]]\n [1]     16     32     60    112    205    357    574    821    976    781\n[11]   -164  -2258  -5398  -7738  -3028  24678 111116\n\n[[6]]\n [1]    16    28    52    93   152   217   247   155  -195  -945 -2094 -3140\n[13] -2340  4710 27706 86438\n\n[[7]]\n [1]    12    24    41    59    65    30   -92  -350  -750 -1149 -1046   800\n[13]  7050 22996 58732\n\n[[8]]\n [1]    12    17    18     6   -35  -122  -258  -400  -399   103  1846  6250\n[13] 15946 35736\n\n[[9]]\n [1]     5     1   -12   -41   -87  -136  -142     1   502  1743  4404  9696\n[13] 19790\n\n[[10]]\n [1]    -4   -13   -29   -46   -49    -6   143   501  1241  2661  5292 10094\n\n[[11]]\n [1]   -9  -16  -17   -3   43  149  358  740 1420 2631 4802\n\n[[12]]\n [1]   -7   -1   14   46  106  209  382  680 1211 2171\n\n[[13]]\n[1]   6  15  32  60 103 173 298 531 960\n\n[[14]]\n[1]   9  17  28  43  70 125 233 429\n\n[[15]]\n[1]   8  11  15  27  55 108 196\n\n[[16]]\n[1]  3  4 12 28 53 88\n\n[[17]]\n[1]  1  8 16 25 35\n\n[[18]]\n[1]  7  8  9 10\n\n[[19]]\n[1] 1 1 1\n\n[[20]]\n[1] 0 0\n\n\nNow let‚Äôs turn this into a function and apply it to the original list through purrr:map\n\nobtain_diffs &lt;- function(history) {\n  last_vector &lt;- history[[1]]\n\n  output &lt;- history\n\n  while (any(last_vector != 0)) {\n    last_vector &lt;- diff(last_vector)\n    output &lt;- append(output, list(last_vector))\n  }\n\n  output\n}\n\nobtain_diffs(input[[1]])\n\n[[1]]\n [1]      3     10     23     46     99    234    563   1310   2904   6131\n[11]  12351  23745  43470  75464 123501 189097 268370 349700 418439 484617\n[21] 669380\n\n[[2]]\n [1]      7     13     23     53    135    329    747   1594   3227   6220\n[11]  11394  19725  31994  48037  65596  79273  81330  68739  66178 184763\n\n[[3]]\n [1]      6     10     30     82    194    418    847   1633   2993   5174\n[11]   8331  12269  16043  17559  13677   2057 -12591  -2561 118585\n\n[[4]]\n [1]      4     20     52    112    224    429    786   1360   2181   3157\n[11]   3938   3774   1516  -3882 -11620 -14648  10030 121146\n\n[[5]]\n [1]     16     32     60    112    205    357    574    821    976    781\n[11]   -164  -2258  -5398  -7738  -3028  24678 111116\n\n[[6]]\n [1]    16    28    52    93   152   217   247   155  -195  -945 -2094 -3140\n[13] -2340  4710 27706 86438\n\n[[7]]\n [1]    12    24    41    59    65    30   -92  -350  -750 -1149 -1046   800\n[13]  7050 22996 58732\n\n[[8]]\n [1]    12    17    18     6   -35  -122  -258  -400  -399   103  1846  6250\n[13] 15946 35736\n\n[[9]]\n [1]     5     1   -12   -41   -87  -136  -142     1   502  1743  4404  9696\n[13] 19790\n\n[[10]]\n [1]    -4   -13   -29   -46   -49    -6   143   501  1241  2661  5292 10094\n\n[[11]]\n [1]   -9  -16  -17   -3   43  149  358  740 1420 2631 4802\n\n[[12]]\n [1]   -7   -1   14   46  106  209  382  680 1211 2171\n\n[[13]]\n[1]   6  15  32  60 103 173 298 531 960\n\n[[14]]\n[1]   9  17  28  43  70 125 233 429\n\n[[15]]\n[1]   8  11  15  27  55 108 196\n\n[[16]]\n[1]  3  4 12 28 53 88\n\n[[17]]\n[1]  1  8 16 25 35\n\n[[18]]\n[1]  7  8  9 10\n\n[[19]]\n[1] 1 1 1\n\n[[20]]\n[1] 0 0\n\n\n\nseries_with_diffs &lt;- map(input, obtain_diffs)\nseries_with_diffs[[1]]\n\n[[1]]\n [1]      3     10     23     46     99    234    563   1310   2904   6131\n[11]  12351  23745  43470  75464 123501 189097 268370 349700 418439 484617\n[21] 669380\n\n[[2]]\n [1]      7     13     23     53    135    329    747   1594   3227   6220\n[11]  11394  19725  31994  48037  65596  79273  81330  68739  66178 184763\n\n[[3]]\n [1]      6     10     30     82    194    418    847   1633   2993   5174\n[11]   8331  12269  16043  17559  13677   2057 -12591  -2561 118585\n\n[[4]]\n [1]      4     20     52    112    224    429    786   1360   2181   3157\n[11]   3938   3774   1516  -3882 -11620 -14648  10030 121146\n\n[[5]]\n [1]     16     32     60    112    205    357    574    821    976    781\n[11]   -164  -2258  -5398  -7738  -3028  24678 111116\n\n[[6]]\n [1]    16    28    52    93   152   217   247   155  -195  -945 -2094 -3140\n[13] -2340  4710 27706 86438\n\n[[7]]\n [1]    12    24    41    59    65    30   -92  -350  -750 -1149 -1046   800\n[13]  7050 22996 58732\n\n[[8]]\n [1]    12    17    18     6   -35  -122  -258  -400  -399   103  1846  6250\n[13] 15946 35736\n\n[[9]]\n [1]     5     1   -12   -41   -87  -136  -142     1   502  1743  4404  9696\n[13] 19790\n\n[[10]]\n [1]    -4   -13   -29   -46   -49    -6   143   501  1241  2661  5292 10094\n\n[[11]]\n [1]   -9  -16  -17   -3   43  149  358  740 1420 2631 4802\n\n[[12]]\n [1]   -7   -1   14   46  106  209  382  680 1211 2171\n\n[[13]]\n[1]   6  15  32  60 103 173 298 531 960\n\n[[14]]\n[1]   9  17  28  43  70 125 233 429\n\n[[15]]\n[1]   8  11  15  27  55 108 196\n\n[[16]]\n[1]  3  4 12 28 53 88\n\n[[17]]\n[1]  1  8 16 25 35\n\n[[18]]\n[1]  7  8  9 10\n\n[[19]]\n[1] 1 1 1\n\n[[20]]\n[1] 0 0\n\n\nCool, now the next step is to make the predictions/imputations using this data. Again, all the series behave independently, so they‚Äôre suitable for functional programming (creating functions and then apply them through purrr::map).\n\nexample_case &lt;- series_with_diffs[[1]]\n\ncurrent_element &lt;- example_case[[20]]\n\ncurrent_element[length(current_element)]\n\n[1] 0\n\n# I have to \"iterate in reverse\" from the last element to the first one\ncurrent_diff &lt;- 0\nfor (i in rev(seq_along(example_case))) {\n  current_seq &lt;- example_case[[i]]\n  last_el_seq &lt;- current_seq[length(current_seq)]\n  current_seq &lt;- c(current_seq, last_el_seq+current_diff)\n  example_case[[i]] &lt;- current_seq\n\n  current_diff &lt;- current_seq[length(current_seq)] # new element in the sequence\n}\n\nThe code above solves for a single, example case. Now I‚Äôll wrap it in a function and apply it to each of the sequences in the list:\n\nadd_to_history &lt;- function(history_with_diffs) {\n\n  current_element &lt;- history_with_diffs[[length(history_with_diffs)]]\n\n  # I have to \"iterate in reverse\" from the last element to the first one\n  current_diff &lt;- 0\n  for (i in rev(seq_along(history_with_diffs))) {\n    current_seq &lt;- history_with_diffs[[i]]\n    last_el_seq &lt;- current_seq[length(current_seq)]\n    current_seq &lt;- c(current_seq, last_el_seq+current_diff)\n    history_with_diffs[[i]] &lt;- current_seq\n\n    current_diff &lt;- current_seq[length(current_seq)] # new element in the sequence\n  }\n\n  history_with_diffs\n}\n\n\nseries_with_diffs2 &lt;- map(series_with_diffs, add_to_history)\n\nNow I have to get the last element of the first sequence (~.[[1]][length(.[[1]])]) in each element of series_with_diffs2 and add all them up.\n\nmap_dbl(series_with_diffs2, ~.[[1]][length(.[[1]])]) %&gt;%\n  sum()\n\n[1] 2174807968\n\n\nThe solution is correct!"
  },
  {
    "objectID": "2023/day/9/index.html#part-2",
    "href": "2023/day/9/index.html#part-2",
    "title": "2023: Day 9",
    "section": "Part 2",
    "text": "Part 2\nPart 2 is just extrapolating backwards instead of forwards. I‚Äôm sure that I can do this by just adjusting some parameters in the functions I‚Äôve already created.\n\nadd_to_history_backwards &lt;- function(history_with_diffs) {\n\n  current_element &lt;- history_with_diffs[[length(history_with_diffs)]]\n\n  # I have to \"iterate in reverse\" from the last element to the first one\n  current_diff &lt;- 0\n  for (i in rev(seq_along(history_with_diffs))) {\n    current_seq &lt;- history_with_diffs[[i]]\n    first_el_seq &lt;- current_seq[1]\n    current_seq &lt;- c(first_el_seq-current_diff, current_seq)\n    history_with_diffs[[i]] &lt;- current_seq\n\n    current_diff &lt;- current_seq[1] # new element in the sequence\n  }\n\n  history_with_diffs\n}\n\n\nmap(series_with_diffs, add_to_history_backwards) %&gt;%\n  map_dbl(~.[[1]][1]) %&gt;%\n  sum()\n\n[1] 1208\n\n\nIt‚Äôs correct too!"
  },
  {
    "objectID": "2023/day/10/index.html",
    "href": "2023/day/10/index.html",
    "title": "2023: Day 10",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/10/index.html#setup",
    "href": "2023/day/10/index.html#setup",
    "title": "2023: Day 10",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/10/index.html#part-1",
    "href": "2023/day/10/index.html#part-1",
    "title": "2023: Day 10",
    "section": "Part 1",
    "text": "Part 1\nThere are a lot of pipes and there is an animal hidden somewhere inside them. Puzzle input is a 2D sketch of all the surface pipes we can see.\n\n| is a vertical pipe connecting north and south.\n- is a horizontal pipe connecting east and west.\nL is a 90-degree bend connecting north and east.\nJ is a 90-degree bend connecting north and west.\n7 is a 90-degree bend connecting south and west.\nF is a 90-degree bend connecting south and east.\n. is ground; there is no pipe in this tile.\nS is the starting position of the animal; there is a pipe on this tile, but your sketch doesn‚Äôt show what shape the pipe has.\n\nPrompt suggests that the animal is inside ‚Äúone large, continuous loop‚Äù. For example, one like this:\n.....\n.F-7.\n.|.|.\n.L-J.\n.....\nWhich would have looked like this if the animal had entered through the northwest corner:\n.....\n.S-7.\n.|.|.\n.L-J.\n.....\nOther key facts:\n\nThe tile where the animal is doesn‚Äôt show its true shape, but it can be inferred from the surrounding pipes.\nThe pipe with S is assummed to connect back to the pipes that conect to it.\nThere are many pipes that don‚Äôt connect to the main loop.\n\n\nIf you want to get out ahead of the animal, you should find the tile in the loop that is farthest from the starting position. Because the animal is in the pipe, it doesn‚Äôt make sense to measure this by direct distance. Instead, you need to find the tile that would take the longest number of steps along the loop to reach from the starting point - regardless of which way around the loop the animal went.\n\nFor example, in the following loop:\n..F7.\n.FJ|.\nSJ.L7\n|F--J\nLJ...\nDistances would look like this:\n..45.\n.236.\n01.78\n14567\n23...\nThus, the farthest point is 8 steps away from the start.\nThe problem:\n\nFind the single giant loop starting at S. How many steps along the loop does it take to get from the starting position to the point farthest from the starting position?\n\nDataframe-like data structures don‚Äôt seem right for this problem. I‚Äôll probaby have to use 2D matrices and go through them with nested loops (kind of like the messy code I wrote for day 3). There might be a better data structure for approaching this, but unfortunately, I‚Äôm not aware of it yet.\n(I have a gut feeling that this could be addressed through Object-Oriented Programming? Like, defining each of the pipes as different classes? Anyway, onto the matrices‚Ä¶)\nLoading the sketch as a 2D matrix:\n\nlibrary(tidyverse)\nlibrary(here)\n\nsketch &lt;- read_lines(here(\"2023/day/10/input\")) %&gt;%\n  str_split(pattern = \"\", simplify=TRUE)\n\nsketch[1:10, 1:10]\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,] \"F\"  \"-\"  \"7\"  \"J\"  \"F\"  \"-\"  \"F\"  \"-\"  \"F\"  \"|\"  \n [2,] \"|\"  \"F\"  \"-\"  \"J\"  \"|\"  \"|\"  \"L\"  \"-\"  \".\"  \"J\"  \n [3,] \"F\"  \"F\"  \"-\"  \"7\"  \"7\"  \"-\"  \"7\"  \"L\"  \"7\"  \"F\"  \n [4,] \"F\"  \"7\"  \"-\"  \"J\"  \"|\"  \"F\"  \"J\"  \".\"  \"-\"  \"-\"  \n [5,] \"|\"  \"|\"  \"F\"  \"J\"  \"7\"  \"F\"  \"7\"  \"F\"  \"L\"  \"7\"  \n [6,] \"F\"  \"7\"  \"7\"  \".\"  \"-\"  \"F\"  \"J\"  \"J\"  \"L\"  \"J\"  \n [7,] \"L\"  \"|\"  \"-\"  \"L\"  \".\"  \"J\"  \"|\"  \".\"  \"|\"  \"L\"  \n [8,] \"F\"  \"|\"  \".\"  \"|\"  \".\"  \"L\"  \"|\"  \"7\"  \"-\"  \"|\"  \n [9,] \"L\"  \"J\"  \"F\"  \"L\"  \"L\"  \"F\"  \"J\"  \"7\"  \"J\"  \"L\"  \n[10,] \"|\"  \"-\"  \"J\"  \"7\"  \".\"  \"J\"  \"J\"  \".\"  \"7\"  \"7\"  \n\n\nNow, how to find the ‚Äúbig loop‚Äù?\nIdea: create a ‚Äútwin matrix‚Äù with the same dimensions as sketch, intially filled with NAs, to represent the distances from the origin.\n\nall_distances &lt;- matrix(\n  nrow = dim(sketch)[1],\n  ncol = dim(sketch)[2]\n)\n\nThen, look at the 8 tiles surrounding the starting tile (S) to start exploring the sketch grid.\n\nposition_s &lt;- which(sketch == \"S\", arr.ind = TRUE)\nposition_s\n\n     row col\n[1,]  76  54\n\n\n\ni &lt;- position_s[1]\nj &lt;- position_s[2]\n\nsurroundings &lt;- sketch[(i-1):(i+1), (j-1):(j+1)]\nsurroundings\n\n     [,1] [,2] [,3]\n[1,] \"-\"  \"-\"  \"J\" \n[2,] \"-\"  \"S\"  \"-\" \n[3,] \"7\"  \"F\"  \"-\" \n\n\nLet‚Äôs create a function that, given the surroundings matrix, assigns values of distance to the tiles that are connected to the central tile.\nFirst, I‚Äôll consider the particular case of the starting tile:\n\ndistances &lt;- matrix(nrow = 3, ncol = 3)\ndistances[2,2] &lt;- 0\n\n\nsouth_connecting_pipes &lt;- c(\"|\", \"7\", \"F\")\nwest_connecting_pipes &lt;- c(\"-\", \"J\", \"7\")\neast_connecting_pipes &lt;- c(\"-\", \"L\", \"F\")\nnorth_connecting_pipes &lt;- c(\"|\", \"L\", \"J\")\n\nif (surroundings[1, 2] %in% south_connecting_pipes) {\n  distances[1,2] &lt;- 1\n}\n\nif (surroundings[2, 1] %in% east_connecting_pipes) {\n  distances[2, 1] &lt;- 1\n}\n\nif (surroundings[3,2] %in% north_connecting_pipes) {\n  distances[3, 2] &lt;- 1\n}\n\nif (surroundings[2, 3] %in% west_connecting_pipes) {\n  distances[2, 3] &lt;- 1\n}\n\ndistances\n\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    1    0    1\n[3,]   NA   NA   NA\n\n\nI can now copy these local distances back to the all_distances twin matrix.\nAfter that, I could use which.max(all_distances) to find the tiles that are further away from the starting tile and still connected to it.\nFinally, I can repeat the distance assignment process, but this time starting from the tiles identified by which.max.\nCopying the distance values:\n\nall_distances[(i-1):(i+1), (j-1):(j+1)] &lt;- distances\n\nFinding the tiles that are further away from the start and still connected to it:\n\nfurther_away &lt;- which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE)\nfurther_away\n\n     row col\n[1,]  76  53\n[2,]  76  55\n\n\nLet‚Äôs take the coordinates of these points, explore their surroundings, and then assign distance values to the tiles that are connected to them.\nTo simplify, I‚Äôll first calculate the distances for just one of the further_away points:\n\ncurrent_tile1 &lt;- further_away[1,]\ni &lt;- current_tile1[1]\nj &lt;- current_tile1[2]\n\ndistances &lt;- all_distances[(i-1):(i+1), (j-1):(j+1)]\n\nsurroundings &lt;- sketch[(i-1):(i+1), (j-1):(j+1)]\nsurroundings\n\n     [,1] [,2] [,3]\n[1,] \"F\"  \"-\"  \"-\" \n[2,] \"L\"  \"-\"  \"S\" \n[3,] \"F\"  \"7\"  \"F\" \n\n\nAt this point, the rules for identifying connecting pipes should be extended to include scenarios where none of the tiles are marked with S. I‚Äôll define the function is_connected() for this purpose.\n\nhorizontally_connecting &lt;- \n # first element = left, second element=left\n  list(\n    c(\"-\", \"-\"),\n    c(\"-\", \"7\"),\n    c(\"-\", \"J\"),\n    c(\"L\", \"-\"),\n    c(\"L\", \"7\"),\n    c(\"L\", \"J\"),\n    c(\"F\", \"-\"),\n    c(\"F\", \"J\"),\n    c(\"F\", \"7\"),\n    c(\"S\", \"-\"),\n    c(\"S\", \"J\"),\n    c(\"S\", \"7\"),\n    c(\"-\", \"S\"),\n    c(\"L\", \"S\"),\n    c(\"F\", \"S\")\n  )\n\nvertically_connecting &lt;- \n # first element = top, second element = bottom\n  list(\n    c(\"|\", \"|\"),\n    c(\"F\", \"|\"),\n    c(\"7\", \"|\"),\n    c(\"|\", \"J\"),\n    c(\"F\", \"J\"),\n    c(\"7\", \"J\"),\n    c(\"F\", \"L\"),\n    c(\"7\", \"L\"),\n    c(\"|\", \"L\"),\n    c(\"S\", \"|\"),\n    c(\"S\", \"L\"),\n    c(\"S\", \"J\"),\n    c(\"|\", \"S\"),\n    c(\"7\", \"S\"),\n    c(\"F\", \"S\")\n  )\n\nis_connected &lt;- function(pair_tiles, direction) {\n  # the logic for identifying connecting pipes depends on the direction we're moving to\n  if (direction %in% c(\"N\", \"S\")) {\n    return (list(pair_tiles) %in% vertically_connecting)\n  } else {\n    return (list(pair_tiles) %in% horizontally_connecting)\n  }\n}\n\nUsing a named list to give friendly names to directions in the 3x3 matrices:\n\ndirections &lt;- list(\n  \"S\" = c(3, 2),\n  \"N\" = c(1, 2),\n  \"E\" = c(2, 3),\n  \"W\" = c(2, 1)\n)\n\nNow let‚Äôs use this function to calculate the distances surrounding our current location (current_tile1).\n\ncentral_tile &lt;- surroundings[2,2]\n\nfor (i_dir in seq_along(directions)) {\n  direction &lt;- names(directions)[i_dir]\n\n  surr_i &lt;- directions[[i_dir]][1]\n  surr_j &lt;- directions[[i_dir]][2]\n\n  cur_surr_tile &lt;- surroundings[surr_i, surr_j]\n\n  if (is.na(distances[surr_i, surr_j])) {\n    # NA in distance means a comparation hasn't been done\n    if (direction %in% c(\"S\", \"E\")) tile_pair &lt;- c(central_tile, cur_surr_tile)\n\n    if (direction %in% c(\"N\", \"W\")) tile_pair &lt;- c(cur_surr_tile, central_tile)\n\n    connected &lt;- is_connected(tile_pair, direction)\n\n    if (connected) {\n      distances[surr_i, surr_j] &lt;- distances[2,2] + 1\n    }\n  \n  }\n} \n\nall_distances[(i-1):(i+1), (j-1):(j+1)] &lt;- distances\n\nSo far, the code is working as expected.\nNow it‚Äôs time to organise the code into functions. I need to start with a function that does the following:\n\nReceives sketch, all_distances and a set of coordinates (the output of which.max) as inputs.\nExplores the surroundings of those coordinates.\nApplies the previously described logic to calculate distance values for tiles connected to those coordinates.\nReturn an updated version of the all_distances with the values from the previous step.\n\nThe set of coordinates will be assummed to be a matrix, as per the output of which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE).\n\nexplore_surroundings &lt;-\n  function(\n    coordinates,\n    this_sketch = sketch,\n    these_distances = all_distances) {\n\n      for (i_coord in seq_along(coordinates[,\"row\"])) {\n        i &lt;- coordinates[i_coord, \"row\"]\n        j &lt;- coordinates[i_coord, \"col\"]\n\n        surroundings &lt;- this_sketch[(i - 1):(i + 1), (j - 1):(j + 1)]\n        distances &lt;- these_distances[(i - 1):(i + 1), (j - 1):(j + 1)]\n\n        central_tile &lt;- surroundings[2, 2]\n\n        for (i_dir in seq_along(directions)) {\n          direction &lt;- names(directions)[i_dir]\n\n          surr_i &lt;- directions[[i_dir]][1]\n          surr_j &lt;- directions[[i_dir]][2]\n\n          cur_surr_tile &lt;- surroundings[surr_i, surr_j]\n\n          if (is.na(distances[surr_i, surr_j])) {\n            # NA in distance means a comparation hasn't been done\n            if (direction %in% c(\"S\", \"E\")) tile_pair &lt;- c(central_tile, cur_surr_tile)\n\n            if (direction %in% c(\"N\", \"W\")) tile_pair &lt;- c(cur_surr_tile, central_tile)\n\n            connected &lt;- is_connected(tile_pair, direction)\n\n            if (connected) {\n              distances[surr_i, surr_j] &lt;- distances[2, 2] + 1\n            }\n          }\n        }\n        these_distances[(i - 1):(i + 1), (j - 1):(j + 1)] &lt;- distances\n      }\n\n    return(these_distances)\n  }\n\nNow, I should be able to navigate through the pipes by repeatedly executing the following code:\n\n# Example code: not meant to run\nall_distances &lt;- explore_surroundings(further_away)\nfurther_away &lt;- which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE)\n\nI‚Äôm considering a while loop for this, but I‚Äôm not quite sure what the stopping condition should be. Maybe it could stop when it‚Äôs about to overwrite a cell that already has a distance value. That would mean we‚Äôre going back to a cell we‚Äôve already visited, suggesting the loop has come full circle.\nLet‚Äôs try doing that. First, we declare the starting conditions:\n\nfurther_away &lt;- which(sketch == \"S\", arr.ind = TRUE)\n\nall_distances &lt;- matrix(\n  nrow = dim(sketch)[1],\n  ncol = dim(sketch)[2]\n)\n\nall_distances[further_away[1, \"row\"], further_away[1, \"col\"]] &lt;- 0\n\nNow onto the loop itself:\n\nwhile (TRUE) {\n  new_distances &lt;- explore_surroundings(further_away)\n\n  # Stopping condition\n  if (sum(new_distances &gt; all_distances, na.rm = TRUE) &gt; 0) break\n\n  # Another stopping condition: the amount of NAs is the same (no exploration)\n  if (sum(is.na(new_distances)) == sum(is.na(all_distances))) break \n\n  all_distances &lt;- new_distances\n  further_away &lt;- which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE)\n}\n\nOnce the code stops, I just need to find the highest value in the all_distances matrix.\n\nmax(all_distances, na.rm = TRUE)\n\n[1] 6682\n\n\nIt‚Äôs correct! (I almost can‚Äôt believe it, given how messy my code is üòÖ)."
  },
  {
    "objectID": "2023/day/10/index.html#part-2",
    "href": "2023/day/10/index.html#part-2",
    "title": "2023: Day 10",
    "section": "Part 2",
    "text": "Part 2\nNow we have to calculate how many tiles are contained within the loop. The definition of being within the loop is quite specific. For example, in the sketch below, the tiles marked with 0 are technically outside the loop.\n..........\n.S------7.\n.|F----7|.\n.||OOOO||.\n.||OOOO||.\n.|L-7F-J|.\n.|II||II|.\n.L--JL--J.\n..........\n\nAny tile that isn‚Äôt part of the main loop can count as being enclosed by the loop.\n\nThe task is to find how many tiles are enclosed by the loop.\nBefore trying to solve this, I want to visualize the values in the all_distances matrix. This will help me get a better idea of the loop‚Äôs size and shape.\n\nlibrary(plot.matrix)\nlibrary(viridis)\nbrk &lt;- 6000\npar(mar=c(5.1, 4.1, 4.1, 4.1))\nsvg(\"all_distances.svg\", height=80, width=80)\n\n# Code of the plot\ndistances &lt;- plot(\n  all_distances,\n  border=NA,\n  breaks=brk,\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(brk), \n  digits=1,\n  text.cell=list(cex=0.5),\n  fmt.cell=\"%.0f\",\n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA)\n\n# Close the graphics device\ndev.off()\n\nThe output of the code above is a giant SVG image that depicts the full all_distances matrix, highlighting the tiles that are part of the loop (they‚Äôre colour-coded based on their distance to the starting tile and they also display the distance value as text on top of them).\nThe plot with the text is too big to show it on this page (here is the full-size version of the plot), so I‚Äôll display just a section of it below.\n\ni &lt;- position_s[1]\nj &lt;- position_s[2]\n\nplot(\n  all_distances[(i-10):(i+10), (j-10):(j+10)],\n  main=\"Tiles in the loop (and their distances to origin)\",\n  border=NA,\n  breaks=brk,\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(brk), \n  digits=1,\n  text.cell=list(cex=0.5),\n  fmt.cell=\"%.0f\",\n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA,\n  asp=1)\n\n\n\n\n\n\n\n\nAnd here is a ‚Äúminiature version‚Äù without the text (darker colours represent tiles closer to the origin and white represents tiles that are not part of the loop).\n\nplot(\n  all_distances,\n  main=NULL,\n  border=NA,\n  breaks=brk,\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(brk), \n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA,\n  asp=1)\n\n\n\n\n\n\n\n\nBased on the plot, we can see that the loop is really big and has a complex shape, including many twists and turns.\nI‚Äôm also curious about how many ‚Äòarms‚Äô or paths branch off from the loop. Are there any that lead to dead-ends and don‚Äôt reconnect with the main loop? (In that case, there would be distance values I would have to discard before identifying the tiles enclosed by the loop).\n\ndistances_values &lt;- 1:max(all_distances, na.rm = TRUE)\n\nn_tiles_distance &lt;- function(distance) {\n  return(sum(all_distances == distance, na.rm=TRUE))\n}\n\ntibble(\n  distances = distances_values,\n  n_paths = map_dbl(distances, n_tiles_distance)\n) %&gt;%\n  count(n_paths)\n\n# A tibble: 2 √ó 2\n  n_paths     n\n    &lt;dbl&gt; &lt;int&gt;\n1       1     1\n2       2  6681\n\n\nThere are always only two paths branching off the starting tile, ensuring there are no ‚Äòdead-ends‚Äô in the loop.\nNext steps:\n\nTraverse the loop in a counter-clockwise direction, inspecting the tiles to the left of the path. Consider tiles with NA as distance value as ‚Äúenclosed‚Äù by the loop.\nAfter identifying these inner loop cells (and verifying via visual inspection that they actually are within the loop), initiate a ‚Äòcontagion‚Äô process. This means marking contiguous non-loop tiles as ‚Äúenclosed by the loop‚Äù.\n\nImplementing my idea for the ‚Äúbase case‚Äù (the starting tile S):\n\nstarting_position &lt;- which(all_distances == 0, arr.ind = TRUE)\ni &lt;- starting_position[1, \"row\"]\nj &lt;- starting_position[1, \"col\"]\n\ndirections &lt;- list(\n  \"S\" = c(3, 2),\n  \"N\" = c(1, 2),\n  \"W\" = c(2, 1),\n  \"E\" = c(2, 3)\n)\n\nThe coordinates for ‚Äòthe cell to the left‚Äô and ‚Äòthe cell to the right‚Äô will vary depending on the direction. E.g. if we go South from the centre tile (2,2 to 3,2), the coordinates of the ‚Äúcell to the right‚Äù are going to be 3,1.\n\nto_the_right &lt;- list(\n  \"S\" = c(3, 1),\n  \"N\" = c(1, 3),\n  \"E\" = c(3, 3),\n  \"W\" = c(1, 1)\n)\n\nto_the_left &lt;- list(\n  \"S\" = c(3, 3),\n  \"N\" = c(1, 1),\n  \"E\" = c(1, 3),\n  \"W\" = c(3, 1)\n)\n\nI‚Äôll use the value -1 in the distances matrix to mark the tiles that are enclosed by the loop.\n\nnew_i &lt;- i\nnew_j &lt;- j\nwhile (TRUE) {\n  distances &lt;- all_distances[(new_i-1):(new_i+1), (new_j-1):(new_j+1)]\n\n  # I'll use the `directions` vector which was declared before to check the cardinal coordinates\n  # Given the order of the list `directions`, this loop will go East first\n  for (i_dir in seq_along(directions)) {\n    direction &lt;- names(directions)[i_dir]\n\n    surr_i &lt;- directions[[i_dir]][1]\n    surr_j &lt;- directions[[i_dir]][2]\n\n    surr_dist_val &lt;- replace_na(distances[surr_i, surr_j], 0)\n\n    # Go in the direction of the cell that increments distance by 1\n    if (surr_dist_val - distances[2, 2] == 1) {\n      #  mark the tile to the left as \"inside\"\n      i_left &lt;- to_the_left[[direction]][1]\n      j_left &lt;- to_the_left[[direction]][1]\n\n      if (is.na(distances[i_left, j_left])) {\n        distances[i_left, j_left] &lt;- -1\n      }\n\n      # Updating i and j to reflect that we moved\n      new_i &lt;- i + surr_i - 2\n      new_j &lt;- j + surr_j - 2\n      break\n    }\n  }\n\n  # stopping condition: \n  if (distances[2, 2] == all_distances[new_i, new_j]) break\n\n  all_distances[(i-1):(i+1), (j-1):(j+1)] &lt;- distances\n\n  i &lt;- new_i\n  j &lt;- new_j\n}\n\nCounting the tiles that have been marked as inside the loop until now.\n\nsum(all_distances == -1, na.rm=TRUE)\n\n[1] 390\n\n\nVisual inspection:\n\nplot(\n  all_distances,\n  main='Tiles inside the loop (before the contagion process)',\n  sub=\"White = NA / Grey = Part of the loop / Black = enclosed by the loop\",\n  border=NA,\n  breaks=c(-1, 1),\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(4), \n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA,\n  asp=1)\n\n\n\n\n\n\n\n\nAfter looking carefully at the full-size visualisation, it seems there are two issues:\n\nI‚Äôm not correctly handling the case then the loop takes a turn.\nOnly one of the loop‚Äôs ‚Äòarms‚Äô is being traversed, but there are two.\n\nUnfortunately, the time I‚Äôve spent on this problem has exceeded my ‚Äútime budget‚Äù and I‚Äôm not even sure that the algorithm I‚Äôm implementing will lead to the correct solution, so I‚Äôm deciding to stop here."
  },
  {
    "objectID": "2023/day/5/index.html",
    "href": "2023/day/5/index.html",
    "title": "2023: Day 5",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/5/index.html#setup",
    "href": "2023/day/5/index.html#setup",
    "title": "2023: Day 5",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/5/index.html#part-1",
    "href": "2023/day/5/index.html#part-1",
    "title": "2023: Day 5",
    "section": "Part 1",
    "text": "Part 1\nInput: an almanac that lists all the seeds that need to be planted to solve Island Island food production problem.\nWe start with a list of seeds identified by numbers.\nMapping System: Each seed is associated, based on its number, with specific types of agricultural resources (soil, fertilizer, water, and so on), which are also identified by numbers, through a series of mappings that connect ‚Äúsource‚Äù numbers with ‚Äúdestination‚Äù numbers.\n\n[The mappings indicate] what type of soil to use with each kind of seed, what type of fertilizer to use with each kind of soil, what type of water to use with each kind of fertilizer, and so on.\n\n\nEvery type of seed, soil, fertilizer and so on is identified with a number, but numbers are reused by each category - that is, soil 123 and fertilizer 123 aren‚Äôt necessarily related to each other.\n\nFor example:\nseeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nRather than list every source number and its corresponding destination number one by one, the maps describe entire ranges of numbers that can be converted‚Ä¶\n\n\nThe first line has a destination range start of 50, a source range start of 98, and a range length of 2. This line means that the source range starts at 98 and contains two values: 98 and 99. The destination range is the same length, but it starts at 50, so its two values are 50 and 51. With this information, you know that seed number 98 corresponds to soil number 50 and that seed number 99 corresponds to soil number 51.\n\n\nAny source numbers that aren‚Äôt mapped correspond to the same destination number. So, seed number 10 corresponds to soil number 10.\n\nAvailable mappings go from seed to location (seed -&gt; soil -&gt; fertilizer -&gt; water -&gt; light -&gt; temperature -&gt; humidity -&gt; location).\n\nFind the lowest location number that corresponds to any of the initial seeds\n\nIdeas of how to approach this problem:\n\nStore seeds numbers as a vector.\nTurn each mapping into a function.\nCrazy idea: make a ‚Äúfunction factory‚Äù (https://adv-r.hadley.nz/function-factories.html) to programatically create functions for each mapping using the numbers from each one.\n\nStoring the seeds as a vector:\n\nseeds &lt;- read_lines(here(\"2023/day/5/input\"), n_max = 1) %&gt;%\n  str_extract_all(\"\\\\d+\") %&gt;%\n  as_vector() %&gt;%\n  as.numeric()\n\nseeds\n\n [1] 2906422699    6916147 3075226163  146720986  689152391  244427042\n [7]  279234546  382175449 1105311711    2036236 3650753915  127044950\n[13] 3994686181   93904335 1450749684  123906789 2044765513  620379445\n[19] 1609835129   60050954\n\n\nNow it‚Äôs time to load the mappings. I‚Äôll start loading a single mapping in a vector as a ‚Äúproof of concept‚Äù:\n\nseed_to_soil &lt;-\n  read_lines(here(\"2023/day/5/input\"), skip = 3, n_max = 22)\n\nseed_to_soil\n\n [1] \"2642418175 2192252668 3835256\"   \"2646253431 2276158914 101631202\"\n [3] \"2640809144 3719389865 1609031\"   \"2439110058 2377790116 121628096\"\n [5] \"439727986 2712085714 392957193\"  \"993018128 1316992003 327657967\" \n [7] \"832685179 1875058987 50438969\"   \"2796039666 0 1107546829\"        \n [9] \"182253984 3569317158 150072707\"  \"2747884633 1826903954 48155033\" \n[11] \"2268424297 3406848659 162468499\" \"0 1644649970 182253984\"         \n[13] \"1794130013 2499418212 105266207\" \"2560738154 2196087924 80070990\" \n[15] \"1512587867 1925497956 72096972\"  \"2094053960 3729216158 174370337\"\n[17] \"1320676095 3105042907 191911772\" \"1899396220 1997594928 194657740\"\n[19] \"2430892796 3720998896 8217262\"   \"1584684839 1107546829 209445174\"\n[21] \"332326691 2604684419 107401295\"  \"883124148 3296954679 109893980\" \n\n\nThe sample mapping was correctly loaded but I think it will be easier to work with the mappings if I transform them into a dataframe first.\n\nmapping &lt;- \n  seed_to_soil %&gt;%\n  map(~str_split_1(., \" \")) %&gt;%\n  map(as.numeric) %&gt;%\n  map(~set_names(., c(\"start_dest\", \"start_source\", \"range\"))) %&gt;%\n  enframe() %&gt;%\n  unnest_wider(value) %&gt;%\n  mutate(\n    end_source = start_source + range - 1,\n    offset = start_dest - start_source\n    ) %&gt;%\n  select(start_source, end_source, offset) %&gt;%\n  arrange(start_source)\n\nmapping\n\n# A tibble: 22 √ó 3\n   start_source end_source      offset\n          &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1            0 1107546828  2796039666\n 2   1107546829 1316992002   477138010\n 3   1316992003 1644649969  -323973875\n 4   1644649970 1826903953 -1644649970\n 5   1826903954 1875058986   920980679\n 6   1875058987 1925497955 -1042373808\n 7   1925497956 1997594927  -412910089\n 8   1997594928 2192252667   -98198708\n 9   2192252668 2196087923   450165507\n10   2196087924 2276158913   364650230\n# ‚Ñπ 12 more rows\n\n\nNow I‚Äôll create a function that receives a function as input (e.g.¬†a seed) and:\n\nLooks up which source range does it belong to (this is very similar to Excel‚Äôs VLOOKUP).\nReturns the input number adjusted by the corresponding offset.\n\n\ncompute_mapping &lt;- function(input, mapping) {\n  tibble(input = input) %&gt;%\n  left_join(\n    mapping, by = join_by(between(input, start_source, end_source))) %&gt;%\n  mutate(\n    offset = replace_na(offset, 0),\n    output = input + offset\n  ) %&gt;%\n  pull(output)\n}\n\n\ncompute_mapping(seeds, mapping)\n\n [1]  634064971 2802955813  802868435 2942760652 3485192057 3040466708\n [7] 3075274212 3178215115 3901351377 2798075902  263690741 2923084616\n[13] 3994686181 2889944001 1126775809 2919946455 1946566805 3416419111\n[19] 1285861254 2856090620\n\n\nThis works as expected for the sample mapping.\nNow I need to generalise this procedure. For this, I have to read all the mappings from the input file as dataframes.\nThe following pipeline does just that, creating a nested dataframe where the first column is the name of the mapping (e.g.¬†seed-to-soil, soil-to-fertilizer, and so on) and the second column is the mapping itself.\n\nmappings_df &lt;-\n  read_lines(here(\"2023/day/5/input\"), skip =2) %&gt;%\n  tibble(x = .) %&gt;%\n  filter(x != \"\") %&gt;%\n  mutate(name = str_match(x, '(.+) map')[,2]) %&gt;%\n  fill(name) %&gt;%\n  filter(!str_detect(x, \"map\")) %&gt;%\n  nest(data = x) %&gt;%\n  mutate(data = map(data, as_vector))\n\nmappings_df\n\n# A tibble: 7 √ó 2\n  name                    data      \n  &lt;chr&gt;                   &lt;list&gt;    \n1 seed-to-soil            &lt;chr [22]&gt;\n2 soil-to-fertilizer      &lt;chr [28]&gt;\n3 fertilizer-to-water     &lt;chr [48]&gt;\n4 water-to-light          &lt;chr [38]&gt;\n5 light-to-temperature    &lt;chr [47]&gt;\n6 temperature-to-humidity &lt;chr [40]&gt;\n7 humidity-to-location    &lt;chr [23]&gt;\n\n\nThere‚Äôs just one problem: the mappings in the column data are not yet parsed as dataframes. They‚Äôre currently just vectors, with each item combining the source, destination, and offset into a single string.\n\nmappings_df[['data']][[1]][1:5]\n\n                               x1                                x2 \n  \"2642418175 2192252668 3835256\" \"2646253431 2276158914 101631202\" \n                               x3                                x4 \n  \"2640809144 3719389865 1609031\" \"2439110058 2377790116 121628096\" \n                               x5 \n \"439727986 2712085714 392957193\" \n\n\nTo solve this, I‚Äôm creating the function chr_to_mapping, which takes these character vectors as input and returns the mapping dataframes I want as output.\n\nchr_to_mapping &lt;- function(chr)  {\n  chr %&gt;%\n  map(~str_split_1(., \" \")) %&gt;%\n  map(as.numeric) %&gt;%\n  map(~set_names(., c(\"start_dest\", \"start_source\", \"range\"))) %&gt;%\n  enframe() %&gt;%\n  unnest_wider(value) %&gt;%\n  mutate(\n    end_source = start_source + range - 1,\n    offset = start_dest - start_source\n    ) %&gt;%\n  select(start_source, end_source, offset) %&gt;%\n  arrange(start_source)\n}\n\nNext, I use purrr::map to apply this function to the data column, creating the mappings list-column that contains the dataframes I need.\n\nmappings_df &lt;- mappings_df %&gt;%\n  mutate(\n    mappings = map(data, chr_to_mapping)\n  )\n\nThen, I can simply pull the mappings, and starting with the seeds, use the compute_mapping function to apply all the mappings and determine the final location values.\n\nmappings &lt;- mappings_df %&gt;% pull(mappings)\n\nvalues &lt;- seeds\n\nfor (i in seq_along(mappings)) {\n  values &lt;- compute_mapping(values, mappings[[i]])\n}\n\nThe solution is just the minimum of these location values.\n\nmin(values)\n\n[1] 177942185"
  },
  {
    "objectID": "2023/day/5/index.html#part-2",
    "href": "2023/day/5/index.html#part-2",
    "title": "2023: Day 5",
    "section": "Part 2",
    "text": "Part 2\nNow it turns out that the seeds are actually RANGES.\n\nThe values on the initial seeds: line come in pairs. Within each pair, the first value is the start of the range and the second value is the length of the range. So, in the first line of the example above:\n\n\nseeds: 79 14 55 13\n\n\nThis line describes two ranges of seed numbers to be planted in the garden. The first range starts with seed number 79 and contains 14 values: 79, 80, ‚Ä¶, 91, 92. The second range starts with seed number 55 and contains 13 values: 55, 56, ‚Ä¶, 66, 67.\n\nIt seems the computational cost/complexity of my solution is going to scale abruptly given this new interpretation of the input.\nThe first thing I‚Äôll try to do is to represent the ranges as vectors:\n\nseeds_m &lt;- matrix(seeds, ncol = 2, byrow = TRUE) \n\ncolnames(seeds_m) &lt;- c(\"start\", \"range\")\n\ndf_all_seeds &lt;- as_tibble(seeds_m) %&gt;%\n  mutate(all_seeds = map2(start, range, ~as.numeric(.x:(.x + .y))))\n\ndf_all_seeds\n\n# A tibble: 10 √ó 3\n        start     range all_seeds          \n        &lt;dbl&gt;     &lt;dbl&gt; &lt;list&gt;             \n 1 2906422699   6916147 &lt;dbl [6,916,148]&gt;  \n 2 3075226163 146720986 &lt;dbl [146,720,987]&gt;\n 3  689152391 244427042 &lt;dbl [244,427,043]&gt;\n 4  279234546 382175449 &lt;dbl [382,175,450]&gt;\n 5 1105311711   2036236 &lt;dbl [2,036,237]&gt;  \n 6 3650753915 127044950 &lt;dbl [127,044,951]&gt;\n 7 3994686181  93904335 &lt;dbl [93,904,336]&gt; \n 8 1450749684 123906789 &lt;dbl [123,906,790]&gt;\n 9 2044765513 620379445 &lt;dbl [620,379,446]&gt;\n10 1609835129  60050954 &lt;dbl [60,050,955]&gt; \n\n\nI tried (in code that not shown here) to just run my previous code on all_seeds but it just doesn‚Äôt work: my computer runs out of memory.\nThen I tried some alternative approaches that may have been more efficient, such as:\n\nCollapsing all the mappings (seed-to-soil, soil-to-fertilizer, and so on) into just one look-up table that directly maps seeds to locations. This may save memory in the compute_mapping process. The problem is that this is easier said than done. Implementing this idea is not trivial, at least not for me. After a couple of attempts I ended up giving up with this path because I didn‚Äôt have enough time to figure out how to pull it off.\nUsing the intervals R package. This package seems to allow performing interval operations (such as intersections and complements) in a more efficient way, without having to explicitly load all the numbers of the interval in memory. Unfortunately, I also ran out of my ‚Äútime budget‚Äù when trying to implement this idea, so I ended up giving up on it too. Still, I have a strong feeling that ‚Äúthis was the way‚Äù to efficiently tackle Part 2 of this problem.\n\nNote: one of the issues I couldn‚Äôt solve was that the intervals are so huge that even trying to perform one transformation causes a cannot allocate vector of size XX.X Gb error. This problem is not addressed by the ‚Äúcollapsing all the mappings‚Äù idea. So, even if I had been able to implement it, I would still have ran into the same error. That‚Äôs why I suspect that the intervals approach has higher chances of success."
  },
  {
    "objectID": "2023/day/2023-introduction/index.html",
    "href": "2023/day/2023-introduction/index.html",
    "title": "2023: Introduction",
    "section": "",
    "text": "Welcome to my Advent of Code 2023 journey! This year, I‚Äôve decided to put a bit of extra-whimsy on this already whimsical set of puzzles by using a ‚Äúspinning wheel‚Äù to decide whether I‚Äôll attempt to solve each day‚Äôs puzzle using R or Python:\nThis method allows me to both strengthen my already substantial R skills and also improve my fluency in Python, a language in which I have more progress to make.\nI‚Äôll aim to post the solutions in a conversational, narrative manner, sharing not only the final code, but also the thought process I followed to solve each problem."
  },
  {
    "objectID": "2023/day/2023-introduction/index.html#on-llms-usage",
    "href": "2023/day/2023-introduction/index.html#on-llms-usage",
    "title": "2023: Introduction",
    "section": "On LLMs usage",
    "text": "On LLMs usage\nI‚Äôm adhering to the guidelines and suggestions made by the Advent of Code team regarding the use of LLMs like ChatGPT to solve the puzzles. That means I‚Äôm not using ChatGPT‚Äôs help to arrive at the solutions I‚Äôm posting on this website. However, once I‚Äôm done with a problem (that means, either solving it or giving up), I may use LLMs to seek feedback or explore alternative approaches."
  },
  {
    "objectID": "2022.html",
    "href": "2022.html",
    "title": "2022",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2022: Day 1\n\n\nbase R, lists\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "fonts/LICENSE.html",
    "href": "fonts/LICENSE.html",
    "title": "iA Writer Typeface",
    "section": "",
    "text": "iA Writer Typeface\nCopyright ¬© 2018 Information Architects Inc.¬†with Reserved Font Name ‚ÄúiA Writer‚Äù\n\n\nBased on IBM Plex Typeface\nCopyright ¬© 2017 IBM Corp.¬†with Reserved Font Name ‚ÄúPlex‚Äù\n\n\nLicense\nThis Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL\n\n\n\nSIL OPEN FONT LICENSE Version 1.1 - 26 February 2007\n\n\n\nPREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.\nThe OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.\nDEFINITIONS ‚ÄúFont Software‚Äù refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.\n‚ÄúReserved Font Name‚Äù refers to any names specified as such after the copyright statement(s).\n‚ÄúOriginal Version‚Äù refers to the collection of Font Software components as distributed by the Copyright Holder(s).\n‚ÄúModified Version‚Äù refers to any derivative made by adding to, deleting, or substituting ‚Äì in part or in whole ‚Äì any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.\n‚ÄúAuthor‚Äù refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.\nPERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:\n\nNeither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.\nOriginal or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.\nNo Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.\nThe name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.\nThe Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.\n\nTERMINATION This license becomes null and void if any of the above conditions are not met.\nDISCLAIMER THE FONT SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE."
  },
  {
    "objectID": "2022/day/1/index.html",
    "href": "2022/day/1/index.html",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#setup",
    "href": "2022/day/1/index.html#setup",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#part-1",
    "href": "2022/day/1/index.html#part-1",
    "title": "2022: Day 1",
    "section": "Part 1",
    "text": "Part 1\nI‚Äôm including this post in the website example to demonstrate what a typical post will look like, using post-template, in the _templates directory as a starting point. This post is created by a call to aoc_new_day(1, 2022). It can be deleted with a call to aoc_delete_day(1, 2022), or all posts and the listing for the year can be deleted with aoc_delete_year(2022).\n\n\n\n\n\n\nNote\n\n\n\nThis is Ella Kaye‚Äôs solution1, with her puzzle input. If attempting this challenge yourself, your solution will be different.\n\n\n\nlibrary(aochelpers)\ninput &lt;- aoc_input_vector(1, 2022, \"numeric\")\n\nI‚Äôm using the aoc_input_vector() function from the aochelpers package to read in the data, but otherwise using base R functions (including the native pipe, |&gt;) for this puzzle.\nIn this challenge, we‚Äôre given groups of numbers and we need to find the sum of each group. Our solution is the largest of these. The groups are separated by a blank line. When reading in the input as a numeric vector, these are coerced to NA. We can identify the new groups by the NA values, produce an index for them with cumsum(is.na(input)), which increments when a new NA is reached, then use this with split() to split the input into a list of vectors, one for each group. We need the argument na.rm = TRUE in sapply() because each vector, other than the first, starts with NA, as that‚Äôs where it was split.\n\ntotals &lt;- split(input, cumsum(is.na(input))) |&gt; \n  sapply(sum, na.rm = TRUE) \n\nmax(totals)\n\n[1] 66719"
  },
  {
    "objectID": "2022/day/1/index.html#part-2",
    "href": "2022/day/1/index.html#part-2",
    "title": "2022: Day 1",
    "section": "Part 2",
    "text": "Part 2\nThis is similar, except we want to find the sum of the sums of the top three groups.\n\ntotals |&gt; \n  sort() |&gt; \n  tail(3) |&gt; \n  sum()\n\n[1] 198551"
  },
  {
    "objectID": "2022/day/1/index.html#footnotes",
    "href": "2022/day/1/index.html#footnotes",
    "title": "2022: Day 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nElla is the author of this website template and of the aochelpers package, and the author of this demo post.‚Ü©Ô∏é"
  }
]