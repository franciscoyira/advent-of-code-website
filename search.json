[
  {
    "objectID": "2022/day/1/index.html",
    "href": "2022/day/1/index.html",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#setup",
    "href": "2022/day/1/index.html#setup",
    "title": "2022: Day 1",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2022/day/1/index.html#part-1",
    "href": "2022/day/1/index.html#part-1",
    "title": "2022: Day 1",
    "section": "Part 1",
    "text": "Part 1\nI’m including this post in the website example to demonstrate what a typical post will look like, using post-template, in the _templates directory as a starting point. This post is created by a call to aoc_new_day(1, 2022). It can be deleted with a call to aoc_delete_day(1, 2022), or all posts and the listing for the year can be deleted with aoc_delete_year(2022).\n\n\n\n\n\n\nNote\n\n\n\nThis is Ella Kaye’s solution1, with her puzzle input. If attempting this challenge yourself, your solution will be different.\n\n\n\n\nCode\nlibrary(aochelpers)\ninput &lt;- aoc_input_vector(1, 2022, \"numeric\")\n\n\nI’m using the aoc_input_vector() function from the aochelpers package to read in the data, but otherwise using base R functions (including the native pipe, |&gt;) for this puzzle.\nIn this challenge, we’re given groups of numbers and we need to find the sum of each group. Our solution is the largest of these. The groups are separated by a blank line. When reading in the input as a numeric vector, these are coerced to NA. We can identify the new groups by the NA values, produce an index for them with cumsum(is.na(input)), which increments when a new NA is reached, then use this with split() to split the input into a list of vectors, one for each group. We need the argument na.rm = TRUE in sapply() because each vector, other than the first, starts with NA, as that’s where it was split.\n\n\nCode\ntotals &lt;- split(input, cumsum(is.na(input))) |&gt; \n  sapply(sum, na.rm = TRUE) \n\nmax(totals)\n\n\n[1] 66719"
  },
  {
    "objectID": "2022/day/1/index.html#part-2",
    "href": "2022/day/1/index.html#part-2",
    "title": "2022: Day 1",
    "section": "Part 2",
    "text": "Part 2\nThis is similar, except we want to find the sum of the sums of the top three groups.\n\n\nCode\ntotals |&gt; \n  sort() |&gt; \n  tail(3) |&gt; \n  sum()\n\n\n[1] 198551"
  },
  {
    "objectID": "2022/day/1/index.html#footnotes",
    "href": "2022/day/1/index.html#footnotes",
    "title": "2022: Day 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nElla is the author of this website template and of the aochelpers package, and the author of this demo post.↩︎"
  },
  {
    "objectID": "2023.html",
    "href": "2023.html",
    "title": "2023",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2023: Introduction\n\n\nintro\n\n\n\n\n2023: Day 1\n\n\nR,stringr\n\n\n\n\n2023: Day 2\n\n\nR,stringr\n\n\n\n\n2023: Day 3\n\n\npython,arrays\n\n\n\n\n2023: Day 6\n\n\npython,optimisation\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "fonts/LICENSE.html",
    "href": "fonts/LICENSE.html",
    "title": "iA Writer Typeface",
    "section": "",
    "text": "iA Writer Typeface\nCopyright © 2018 Information Architects Inc. with Reserved Font Name “iA Writer”\n\n\nBased on IBM Plex Typeface\nCopyright © 2017 IBM Corp. with Reserved Font Name “Plex”\n\n\nLicense\nThis Font Software is licensed under the SIL Open Font License, Version 1.1. This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL\n\n\n\nSIL OPEN FONT LICENSE Version 1.1 - 26 February 2007\n\n\n\nPREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.\nThe OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.\nDEFINITIONS “Font Software” refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.\n“Reserved Font Name” refers to any names specified as such after the copyright statement(s).\n“Original Version” refers to the collection of Font Software components as distributed by the Copyright Holder(s).\n“Modified Version” refers to any derivative made by adding to, deleting, or substituting – in part or in whole – any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.\n“Author” refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.\nPERMISSION & CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:\n\nNeither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.\nOriginal or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.\nNo Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.\nThe name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.\nThe Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.\n\nTERMINATION This license becomes null and void if any of the above conditions are not met.\nDISCLAIMER THE FONT SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE."
  },
  {
    "objectID": "2023/day/3/index.html",
    "href": "2023/day/3/index.html",
    "title": "2023: Day 3",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/3/index.html#setup",
    "href": "2023/day/3/index.html#setup",
    "title": "2023: Day 3",
    "section": "",
    "text": "The original challenge\nMy data"
  },
  {
    "objectID": "2023/day/3/index.html#part-1",
    "href": "2023/day/3/index.html#part-1",
    "title": "2023: Day 3",
    "section": "Part 1",
    "text": "Part 1\nNotes:\n\nA part is missing from an engine; we have to figure out which one using the numbers in the engine schematic (puzzle input).\nAny number adjacent to a symbol, even diagonally, is a “part number” and should be included in the sum.\nPeriods do not count as a symbol.\n\nExample\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\nIn this schematic, two numbers are not part numbers because they are not adjacent to a symbol: 114 (top right) and 58 (middle right). Every other number is adjacent to a symbol and so is a part number; their sum is 4361.\n\nProblems I see:\n\nThe input is a sort of matrix/grid, but we’re working with multi-digit numbers that occupy several slots/cells of the matrix.\nComputations need to span both vertical and horizontal axes (so dataframe-oriented methods and functions may not be suitable here).\n\nAt this moment, I have no idea which data structure to use for this problem.\nThe only thing that comes to mind is to put the data in a numpy array, then use a nested for loop to check certain conditions.\n\n\nCode\nimport numpy as np\nimport pandas as pd\n\n\nImporting the data in a numpy array where each element is a character of the input file.\n\n\nCode\n# Inspiration for this: https://stackoverflow.com/a/75643841/7221164\nwith open('input', 'r') as f:\n    input = np.stack([np.fromiter(list(line.strip()), dtype=\"object\") for line in f])\n    print(input)\n\n\n[['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '1' ... '.' '.' '.']\n ...\n ['.' '.' '.' ... '1' '3' '.']\n ['.' '9' '6' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']]\n\n\n\n\nCode\ninput.shape\n\n\n(140, 140)\n\n\nImplementing my for loop\n\nIn current_number, I’ll add the digits I find as I iterate (will reset when a period or a line break is found).\nis_valid is a flag indicating whether the current_number should be counted in the sum (i.e., if any of its digits is adjacent to a symbol).\nrunning_sum keeps track of the total of all valid numbers.\n\n\n\nCode\ndebugging_array = []\ncurrent_number = None\nis_valid = False\nrunning_sum = 0\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\n# Inspiration for this: https://stackoverflow.com/a/49360371\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n\n    if not value.isdigit() or (ix == 0 and iy &gt; 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        if is_valid:\n          debugging_array.append(str(current_number) + \" is valid\")\n          running_sum += current_number\n          is_valid = False\n        else:\n          debugging_array.append(str(current_number) + \" is NOT valid\")\n\n        # reset current_numner\n        current_number = None\n    \n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n\n      # check the surrounding elements to know if there is a symbol (only if is_valid = False, otherwise it's not necessary)\n      if is_valid is False:\n        for offset_y, offset_x in np.ndindex((3,3)):\n          curr_y=iy+offset_y-1\n          curr_x=ix+offset_x-1\n\n          # Exception when the \"neighbour\" would be out of the array\n          if curr_y &lt; 0 or curr_x &lt; 0 or curr_y &gt; max_y or curr_x &gt; max_x:\n            continue\n\n          # Exception when we're on the same number\n          if curr_y == iy and curr_x == ix:\n            continue\n\n          # The check itself\n          # If one of the surrounding elements is not a dot or a digit, the flag switches to True and the for loop ends\n          if input[curr_y, curr_x] != \".\" and not input[curr_y, curr_x].isdigit():\n            is_valid = True\n            break \n\n\nInspecting how the first numbers from the input were classified:\n\n\nCode\ndebugging_array[:10]\n\n\n['401 is valid',\n '425 is NOT valid',\n '323 is NOT valid',\n '791 is valid',\n '697 is valid',\n '963 is NOT valid',\n '420 is NOT valid',\n '290 is valid',\n '492 is NOT valid',\n '656 is valid']\n\n\nChecking my solution:\n\n\nCode\nprint(running_sum)\n\n\n543867\n\n\nThe code is very ugly (for my taste), but the solution is correct!!"
  },
  {
    "objectID": "2023/day/3/index.html#part-2",
    "href": "2023/day/3/index.html#part-2",
    "title": "2023: Day 3",
    "section": "Part 2",
    "text": "Part 2\n\nOne of the gears in the engine is malfunctioning. A gear is represented by a ’*’ symbol, and it must be adjacent to exactly two part numbers. The gear ratio is calculated by multiplying these two numbers together.\nTask is to determine the gear ratio for each gear and then add them up.\n\nExample:\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\nHere there are two gears. The first one is located in the top left corner, with part numbers 467 and 35, resulting in a gear ratio of 16345. The second gear is in the lower right corner, and its gear ratio is 451490. (Note that the ’*’ adjacent to 617 is not a gear because it’s only adjacent to one part number.)\n\n\nTo find the total sum of all the gear ratios in your engine schematic, simply add them up.\n\nIdea to solve this part: each time a number is valid, put it in the corresponding position of a new array that has the same dimensions as the input array.\nThen, iterate over the input array with a new for loop that searches for “*” and counts the N of valid numbers surrounding it.\n\n\nCode\narr_pt2 = np.zeros(input.shape)\n\ncurrent_number = None\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n    \n    # Case when the element is a * (potentially a gear)\n    if value == \"*\":\n      arr_pt2[iy, ix] = -1\n\n    # Checking if a number just ended\n    if not value.isdigit() or (ix == 0 and iy &gt; 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        # I need to write the current_number on the previous positions of arr_pt2\n        # Things to take into account:\n        # 1. overflowing across rows\n        # 2. I need to write the number on as many cells as digits the number has \n\n        for i in range(len(str(current_number))):\n          # ex: for a 3 digit number, offset will take values -1, -2 and -3\n          offset = -1 - i\n          # we first try to go back one cell in the x axis\n          # (move to the left across the same row)\n          ix_offset = ix + offset\n          iy_offset = iy\n\n          # case when we overflow the beginning of the row\n          if ix_offset &lt; 0:\n            # we move up in the y-axis\n            iy_offset = iy_offset-1\n\n            # when ix_offset == -1, we add 140 to end up with 139\n            ix_offset=ix_offset+input.shape[1]\n\n            # example\n            # if iy_offset, ix_offset == 10, -1\n            # we end up in 9, 139\n          arr_pt2[iy_offset, ix_offset] = current_number\n\n        # reset current_numner\n        current_number = None\n\n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n\n\nAfter this rather messy for loop, I should be able to identify gears by looking at the surrounding cells of all the ‘-1’ values in the array, which represent ’*’.\n\n\nCode\nmax_y = arr_pt2.shape[0] -1\nmax_x = arr_pt2.shape[1] -1\n\nrunning_sum = 0\n\nfor iy, ix in np.ndindex(arr_pt2.shape):\n  value = arr_pt2[iy, ix]\n\n  neighbours = set()\n\n  if value == -1:\n    for offset_y, offset_x in np.ndindex((3,3)):\n      curr_y=iy+offset_y-1\n      curr_x=ix+offset_x-1\n\n      # Exception when the \"neighbour\" would be out of the array\n      if curr_y &lt; 0 or curr_x &lt; 0 or curr_y &gt; max_y or curr_x &gt; max_x:\n        continue\n\n      # Exception when we're on the same number\n      if curr_y == iy and curr_x == ix:\n        continue\n\n      # The check itself\n      # if a surrounding cell is a number, then I'll add it to the `neighbours` set (this data structure handles duplicated numbers automatically)\n      if arr_pt2[curr_y, curr_x] &gt; 0:\n        neighbours.add(arr_pt2[curr_y, curr_x])\n\n  \n  if len(neighbours) == 2:\n    # multiply the neighbours\n    running_sum += neighbours.pop() * neighbours.pop()\n\n\nChecking my solution:\n\n\nCode\nprint(running_sum)\n\n\n79613331.0\n\n\nIt was correct!"
  },
  {
    "objectID": "2023/day/2/index.html",
    "href": "2023/day/2/index.html",
    "title": "2023: Day 2",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nThere are three types of cubes: green, red, and blue.\nSecret number of each type in a bag, have to figure out number.\nWe have “sample data” from the bag.\nThe input includes info (samples) from previous games.\nGames are identified by an ID (e.g., Game 11).\n\nExample:\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\nIn Game 1, three sets of cubes are sampled from the bag (then returned). The first set contains 3 blue and 4 red cubes; the second set has 1 red cube, 2 green cubes, and 6 blue cubes; the third set consists solely of 2 green cubes.\nWhich games would have been possible if the bag had contained only 12 red cubes, 13 green cubes, and 14 blue cubes? Game 3 would have been impossible as it required 20 red cubes at one point.\nAfter filtering out the impossible games, we can sum their IDs (for instance, in this example, we would obtain a total of 8)."
  },
  {
    "objectID": "2023/day/2/index.html#setup",
    "href": "2023/day/2/index.html#setup",
    "title": "2023: Day 2",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nThere are three types of cubes: green, red, and blue.\nSecret number of each type in a bag, have to figure out number.\nWe have “sample data” from the bag.\nThe input includes info (samples) from previous games.\nGames are identified by an ID (e.g., Game 11).\n\nExample:\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\nIn Game 1, three sets of cubes are sampled from the bag (then returned). The first set contains 3 blue and 4 red cubes; the second set has 1 red cube, 2 green cubes, and 6 blue cubes; the third set consists solely of 2 green cubes.\nWhich games would have been possible if the bag had contained only 12 red cubes, 13 green cubes, and 14 blue cubes? Game 3 would have been impossible as it required 20 red cubes at one point.\nAfter filtering out the impossible games, we can sum their IDs (for instance, in this example, we would obtain a total of 8)."
  },
  {
    "objectID": "2023/day/2/index.html#part-1",
    "href": "2023/day/2/index.html#part-1",
    "title": "2023: Day 2",
    "section": "Part 1",
    "text": "Part 1\n\nDetermine which games would have been possible if the bag had been loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?\n\n\n\nCode\nlibrary(tidyverse)\nlibrary(here)\n\ninput &lt;- read_file(here(\"2023/day/2/input\")) %&gt;%\n  str_split_1(pattern = '\\n') %&gt;%\n  magrittr::extract(1:100)\n\ninput[1:10]\n\n\n [1] \"Game 1: 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"                                                \n [2] \"Game 2: 11 green, 7 blue, 15 red; 13 red, 6 green, 2 blue; 7 green, 9 red, 10 blue; 5 blue, 1 red, 11 green; 4 blue, 18 green; 4 red, 8 blue, 18 green\"\n [3] \"Game 3: 7 red, 10 green, 4 blue; 2 blue, 3 green, 5 red; 9 red, 7 green, 3 blue; 3 blue, 6 green, 18 red\"                                              \n [4] \"Game 4: 1 blue, 2 green, 5 red; 10 red, 1 blue, 3 green; 14 red\"                                                                                       \n [5] \"Game 5: 16 red, 4 green, 19 blue; 13 blue, 9 red; 7 green, 14 red, 2 blue; 5 green, 18 blue, 4 red; 7 red, 2 blue, 3 green; 8 blue, 12 green\"          \n [6] \"Game 6: 3 blue, 8 green; 4 red, 5 green; 5 red, 8 blue, 5 green; 8 blue, 4 green; 3 red, 7 green, 2 blue\"                                              \n [7] \"Game 7: 7 red, 2 blue; 5 red, 6 green; 10 red; 2 blue, 12 red, 2 green; 4 red, 1 blue, 1 green; 9 green, 2 blue, 10 red\"                               \n [8] \"Game 8: 3 red, 7 green, 3 blue; 2 green, 3 blue, 3 red; 3 blue, 4 green, 1 red; 3 blue, 3 red; 2 blue, 6 green; 2 red, 7 green, 1 blue\"                \n [9] \"Game 9: 5 red, 6 green; 6 red; 2 blue, 3 green, 9 red; 6 green, 2 blue\"                                                                                \n[10] \"Game 10: 5 red, 8 blue, 5 green; 15 red, 6 green, 7 blue; 8 blue, 6 red, 5 green; 5 green, 2 blue; 12 red, 6 blue; 6 green, 16 red, 6 blue\"            \n\n\nWhat is the most suitable data structure for solving this problem?\nI believe I need only this information:\n\nThe ID of the game.\nThe maximum number of cubes for each colour.\n\nRegarding the number of cubes: is the maximum alone sufficient?\nConsider there are 10 red cubes.\nIf the maximum is 10 or less, the game was possible. If the maximum is 11 or more, the game was impossible.\nIndeed, I just need the maximum number of cubes for each colour in each game.\nI think a tibble would be a suitable data structure to store this information.\nLet’s start with the first game:\n\n\nCode\nfirst_game &lt;- input[1]\nfirst_game\n\n\n[1] \"Game 1: 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"\n\n\nSpecial characters to handle:\n\n:\n,\n`;\n\n\n\nCode\ngame_data &lt;-\n  tibble(\n    input = input\n  ) %&gt;%\n    separate(\n      input,\n      into = c(\"id\", \"data\"),\n      sep = \": \"\n    ) %&gt;%\n    mutate(\n      id = as.integer(str_extract(id, \"\\\\d+\"))\n    )\n\ngame_data\n\n\n# A tibble: 100 × 2\n      id data                                                                   \n   &lt;int&gt; &lt;chr&gt;                                                                  \n 1     1 8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue…\n 2     2 11 green, 7 blue, 15 red; 13 red, 6 green, 2 blue; 7 green, 9 red, 10 …\n 3     3 7 red, 10 green, 4 blue; 2 blue, 3 green, 5 red; 9 red, 7 green, 3 blu…\n 4     4 1 blue, 2 green, 5 red; 10 red, 1 blue, 3 green; 14 red                \n 5     5 16 red, 4 green, 19 blue; 13 blue, 9 red; 7 green, 14 red, 2 blue; 5 g…\n 6     6 3 blue, 8 green; 4 red, 5 green; 5 red, 8 blue, 5 green; 8 blue, 4 gre…\n 7     7 7 red, 2 blue; 5 red, 6 green; 10 red; 2 blue, 12 red, 2 green; 4 red,…\n 8     8 3 red, 7 green, 3 blue; 2 green, 3 blue, 3 red; 3 blue, 4 green, 1 red…\n 9     9 5 red, 6 green; 6 red; 2 blue, 3 green, 9 red; 6 green, 2 blue         \n10    10 5 red, 8 blue, 5 green; 15 red, 6 green, 7 blue; 8 blue, 6 red, 5 gree…\n# ℹ 90 more rows\n\n\nI need to obtain the number of cubes that have appeared for each colour:\n\n\nCode\ngame_data_1 &lt;- game_data[[\"data\"]][[1]]\ngame_data_1\n\n\n[1] \"8 green, 4 red, 4 blue; 1 green, 6 red, 4 blue; 7 red, 4 green, 1 blue; 2 blue, 8 red, 8 green\"\n\n\nI think I can use str_match_all with a capturing pattern associated with the colours and simply ignore everything else.\n\n\nCode\nn_cubes_colour &lt;- \n  str_match_all(\n    game_data_1,\n    \"(\\\\d+) ([red|green|blue]+)\"\n  )[[1]][,2:3]\n\ncolnames(n_cubes_colour) &lt;- c(\"n\", \"colour\")\n\nn_cubes_colour %&gt;%\n  as_tibble() %&gt;%\n  group_by(colour) %&gt;%\n  summarise(n = max(as.numeric(n)))\n\n\n# A tibble: 3 × 2\n  colour     n\n  &lt;chr&gt;  &lt;dbl&gt;\n1 blue       4\n2 green      8\n3 red        8\n\n\nNow it’s time to wrap the code above into a function and apply it to all the games:\n\n\nCode\nget_count_cubes &lt;-\n  function(x) {\n    matrix_count_cubes &lt;-\n    str_match_all(\n      x,\n      \"(\\\\d+) ([red|green|blue]+)\"\n    )[[1]][,2:3]\n\n    colnames(matrix_count_cubes) &lt;- c(\"n\", \"colour\")\n\n    matrix_count_cubes %&gt;%\n      as_tibble() %&gt;%\n      group_by(colour) %&gt;%\n      summarise(n = max(as.numeric(n)))\n}\n\n\n(I’m concerned this approach may not scale effectively if the input for the second part is significantly larger.)\n\n\nCode\ngame_data_tidy &lt;- \n  game_data %&gt;%\n  mutate(data = map(data, get_count_cubes)) %&gt;%\n  unnest(data) %&gt;%\n  pivot_wider(\n    id_cols = id,\n    names_from = colour,\n    values_from = n\n  )\n\n\nMy attempted solution to determine which games would have been possible if the bag had been loaded with only 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?.\n\n\nCode\ngame_data_tidy %&gt;%\n  filter(red &lt;= 12, green &lt;= 13, blue &lt;= 14) %&gt;%\n  pull(id) %&gt;%\n  sum()\n\n\n[1] 2085\n\n\nIT IS CORRECT!!! 🥳🥳🥳🥳"
  },
  {
    "objectID": "2023/day/2/index.html#part-2",
    "href": "2023/day/2/index.html#part-2",
    "title": "2023: Day 2",
    "section": "Part 2",
    "text": "Part 2\n\nIn each game you played, what is the fewest number of cubes of each color that could have been in the bag to make the game possible?\n\n\nThe power of a set of cubes is equal to the numbers of red, green, and blue cubes multiplied together. The power of the minimum set of cubes in game 1 is 48. In games 2-5 it was 12, 1560, 630, and 36, respectively. Adding up these five powers produces the sum 2286.\n\n\nFor each game, find the minimum set of cubes that must have been present. What is the sum of the power of these sets?\n\nGiven the data structure I’m using, this second part seems easy.\n\n\nCode\ngame_data_tidy %&gt;%\n  summarise(sum(red*green*blue))\n\n\n# A tibble: 1 × 1\n  `sum(red * green * blue)`\n                      &lt;dbl&gt;\n1                     79315\n\n\nIt is correct too!!"
  },
  {
    "objectID": "2023/day/2023-introduction/index.html",
    "href": "2023/day/2023-introduction/index.html",
    "title": "2023: Introduction",
    "section": "",
    "text": "Welcome to my Advent of Code 2023 journey! This year, I’ve decided to put a bit of extra-whimsy on this already whimsical set of puzzles by using a “spinning wheel” to decide whether I’ll attempt to solve each day’s puzzle using R or Python:\nThis method allows me to both strengthen my already substantial R skills and also improve my fluency in Python, a language in which I have more progress to make.\nI’ll aim to post the solutions in a conversational, narrative manner, sharing not only the final code, but also the thought process I followed to solve each problem."
  },
  {
    "objectID": "2023/day/2023-introduction/index.html#on-llms-usage",
    "href": "2023/day/2023-introduction/index.html#on-llms-usage",
    "title": "2023: Introduction",
    "section": "On LLMs usage",
    "text": "On LLMs usage\nI’m adhering to the guidelines and suggestions made by the Advent of Code team regarding the use of LLMs like ChatGPT to solve the puzzles. That means I’m not using ChatGPT’s help to arrive at the solutions I’m posting on this website. However, once I’m done with a problem (that means, either solving it or giving up), I may use LLMs to seek feedback or explore alternative approaches."
  },
  {
    "objectID": "2023/day/6/index.html",
    "href": "2023/day/6/index.html",
    "title": "2023: Day 6",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nWe arrive to Island Island\nThere should be a large pile of sand but there isn’t\nBoat races to win trip to Desert Island: fixed amount of time and boat has to travel as far as it can\nInput: time allowed for each race and best distance until now\nTo win, we need to go farther than each current record holder\nBoats are toy boats: we press a button to charge them, and release them to allow them to move.\n\n\nBoats move faster if their button was held longer, but time spent holding the button counts against the total race time. You can only hold the button at the start of the race, and boats don’t move until the button is released.\n\n\nYour toy boat has a starting speed of zero millimeters per millisecond. For each whole millisecond you spend at the beginning of the race holding down the button, the boat’s speed increases by one millimeter per millisecond.\n\n\nThis is an optimisation problem.\nFor each problem, we have several ways (amount of time we can press the button) that allow us to beat the current record holder.\n\n\nTo see how much margin of error you have, determine the number of ways you can beat the record in each race; in this example, if you multiply these values together, you get 288 (4 * 8 * 9)."
  },
  {
    "objectID": "2023/day/6/index.html#setup",
    "href": "2023/day/6/index.html#setup",
    "title": "2023: Day 6",
    "section": "",
    "text": "The original challenge\nMy data\nNotes:\n\nWe arrive to Island Island\nThere should be a large pile of sand but there isn’t\nBoat races to win trip to Desert Island: fixed amount of time and boat has to travel as far as it can\nInput: time allowed for each race and best distance until now\nTo win, we need to go farther than each current record holder\nBoats are toy boats: we press a button to charge them, and release them to allow them to move.\n\n\nBoats move faster if their button was held longer, but time spent holding the button counts against the total race time. You can only hold the button at the start of the race, and boats don’t move until the button is released.\n\n\nYour toy boat has a starting speed of zero millimeters per millisecond. For each whole millisecond you spend at the beginning of the race holding down the button, the boat’s speed increases by one millimeter per millisecond.\n\n\nThis is an optimisation problem.\nFor each problem, we have several ways (amount of time we can press the button) that allow us to beat the current record holder.\n\n\nTo see how much margin of error you have, determine the number of ways you can beat the record in each race; in this example, if you multiply these values together, you get 288 (4 * 8 * 9)."
  },
  {
    "objectID": "2023/day/6/index.html#part-1",
    "href": "2023/day/6/index.html#part-1",
    "title": "2023: Day 6",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nimport pandas as pd\nimport numpy as np\n\n\n\n\nCode\nf = open(\"input\", \"r\")\ninput = f.readlines()\n# input is a list\n\n\nExtracting the times:\n\n\nCode\nimport re\ntimes = re.findall('[0-9]+', input[0])\ntimes = list(map(int, times))\n\n\nExtracting the distances:\n\n\nCode\ndistances = re.findall('[0-9]+', input[1])\ndistances = list(map(int, distances))\n\n\nNext, I think I could write a function that, for any pair of times and distances, returns the count of different values of time that allow to surpass the current record.\nFirst, let’s write the code of a particular case (using the example in the prompt)\n\n\nCode\ntime = 7\ndistance = 9\nn_possible_wins = 0\n\nfor i in range(time):\n  speed = i\n  available_time = time - i\n  my_distance = speed*available_time\n\n  if my_distance &gt; distance:\n    n_possible_wins += 1\n\nprint(n_possible_wins)\n\n\n4\n\n\n\n\nCode\ndef calculate_n_ways_to_win(time, distance):\n  n_possible_wins = 0\n\n  for i in range(time):\n    speed = i\n    available_time = time - i\n    my_distance = speed*available_time\n\n    if my_distance &gt; distance:\n      n_possible_wins += 1\n\n  return(n_possible_wins)\n\n\n\n\nCode\ncalculate_n_ways_to_win(7, 9)\n\n\n4\n\n\nNow I need to iterate across the two lists. I would like to do that using something similar to map2, instead of a for loop\n\n\nCode\nn_ways = list(map(calculate_n_ways_to_win, times, distances))\n\n\n\n\nCode\nimport operator\nfrom functools import reduce\n\nreduce(operator.mul, n_ways)\n\n\n1660968"
  },
  {
    "objectID": "2023/day/6/index.html#part-2",
    "href": "2023/day/6/index.html#part-2",
    "title": "2023: Day 6",
    "section": "Part 2",
    "text": "Part 2\nThe input interpretation changed and all the values of time and distance now actually represent two big numbers.\n\n\nCode\ncalculate_n_ways_to_win(47986698, 400121310111540)\n\n\n26499773"
  },
  {
    "objectID": "2023/day/1/index.html",
    "href": "2023/day/1/index.html",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a “calibration document”\nHas been “amended” by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#setup",
    "href": "2023/day/1/index.html#setup",
    "title": "2023: Day 1",
    "section": "",
    "text": "The original challenge\nMy data\nChosen language: R\nNotes:\n\nPuzzle input is a “calibration document”\nHas been “amended” by an Elf\nEach line was a calibration value, that now needs to be recovered\nValue can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n1abc2 -&gt; 12\npqr3stu8vwx -&gt; 38\na1b2c3d4e5f -&gt; 15\ntreb7uchet -&gt; 77\n\nAdding these together produces 142.\nDo the same for the whole puzzle input"
  },
  {
    "objectID": "2023/day/1/index.html#part-1",
    "href": "2023/day/1/index.html#part-1",
    "title": "2023: Day 1",
    "section": "Part 1",
    "text": "Part 1\n\n\nCode\nlibrary(tidyverse)\nlibrary(here)\n\n\nTransforming the data to an appropriate data structure:\n\n\nCode\namended &lt;- read_lines(here('2023', 'day', '1', 'input'))\namended[1:10]\n\n\n [1] \"nqninenmvnpsz874\"                          \n [2] \"8twofpmpxkvvdnpdnlpkhseven4ncgkb\"          \n [3] \"six8shdkdcdgseven8xczqrnnmthreecckfive\"    \n [4] \"qlcnz54dd75nine7jfnlfgz\"                   \n [5] \"7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr\"\n [6] \"cdhmktwo6kjqbprvfour8\"                     \n [7] \"ninekkvkeight9three\"                       \n [8] \"ms9five71lrfpqxqlbj\"                       \n [9] \"9five9sevenldshqfgcnq\"                     \n[10] \"1one4seven\"                                \n\n\n\nSolving for a particular case\n\n\nCode\n(first_case &lt;- amended[1])\n\n\n[1] \"nqninenmvnpsz874\"\n\n\nExtracting the numbers\n\n\nCode\n(matrix_str_numbers &lt;-\n  str_extract_all(first_case, pattern = '\\\\d', simplify = TRUE))\n\n\n     [,1] [,2] [,3]\n[1,] \"8\"  \"7\"  \"4\" \n\n\nExtracting all the rows from columns one and three (the first and last number of each row)\n\n\nCode\nnumbers_i_want &lt;- matrix_str_numbers[, c(1,3)]\nnumbers_i_want\n\n\n[1] \"8\" \"4\"\n\n\n(This code will generalise ONLY IF all the other rows have 3 numbers too).\nThe following code returns the first and last number “pasted” together and converts the result from string to numeric.\n\n\nCode\nstringr::str_flatten(numbers_i_want) %&gt;%\n  as.numeric()\n\n\n[1] 84\n\n\nNow let’s try to generalise to all input rows:\n\n\nCode\namended %&gt;%\n  str_extract_all(pattern = '\\\\d', simplify = TRUE) %&gt;%\n  head(5)\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n[1,] \"8\"  \"7\"  \"4\"  \"\"   \"\"   \"\"   \"\"  \n[2,] \"8\"  \"4\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[3,] \"8\"  \"8\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[4,] \"5\"  \"4\"  \"7\"  \"5\"  \"7\"  \"\"   \"\"  \n[5,] \"7\"  \"2\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n\n\nOh no. Rows have a different quantity of digits.\nMaybe using simplify=TRUE was a mistake here. Given that each element has a different quantity of digits, a list seems to be a more suitable data structure:\n\n\nCode\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(5)\n\nlist_digits_preview\n\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nNow, how can I extract the first and last element from each element of the list? My gut feeling is that I’ll need purrr for this:\npluck and keep_at seem to be useful functions for this task\n\n\nCode\nlist_digits_preview %&gt;%\n  # This should extract the first and last digit from each element of the list \n  map(~keep_at(., c(1, length(.))))\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n\nIt is working!!\nNow I’ll apply the action to the whole list:\n\n\nCode\nlist_useful_digits &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(~keep_at(., c(1, length(.))))\n\nlist_useful_digits[1:10]\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nHmmm… Why does element 7 have only 1 digit?\n\n\nCode\namended[7]\n\n\n[1] \"ninekkvkeight9three\"\n\n\nIt’s got just one digit as a number, but there are other digits written out in words. Should we count those? The prompt isn’t really clear about this. But since the example only talks about digits as numbers, I guess I’ll just go with those for now. If I’ve got this wrong and my solution gets rejected, well, I can always give it another shot\nNow let’s concatenate the digits row-wise, turn them into a number and add them up:\n\n\nCode\nsolution &lt;- \n  list_useful_digits %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution\n\n\n[1] 39347\n\n\n👎🏽 Solution was rejected. The website says it’s too low 🤔\nThe most likely suspect here is the way map(~keep_at(., c(1, length(.)))) is handling the rows with only one digit.\nSome alternatives I could try:\n\nIf the input row has only one digit, then use it as first AND last digit when building the number (e.g. if the row only contains 7, the number I would obtain from that row should be 77).\nTake into account digits that are written as words (e.g. “three”). This is less likely to work and it would be weird for the exercise to expect people to do this and not mentioning it explicitely in the prompt or the examples.\n\nI’ll go with alternative 1.\n\n\nHandling rows with just one digit\nI’ll take a slice from the first 10 rows, as the first case with one digit appears in row 7:\n\n\nCode\nlist_digits_preview &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  head(10)\n\nlist_digits_preview\n\n\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"7\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nI have a feeling that purrr::pluck may do the trick here:\n\n\nCode\nget_first_and_last &lt;- function(x) {\n  c(pluck(x, 1), pluck(x, length(x)))\n}\n\nlist_digits_preview %&gt;%\n  map(get_first_and_last)\n\n\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\" \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n\n\nThis function does what I want (and yes, using pluck is a bit unnecessary since I could just have used regular subsetting, e.g. x[[1]] and x[[length(x)]], but I’m doing this with the purrr cheat sheet in front of me, so pluck was what came to my mind).\n2nd attempt, this time using get_first_and_last.\n\n\nCode\nsolution2 &lt;- \n  amended %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution2\n\n\n[1] 56397\n\n\nThis is the correct solution!! 🥳🥳🥳\nOnto the second part!"
  },
  {
    "objectID": "2023/day/1/index.html#part-2",
    "href": "2023/day/1/index.html#part-2",
    "title": "2023: Day 1",
    "section": "Part 2",
    "text": "Part 2\nSaw this one coming: now I need to tackle the digits spelled out as words 😬.\n\nFirst (naive) attempt\nIMHO the simplest approach is to write a function that converts digits spelled out in a string into their numeric form. Then, I can incorporate this function into my pipeline using a map call, right before str_extract_all.\n\n\nCode\ncase_with_spelled_digit &lt;- amended[7]\ncase_with_spelled_digit\n\n\n[1] \"ninekkvkeight9three\"\n\n\n\n\nCode\ncase_with_spelled_digit %&gt;%\n  str_replace_all(\n    c(\n      \"nine\" = \"9\",\n      \"eight\" = \"8\",\n      \"three\" = \"3\"\n    )\n  )\n\n\n[1] \"9kkvk893\"\n\n\nWorking as expected.\nNow let’s apply the function to the full data.\nI’ll start by creating the replacement vector (although I’m pretty sure it’s already a part of some R package that’s slipping my mind right now).\n\n\nCode\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\"\n)\n\n\n\n\nCode\nsolution3 &lt;- \n  amended %&gt;%\n  str_replace_all(pattern = digits) %&gt;%\n  str_extract_all(pattern = '\\\\d') %&gt;%\n  map(get_first_and_last) %&gt;%\n  map(str_flatten) %&gt;%\n  map(as.integer) %&gt;%\n  as_vector() %&gt;%\n  sum()\n\nsolution3\n\n\n[1] 55266\n\n\nThe solution wasn’t right.\n\n\nSecond attempt: handling overlapping patterns\nTime to take a closer look at the pipeline using a tibble.\n\n\nCode\ntibble(\n  original = amended,\n  new = original %&gt;%\n    str_replace_all(pattern = digits),\n  digits = amended %&gt;%\n    str_replace_all(pattern = digits) %&gt;%\n    str_extract_all(pattern = '\\\\d') %&gt;%\n    map(get_first_and_last) %&gt;%\n    map(str_flatten) %&gt;%\n    as_vector()\n)\n\n\n# A tibble: 1,000 × 3\n   original                                   new                         digits\n   &lt;chr&gt;                                      &lt;chr&gt;                       &lt;chr&gt; \n 1 nqninenmvnpsz874                           nq9nmvnpsz874               94    \n 2 8twofpmpxkvvdnpdnlpkhseven4ncgkb           82fpmpxkvvdnpdnlpkh74ncgkb  84    \n 3 six8shdkdcdgseven8xczqrnnmthreecckfive     68shdkdcdg78xczqrnnm3cck5   65    \n 4 qlcnz54dd75nine7jfnlfgz                    qlcnz54dd7597jfnlfgz        57    \n 5 7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr 7vrdhggdkqbnltlgpkkvsdxn2m… 72    \n 6 cdhmktwo6kjqbprvfour8                      cdhmk26kjqbprv48            28    \n 7 ninekkvkeight9three                        9kkvk893                    93    \n 8 ms9five71lrfpqxqlbj                        ms9571lrfpqxqlbj            91    \n 9 9five9sevenldshqfgcnq                      9597ldshqfgcnq              97    \n10 1one4seven                                 1147                        17    \n# ℹ 990 more rows\n\n\nHypothesis: The issue might arise in instances like \"zoneight234\", where the spellings of two numbers are overlapping.\n\n\nCode\nstr_replace_all(\"zoneight234\", pattern = digits)\n\n\n[1] \"z1ight234\"\n\n\nI’ll try to handle these cases to make sure that every spelled-out digit in the text is returned, even if they overlap.\nMaybe I can get closer to that by using the stringi package?\n\n\nCode\nstringi::stri_replace_all_regex(\"zoneight234\", pattern = names(digits), replacement = digits, vectorize_all = FALSE)\n\n\n[1] \"z1ight234\"\n\n\nThis is not working.\nSomething else I could try:\n\nUsing the _first and _last functions from stringi to identify digits, whether they are numerically written or spelled out.\n\n\nThen, replacing the spelled-out digits that appear at either the beginning or end of the string.\n\n\n\nCode\nproblematic_string &lt;- \"zone2344oneight\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\nall_digits_vector &lt;- c(\n  names(digits),\n  0:9\n)\n\nstringi::stri_extract_last_regex(\n  str = problematic_string,\n  pattern = all_digits_vector\n)\n\n\n [1] \"one\"   NA      NA      NA      NA      NA      NA      \"eight\" NA     \n[10] NA      NA      \"2\"     \"3\"     \"4\"     NA      NA      NA      NA     \n[19] NA     \n\n\nOkay, this method DOES return all the digits that appear in the string, but I end up losing details about where the digits are positioned, which is needed for identifying the first and last digits in each row.\nMore ideas:\n\nUsing str_localte_all, a stringr function that allows matching each digit as an separate pattern (thus avoiding the overlap problem) and gives information about the POSITION of the pattern. Then use that info to find the first and the last match in each row.\n\nExample:\n\n\nCode\nstringr::str_locate_all(\n  string = problematic_string,\n  pattern = all_digits_vector\n)[1:8]\n\n\n[[1]]\n     start end\n[1,]     2   4\n[2,]     9  11\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n\n[[4]]\n     start end\n\n[[5]]\n     start end\n\n[[6]]\n     start end\n\n[[7]]\n     start end\n\n[[8]]\n     start end\n[1,]    11  15\n\n\n\nCRAZY IDEA!!! What if I reverse the string, and then look for first match of the reversed names of the digits??\n\nAfter all, the only matches that matter for solving this puzzle are the first one and the last one. For the first match, overlapping is not a real problem because it causes the second digit not to match (example: “eight” in “oneight”, here “one” is always matched or detected).\nReversing the strings and their patterns could mirror this dynamic when matching the last digit.\n\n\nCode\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nvector_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\n\nIn this example, I should be able to match “eight” as the last string, despite it overlapping with “one”.\n\n\nCode\nproblematic_string\n\n\n[1] \"zone2344oneight\"\n\n\nMy strategy is to invert it and then look for “thgie” 😂💀\n\n\nCode\nreversed_problematic_string &lt;- \n  stringi::stri_reverse(\n  problematic_string\n)\nreversed_problematic_string\n\n\n[1] \"thgieno4432enoz\"\n\n\n\n\nCode\nfound_reversed_string &lt;- str_extract(\n  reversed_problematic_string,\n  \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n)\n\nfound_reversed_string\n\n\n[1] \"thgie\"\n\n\nAfter finding it, I can use the following code to get back the original number\n\n\nCode\nvector_reversed[found_reversed_string]\n\n\nthgie \n  \"8\" \n\n\nIt’s working. Now, let’s wrap this pipeline in a function to apply it to whole dataset:\n\n\nCode\nregex_reversed &lt;- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nall_digits_regex &lt;- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\ndigits_reversed &lt;- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\ndigits &lt;- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\nget_last_number &lt;- function(x) {\n  found_reversed_string &lt;-\n    stringi::stri_reverse(x) %&gt;%\n    str_extract(regex_reversed)\n\n  digits_reversed[found_reversed_string] %&gt;%\n    set_names(NULL)\n}\n\nget_first_number &lt;- function(x) {\n  found_string &lt;- str_extract(\n    x,\n    all_digits_regex\n  )\n\n  digits[found_string] %&gt;%\n    set_names(NULL)\n\n}\nget_first_number(problematic_string)\n\n\n[1] \"1\"\n\n\nCode\nget_last_number(problematic_string)\n\n\n[1] \"8\"\n\n\nIt’s working as intended, now let’s generalise it:\n\n\nCode\ntibble(\n  amended = amended,\n  first_digit = get_first_number(amended),\n  last_digit = get_last_number(amended),\n  combined = as.integer(str_c(first_digit, last_digit))\n) %&gt;%\n  pull(combined) %&gt;%\n  sum()\n\n\n[1] 55701\n\n\nIT WORKED!! THIS WAS THE RIGHT ANSWER!!! 🥳🥳🥹🥹"
  },
  {
    "objectID": "fonts/Readme.html",
    "href": "fonts/Readme.html",
    "title": "iA-Fonts",
    "section": "",
    "text": "iA-Fonts\nThe iA Writer fonts comes bundled with iA Writer for for Android, Windows, Mac, iPadOS and iOS\nFor in depth explanation of iA Writer Mono, Duo, and Quattro please read our blog entry on Duospace and on iA Writer Mono, Duo, and Quattro\nThis is a modification of IBM’s Plex font. The upstream project is here Please read the licensing file before working with it.\nIf you fork or use our fonts, please reference iA Writer clearly. Use them creatively.\nDon’t be a copycat. With or without the fonts, do not clone our products or our website. Selling our work under your name is blatantly disrespectful and criminal. Distributing knockoffs of our work for free doesn’t make you Robin Hood either. We do not approve of free plugins or themes for other apps and other counterfeits that imitate our products. They’re poor quality, they undermine our business, and they openly violate our copyright. Due to their poor quality, they tarnish our reputation. They’re unethical, illegal, and lame."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code",
    "section": "",
    "text": "Hi there! Welcome to this mini-site where I’ll be sharing my solutions to the Advent of Code puzzles. Advent of Code is a series of increasingly difficult programming challenges, released daily each year throughout December in the run-up to Christmas.\nTo see my solutions and notes, just click on the corresponding year in the top navigation bar (though, as of now, I’ve only published solutions for 2023).\nThis website is created using the EllaKaye/advent-of-code-website-template template repository. In the README of the repo you can find documentation on how to use it and adapt it, in case you can to publish your solutions in a similar format (which you should totally do 😁)."
  },
  {
    "objectID": "index.html#on-llms-usage",
    "href": "index.html#on-llms-usage",
    "title": "Advent of Code",
    "section": "On LLMs usage",
    "text": "On LLMs usage\nI’m adhering to the guidelines and suggestions made by the Advent of Code team regarding the use of LLMs like ChatGPT to solve the puzzles. That means I’m not using ChatGPT’s help to arrive at the solutions I’m posting on this website. However, once I’m done with a problem (that means, either solving it or giving up), I may use LLMs to seek feedback or explore alternative approaches."
  },
  {
    "objectID": "2022.html",
    "href": "2022.html",
    "title": "2022",
    "section": "",
    "text": "Title\n\n\nCategories\n\n\n\n\n\n\n2022: Day 1\n\n\nbase R,lists\n\n\n\n\n\n\nNo matching items"
  }
]