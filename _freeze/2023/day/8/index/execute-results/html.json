{
  "hash": "1f6252ac322d801943f9c553481cb5e0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"2023: Day 8 - Haunted Wasteland\"\ndate: 2023-12-8\ncategories:\n  - python\n---\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/8)\n\n[My data](input){target=\"_blank\"}\n\nNotes:\n\n- Input has left/right instructions and a network of labelled nodes.\n- We're meant to use the left/right instructions to navigate the network.\n- AAA is where we are and ZZZ is where we're going.\n\nExample of how the nodes are navigated:\n\n```\nRL\n\nAAA = (BBB, CCC)\nBBB = (DDD, EEE)\nCCC = (ZZZ, GGG)\nDDD = (DDD, DDD)\nEEE = (EEE, EEE)\nGGG = (GGG, GGG)\nZZZ = (ZZZ, ZZZ)\n```\n> Starting with AAA, you need to look up the next element based on the next left/right instruction in your input. In this example, start with AAA and go right (R) by choosing the right element of AAA, CCC. Then, L means to choose the left element of CCC, ZZZ. By following the left/right instructions, you reach ZZZ in 2 steps.\n\n> you might not find ZZZ right away. If you run out of left/right instructions, repeat the whole sequence of instructions as necessary: RL really means RLRLRLRLRLRLRLRL... and so on\n\nThe Question:\n\n> Starting at AAA, follow the left/right instructions. How many steps are required to reach ZZZ?\n\n## Part 1\n\n::: {#571d4ee8 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n```\n:::\n\n\nFirst I need to load the data in a suitable data structure:\n\nI'm going to load the instructions as an array:\n\n::: {#b8ad1fc2 .cell execution_count=2}\n``` {.python .cell-code}\ninput = open('input', 'r')\ninstructions = input.readline().splitlines()\ninstructions = np.array(list(instructions[0]), dtype='object')\ninstructions\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray(['L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'L', 'L', 'R', 'R',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L',\n       'L', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'L', 'R', 'R', 'R', 'L', 'R', 'L', 'L', 'R', 'R', 'L', 'R',\n       'L', 'L', 'R', 'L', 'R', 'L', 'L', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'R', 'L', 'R', 'L', 'R', 'R', 'R', 'L', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'L', 'R', 'L', 'L', 'L', 'L', 'L', 'R',\n       'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R',\n       'R', 'L', 'R', 'R', 'L', 'L', 'R', 'L', 'R', 'L', 'R', 'R', 'L',\n       'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R',\n       'R', 'R', 'L', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L',\n       'R', 'R', 'R', 'L', 'R', 'L', 'R', 'R', 'R', 'L', 'L', 'R', 'L',\n       'R', 'L', 'R', 'R', 'L', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R',\n       'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'R',\n       'L', 'R', 'R', 'L', 'L', 'R', 'R', 'R', 'L', 'R', 'R', 'L', 'R',\n       'R', 'L', 'R', 'L', 'L', 'R', 'R', 'R', 'R'], dtype=object)\n```\n:::\n:::\n\n\nNow, I need to load the node information.\n\nGiven that the node names appear to be unique, I could use a dictionary with the node names as keys. The value of each key could be another dictionary with 'L' and 'R' as keys, simplifying navigation through the nodes based on the instructions (I hope).\n\n::: {#f7377b1d .cell execution_count=3}\n``` {.python .cell-code}\n# Loading the node information in a numpy array\nnodes = np.loadtxt('input', skiprows=2, dtype='str')\n\n# Removing column that doesn't contain useful information\nnodes = nodes[:, [0, 2, 3]]\nnodes = np.char.replace(nodes, '(', '')\nnodes = np.char.replace(nodes, ')', '')\nnodes = np.char.replace(nodes, ',', '')\nnodes[:10]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([['CTK', 'JLT', 'HRF'],\n       ['TQH', 'DKT', 'HGB'],\n       ['HQM', 'XPV', 'TTR'],\n       ['DLL', 'MFK', 'HHS'],\n       ['BVD', 'BXB', 'FDB'],\n       ['TTR', 'BJG', 'MTF'],\n       ['RPR', 'CQL', 'KHJ'],\n       ['KND', 'TVL', 'QMF'],\n       ['SQH', 'XNP', 'MRD'],\n       ['RXM', 'HTR', 'BXT']], dtype='<U3')\n```\n:::\n:::\n\n\nConverting the numpy array into a dictionary through iteration.\n\nI'll create a function that receives a row of the array and creates a key-value pair with 'L' and 'R' keys:\n\n::: {#77e7a5cf .cell execution_count=4}\n``` {.python .cell-code}\ndef create_dict(node):\n  my_dict = {node[0]: {'L': node[1], 'R': node[2]}}\n  return my_dict\n\nnodes_array = np.apply_along_axis(create_dict, axis=1, arr=nodes)\n\nfrom collections import ChainMap\nnodes_dict = dict(ChainMap(*nodes_array))\n\n# Example\nnodes_dict['XLV']\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n{'L': 'VTR', 'R': 'TGD'}\n```\n:::\n:::\n\n\nNext step is (indefinitely) iterating through the `instructions` until reaching `\"ZZZ\"`, while keeping track of the number of steps required to do so.\n\n::: {#4f9d48d8 .cell execution_count=5}\n``` {.python .cell-code}\nsteps = 0\ncurrent_node = 'AAA'\nlength_instructions = len(instructions)\n\nwhile current_node != 'ZZZ':\n  i_current_instruction = steps % length_instructions \n  current_instruction = instructions[i_current_instruction]\n  current_node = nodes_dict[current_node][current_instruction]\n  steps += 1\n\nprint(f'It took {steps} steps')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt took 16409 steps\n```\n:::\n:::\n\n\nIt was correct!\n\n## Part 2\n\n> The number of nodes with names ending in A is equal to the number ending in Z! If you were a ghost, you'd probably just start at every node that ends with A and follow all of the paths at the same time until they all simultaneously end up at nodes that end with Z.\n\nFor example:\n\n```\nLR\n\n11A = (11B, XXX)\n11B = (XXX, 11Z)\n11Z = (11B, XXX)\n22A = (22B, XXX)\n22B = (22C, 22C)\n22C = (22Z, 22Z)\n22Z = (22B, 22B)\nXXX = (XXX, XXX)\n```\n\n> Here, there are two starting nodes, 11A and 22A (because they both end with A). As you follow each left/right instruction, use that instruction to simultaneously navigate away from both nodes you're currently on. Repeat this process until all of the nodes you're currently on end with Z.\n\n> (If only some of the nodes you're on end with Z, they act like any other node and you continue as normal.)\n\n> Simultaneously start on every node that ends with A. How many steps does it take before you're only on nodes that end with Z?\n\nI THINK I can work this out making changes only to the logic and keeping the data structures of the input (`instructions` and `nodes_dict`) as they are right now.\n\nThe initialisation of the current node requires modification, since now we have to start simultaneously from all the nodes that end in 'A'.\n\n::: {#b2a832d2 .cell execution_count=6}\n``` {.python .cell-code}\n# current_node = 'AAA'\nall_nodes = list(nodes_dict.keys())\n\nimport re\npatA = re.compile(r'[A-Z0-9]{2}A')\nstarting_nodes = [node for node in all_nodes if patA.match(node)]\nstarting_nodes\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n['AAA', 'PPA', 'QQA', 'TDA', 'PDA', 'QXA']\n```\n:::\n:::\n\n\n::: {#37dc7d85 .cell execution_count=7}\n``` {.python .cell-code}\nsteps = 0\n\ncurrent_nodes = starting_nodes\n\npatZ = re.compile(r'[A-Z0-9]{2}Z')\nall_z = False\n\nwhile all_z is False:\n  # Code related to iterating thorugh instructions doesn't change\n  # I changed the names to make them more succinct\n  i_curr_ins = steps % length_instructions \n  curr_ins = instructions[i_curr_ins]\n\n  # This code has to change\n  # current_node = nodes_dict[current_node][current_instruction]\n  current_nodes = [nodes_dict[node][curr_ins] for node in current_nodes]\n\n  steps += 1\n  is_z = [bool(patZ.match(node)) for node in current_nodes]\n  all_z = all(is_z)\n  if sum(is_z) > 4:\n    print(current_nodes)\n    print(steps)\n```\n:::\n\n\nEven though this code might technically reach the right answer given enough time, it takes way too long to be considered a viable solution.\n\nI wasn't able to come up with a better solution on my own ðŸ¥² so I took a *hint from Reddit* where they suggested identifying patterns on the number of steps required to reach a node ending in 'Z' from each of the starting nodes, and then using those patterns to identify a common number in the series.\n\n::: {#6f84ae03 .cell execution_count=8}\n``` {.python .cell-code}\n# Initialization values\nsteps = 0\ncurrent_nodes = starting_nodes\npatZ = re.compile(r'[A-Z0-9]{2}Z')\nall_z = False\n\n# Dictionary of empty lists with the starting nodes as keys\nsteps_ending_z = {}\nfor node in starting_nodes:\n  steps_ending_z[node] = []\n\nsteps_ending_z\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n{'AAA': [], 'PPA': [], 'QQA': [], 'TDA': [], 'PDA': [], 'QXA': []}\n```\n:::\n:::\n\n\n::: {#2fa2f9c2 .cell execution_count=9}\n``` {.python .cell-code}\nwhile all_z is False and steps < 1000000:\n  # This code is necessary for appropriately reading the instructions\n  i_curr_ins = steps % length_instructions \n  curr_ins = instructions[i_curr_ins]\n\n  current_nodes = [nodes_dict[node][curr_ins] for node in current_nodes]\n\n  # For any node that ends in Z,\n  # add the current value of `steps` to the corresponding list of the dictionary\n  is_z = [False] * len(current_nodes)\n  for i, node in enumerate(current_nodes):\n    if patZ.match(node):\n      is_z[i] = True\n      steps_ending_z[starting_nodes[i]].append(steps)\n  \n  all_z = all(is_z)\n\n  steps += 1\n```\n:::\n\n\n::: {#5a074723 .cell execution_count=10}\n``` {.python .cell-code}\nfor i, node in enumerate(steps_ending_z):\n  print('Starting node:', node)\n  print('Steps to be in node where last letter was Z:\\n', steps_ending_z[node][:10])\n  print('Steps between nodes ending in Z:')\n  print(np.diff(steps_ending_z[node][:15]))\n  print('\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarting node: AAA\nSteps to be in node where last letter was Z:\n [16408, 32817, 49226, 65635, 82044, 98453, 114862, 131271, 147680, 164089]\nSteps between nodes ending in Z:\n[16409 16409 16409 16409 16409 16409 16409 16409 16409 16409 16409 16409\n 16409 16409]\n\n\nStarting node: PPA\nSteps to be in node where last letter was Z:\n [19636, 39273, 58910, 78547, 98184, 117821, 137458, 157095, 176732, 196369]\nSteps between nodes ending in Z:\n[19637 19637 19637 19637 19637 19637 19637 19637 19637 19637 19637 19637\n 19637 19637]\n\n\nStarting node: QQA\nSteps to be in node where last letter was Z:\n [18022, 36045, 54068, 72091, 90114, 108137, 126160, 144183, 162206, 180229]\nSteps between nodes ending in Z:\n[18023 18023 18023 18023 18023 18023 18023 18023 18023 18023 18023 18023\n 18023 18023]\n\n\nStarting node: TDA\nSteps to be in node where last letter was Z:\n [15870, 31741, 47612, 63483, 79354, 95225, 111096, 126967, 142838, 158709]\nSteps between nodes ending in Z:\n[15871 15871 15871 15871 15871 15871 15871 15871 15871 15871 15871 15871\n 15871 15871]\n\n\nStarting node: PDA\nSteps to be in node where last letter was Z:\n [14256, 28513, 42770, 57027, 71284, 85541, 99798, 114055, 128312, 142569]\nSteps between nodes ending in Z:\n[14257 14257 14257 14257 14257 14257 14257 14257 14257 14257 14257 14257\n 14257 14257]\n\n\nStarting node: QXA\nSteps to be in node where last letter was Z:\n [12642, 25285, 37928, 50571, 63214, 75857, 88500, 101143, 113786, 126429]\nSteps between nodes ending in Z:\n[12643 12643 12643 12643 12643 12643 12643 12643 12643 12643 12643 12643\n 12643 12643]\n\n\n```\n:::\n:::\n\n\nWe can see that for each starting node, there is a regular pattern of number of steps taken before reaching again a node ending in Z.\n\nLet's take the MCM of these numbers (steps between nodes ending in Z):\n\n::: {#8b6552c9 .cell execution_count=11}\n``` {.python .cell-code}\ndef get_steps_between(node, steps_ending_z):\n  return np.unique(np.diff(steps_ending_z[node]))\n\nsteps_between= [get_steps_between(node, steps_ending_z) for node in steps_ending_z]\n\nsteps_between = np.concatenate(steps_between)\n\nsolution = np.lcm.reduce(steps_between)\nsolution\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n11795205644011\n```\n:::\n:::\n\n\nYay! That was the correct solution!\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}