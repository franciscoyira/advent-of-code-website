{
  "hash": "9b441c15f5b4d193ddba4b7e8d29f70f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 1\"\ndate: 2023-12-1\ncategories:\n  - R\n  - stringr\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/1)\n\n[My data](input){target=\"_blank\"}\n\nChosen language: `R`\n\nNotes:\n\n- Puzzle input is a \"calibration document\"\n- Has been \"amended\" by an Elf\n- Each line was a calibration value, that now needs to be recovered\n- Value can be obtained by combining the first digit with the last digit to form a single two-digit number\n\nExamples:\n\n- 1abc2 -> 12\n- pqr3stu8vwx -> 38\n- a1b2c3d4e5f -> 15\n- treb7uchet -> 77\n\nAdding these together produces 142.\n\nDo the same for the whole puzzle input\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\n\nTransforming the data to an appropriate data structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\namended <- read_lines(here('2023', 'day', '1', 'input'))\namended[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"nqninenmvnpsz874\"                          \n [2] \"8twofpmpxkvvdnpdnlpkhseven4ncgkb\"          \n [3] \"six8shdkdcdgseven8xczqrnnmthreecckfive\"    \n [4] \"qlcnz54dd75nine7jfnlfgz\"                   \n [5] \"7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr\"\n [6] \"cdhmktwo6kjqbprvfour8\"                     \n [7] \"ninekkvkeight9three\"                       \n [8] \"ms9five71lrfpqxqlbj\"                       \n [9] \"9five9sevenldshqfgcnq\"                     \n[10] \"1one4seven\"                                \n```\n\n\n:::\n:::\n\n\n### Solving for a particular case\n\n::: {.cell}\n\n```{.r .cell-code}\n(first_case <- amended[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"nqninenmvnpsz874\"\n```\n\n\n:::\n:::\n\n\nExtracting the numbers\n\n::: {.cell}\n\n```{.r .cell-code}\n(matrix_str_numbers <-\n  str_extract_all(first_case, pattern = '\\\\d', simplify = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"8\"  \"7\"  \"4\" \n```\n\n\n:::\n:::\n\n\nExtracting all the rows from columns one and three (the first and last number of each row)\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers_i_want <- matrix_str_numbers[, c(1,3)]\nnumbers_i_want\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8\" \"4\"\n```\n\n\n:::\n:::\n\n\n(This code will generalise ONLY IF all the other rows have 3 numbers too).\n\nThe following code returns the first and last number \"pasted\" together and converts the result from string to numeric.\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_flatten(numbers_i_want) %>%\n  as.numeric()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 84\n```\n\n\n:::\n:::\n\n\nNow let's try to generalise to all input rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\namended %>%\n  str_extract_all(pattern = '\\\\d', simplify = TRUE) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n[1,] \"8\"  \"7\"  \"4\"  \"\"   \"\"   \"\"   \"\"  \n[2,] \"8\"  \"4\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[3,] \"8\"  \"8\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n[4,] \"5\"  \"4\"  \"7\"  \"5\"  \"7\"  \"\"   \"\"  \n[5,] \"7\"  \"2\"  \"\"   \"\"   \"\"   \"\"   \"\"  \n```\n\n\n:::\n:::\n\n\nOh no. Rows have a different quantity of digits.\n\nMaybe using `simplify=TRUE` was a mistake here. Given that each element has a different quantity of digits, a list seems to be a more suitable data structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_digits_preview <- \n  amended %>%\n  str_extract_all(pattern = '\\\\d') %>%\n  head(5)\n\nlist_digits_preview\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n```\n\n\n:::\n:::\n\n\nNow, how can I extract the first and last element from each element of the list? My gut feeling is that I'll need `purrr` for this:\n\n`pluck` and `keep_at` seem to be useful functions for this task\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_digits_preview %>%\n  # This should extract the first and last digit from each element of the list \n  map(~keep_at(., c(1, length(.))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n```\n\n\n:::\n:::\n\n\nIt is working!!\n\nNow I'll apply the action to the whole list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_useful_digits <- \n  amended %>%\n  str_extract_all(pattern = '\\\\d') %>%\n  map(~keep_at(., c(1, length(.))))\n\nlist_useful_digits[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n```\n\n\n:::\n:::\n\n\nHmmm... Why does element  7 have only 1 digit?\n\n\n::: {.cell}\n\n```{.r .cell-code}\namended[7]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ninekkvkeight9three\"\n```\n\n\n:::\n:::\n\n\nIt's got just one digit as a number, but there are other digits written out in words. Should we count those? The prompt isn't really clear about this. But since the example only talks about digits as numbers, I guess I'll just go with those for now. If I've got this wrong and my solution gets rejected, well, I can always give it another shot\n\nNow let's concatenate the digits row-wise, turn them into a number and add them up:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolution <- \n  list_useful_digits %>%\n  map(str_flatten) %>%\n  map(as.integer) %>%\n  as_vector() %>%\n  sum()\n\nsolution\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 39347\n```\n\n\n:::\n:::\n\n\nüëéüèΩ Solution was rejected. The website says it's too low ü§î \n\nThe most likely suspect here is the way `map(~keep_at(., c(1, length(.))))` is handling the rows with only one digit.\n\nSome alternatives I could try:\n\n1. If the input row has only one digit, then use it as first AND last digit when building the number (e.g. if the row only contains 7, the number I would obtain from that row should be 77).\n\n2. Take into account digits that are written as words (e.g. \"three\"). This is less likely to work and it would be weird for the exercise to expect people to do this and not mentioning it explicitely in the prompt or the examples.\n\nI'll go with alternative 1.\n\n### Handling rows with just one digit\n\nI'll take a slice from the first 10 rows, as the first case with one digit appears in row 7:\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_digits_preview <- \n  amended %>%\n  str_extract_all(pattern = '\\\\d') %>%\n  head(10)\n\nlist_digits_preview\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"8\" \"7\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"4\" \"7\" \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\"\n\n[[8]]\n[1] \"9\" \"7\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n```\n\n\n:::\n:::\n\n\nI have a feeling that [`purrr::pluck`](https://purrr.tidyverse.org/reference/pluck.html) may do the trick here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_first_and_last <- function(x) {\n  c(pluck(x, 1), pluck(x, length(x)))\n}\n\nlist_digits_preview %>%\n  map(get_first_and_last)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"8\" \"4\"\n\n[[2]]\n[1] \"8\" \"4\"\n\n[[3]]\n[1] \"8\" \"8\"\n\n[[4]]\n[1] \"5\" \"7\"\n\n[[5]]\n[1] \"7\" \"2\"\n\n[[6]]\n[1] \"6\" \"8\"\n\n[[7]]\n[1] \"9\" \"9\"\n\n[[8]]\n[1] \"9\" \"1\"\n\n[[9]]\n[1] \"9\" \"9\"\n\n[[10]]\n[1] \"1\" \"4\"\n```\n\n\n:::\n:::\n\n\nThis function does what I want (and yes, using `pluck` is a bit unnecessary since I could just have used regular subsetting, e.g. `x[[1]]` and `x[[length(x)]]`, but I'm doing this with the [purrr cheat sheet](https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf) in front of me, so `pluck` was what came to my mind).\n\n2nd attempt, this time using `get_first_and_last`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolution2 <- \n  amended %>%\n  str_extract_all(pattern = '\\\\d') %>%\n  map(get_first_and_last) %>%\n  map(str_flatten) %>%\n  map(as.integer) %>%\n  as_vector() %>%\n  sum()\n\nsolution2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 56397\n```\n\n\n:::\n:::\n\n\nThis is the correct solution!! ü•≥ü•≥ü•≥\n\nOnto the second part!\n\n## Part 2\n\nSaw this one coming: now I need to tackle the digits spelled out as words üò¨. \n\n### First (naive) attempt\n\nIMHO the simplest approach is to write a function that converts digits spelled out in a string into their numeric form. Then, I can incorporate this function into my pipeline using a `map` call, right before `str_extract_all`.\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_with_spelled_digit <- amended[7]\ncase_with_spelled_digit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ninekkvkeight9three\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncase_with_spelled_digit %>%\n  str_replace_all(\n    c(\n      \"nine\" = \"9\",\n      \"eight\" = \"8\",\n      \"three\" = \"3\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"9kkvk893\"\n```\n\n\n:::\n:::\n\n\nWorking as expected.\n\nNow let's apply the function to the full data.\n\nI'll start by creating the replacement vector (although I'm pretty sure it's already a part of some R package that's slipping my mind right now).\n\n::: {.cell}\n\n```{.r .cell-code}\ndigits <- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsolution3 <- \n  amended %>%\n  str_replace_all(pattern = digits) %>%\n  str_extract_all(pattern = '\\\\d') %>%\n  map(get_first_and_last) %>%\n  map(str_flatten) %>%\n  map(as.integer) %>%\n  as_vector() %>%\n  sum()\n\nsolution3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55266\n```\n\n\n:::\n:::\n\n\nThe solution wasn't right.\n\n### Second attempt: handling overlapping patterns\n\nTime to take a closer look at the pipeline using a `tibble`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  original = amended,\n  new = original %>%\n    str_replace_all(pattern = digits),\n  digits = amended %>%\n    str_replace_all(pattern = digits) %>%\n    str_extract_all(pattern = '\\\\d') %>%\n    map(get_first_and_last) %>%\n    map(str_flatten) %>%\n    as_vector()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,000 √ó 3\n   original                                   new                         digits\n   <chr>                                      <chr>                       <chr> \n 1 nqninenmvnpsz874                           nq9nmvnpsz874               94    \n 2 8twofpmpxkvvdnpdnlpkhseven4ncgkb           82fpmpxkvvdnpdnlpkh74ncgkb  84    \n 3 six8shdkdcdgseven8xczqrnnmthreecckfive     68shdkdcdg78xczqrnnm3cck5   65    \n 4 qlcnz54dd75nine7jfnlfgz                    qlcnz54dd7597jfnlfgz        57    \n 5 7vrdhggdkqbnltlgpkkvsdxn2mfpghkntzrhtjgtxr 7vrdhggdkqbnltlgpkkvsdxn2m‚Ä¶ 72    \n 6 cdhmktwo6kjqbprvfour8                      cdhmk26kjqbprv48            28    \n 7 ninekkvkeight9three                        9kkvk893                    93    \n 8 ms9five71lrfpqxqlbj                        ms9571lrfpqxqlbj            91    \n 9 9five9sevenldshqfgcnq                      9597ldshqfgcnq              97    \n10 1one4seven                                 1147                        17    \n# ‚Ñπ 990 more rows\n```\n\n\n:::\n:::\n\n\nHypothesis: The issue might arise in instances like `\"zoneight234\"`, where the spellings of two numbers are overlapping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace_all(\"zoneight234\", pattern = digits)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"z1ight234\"\n```\n\n\n:::\n:::\n\n\nI'll try to handle these cases to make sure that every spelled-out digit in the text is returned, even if they overlap.\n\nMaybe I can get closer to that by using the `stringi` package?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringi::stri_replace_all_regex(\"zoneight234\", pattern = names(digits), replacement = digits, vectorize_all = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"z1ight234\"\n```\n\n\n:::\n:::\n\n\nThis is not working.\n\nSomething else I could try:\n\n1. Using the `_first` and `_last` functions from stringi to identify digits, whether they are numerically written or spelled out.\nb. Then, replacing the spelled-out digits that appear at either the beginning or end of the string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproblematic_string <- \"zone2344oneight\"\n\nall_digits_regex <- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\nall_digits_vector <- c(\n  names(digits),\n  0:9\n)\n\nstringi::stri_extract_last_regex(\n  str = problematic_string,\n  pattern = all_digits_vector\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"one\"   NA      NA      NA      NA      NA      NA      \"eight\" NA     \n[10] NA      NA      \"2\"     \"3\"     \"4\"     NA      NA      NA      NA     \n[19] NA     \n```\n\n\n:::\n:::\n\n\nOkay, this method DOES return all the digits that appear in the string, but  I end up losing details about where the digits are positioned, which is needed for identifying the first and last digits in each row.\n\n\n\nMore ideas: \n\n1. Using `str_localte_all`, a `stringr` function that allows matching each digit as an separate pattern (thus avoiding the overlap problem) and gives information about the POSITION of the pattern. Then use that info to find the first and the last match in each row.\n\nExample: \n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_locate_all(\n  string = problematic_string,\n  pattern = all_digits_vector\n)[1:8]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n     start end\n[1,]     2   4\n[2,]     9  11\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n\n[[4]]\n     start end\n\n[[5]]\n     start end\n\n[[6]]\n     start end\n\n[[7]]\n     start end\n\n[[8]]\n     start end\n[1,]    11  15\n```\n\n\n:::\n:::\n\n\n2. CRAZY IDEA!!! What if I reverse the string, and then look for first match of the **reversed** names of the digits??\n\nAfter all, the only matches that matter for solving this puzzle are the first one and the last one. For the first match, overlapping is not a real problem because it causes the *second* digit not to match (example: \"eight\" in \"oneight\", here \"one\" is always matched or detected).\n\nReversing the strings and their patterns could mirror this dynamic when matching the last digit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregex_reversed <- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nvector_reversed <- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n```\n:::\n\nIn this example, I should be able to match \"eight\" as the last string, despite it overlapping with \"one\".\n\n::: {.cell}\n\n```{.r .cell-code}\nproblematic_string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"zone2344oneight\"\n```\n\n\n:::\n:::\n\n\nMy strategy is to invert it and then look for \"thgie\" üòÇüíÄ\n\n::: {.cell}\n\n```{.r .cell-code}\nreversed_problematic_string <- \n  stringi::stri_reverse(\n  problematic_string\n)\nreversed_problematic_string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"thgieno4432enoz\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfound_reversed_string <- str_extract(\n  reversed_problematic_string,\n  \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n)\n\nfound_reversed_string\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"thgie\"\n```\n\n\n:::\n:::\n\n\nAfter finding it, I can use the following code to get back the original number\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_reversed[found_reversed_string]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nthgie \n  \"8\" \n```\n\n\n:::\n:::\n\n\nIt's working. Now, let's wrap this pipeline in a function to apply it to whole dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregex_reversed <- \"enin|thgie|neves|xis|evif|ruof|eerht|owt|eno|[0123456789]\"\n\nall_digits_regex <- \"[0123456789]|one|two|three|four|five|six|seven|eight|nine\"\n\ndigits_reversed <- c(\n  \"eno\" = \"1\",\n  \"owt\" = \"2\",\n  \"eerht\" = \"3\",\n  \"ruof\" = \"4\",\n  \"evif\" = \"5\",\n  \"xis\" = \"6\",\n  \"neves\" = \"7\",\n  \"thgie\" = \"8\",\n  \"enin\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\ndigits <- c(\n  \"one\" = \"1\",\n  \"two\" = \"2\",\n  \"three\" = \"3\",\n  \"four\" = \"4\",\n  \"five\" = \"5\",\n  \"six\" = \"6\",\n  \"seven\" = \"7\",\n  \"eight\" = \"8\",\n  \"nine\" = \"9\",\n  \"1\" = \"1\",\n  \"2\" = \"2\",\n  \"3\" = \"3\",\n  \"4\" = \"4\",\n  \"5\" = \"5\",\n  \"6\" = \"6\",\n  \"7\" = \"7\",\n  \"8\" = \"8\",\n  \"9\" = \"9\",\n  \"0\" = \"0\"\n)\n\nget_last_number <- function(x) {\n  found_reversed_string <-\n    stringi::stri_reverse(x) %>%\n    str_extract(regex_reversed)\n\n  digits_reversed[found_reversed_string] %>%\n    set_names(NULL)\n}\n\nget_first_number <- function(x) {\n  found_string <- str_extract(\n    x,\n    all_digits_regex\n  )\n\n  digits[found_string] %>%\n    set_names(NULL)\n\n}\nget_first_number(problematic_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"\n```\n\n\n:::\n\n```{.r .cell-code}\nget_last_number(problematic_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8\"\n```\n\n\n:::\n:::\n\n\nIt's working as intended, now let's generalise it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  amended = amended,\n  first_digit = get_first_number(amended),\n  last_digit = get_last_number(amended),\n  combined = as.integer(str_c(first_digit, last_digit))\n) %>%\n  pull(combined) %>%\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55701\n```\n\n\n:::\n:::\n\n\nIT WORKED!! THIS WAS THE RIGHT ANSWER!!! ü•≥ü•≥ü•πü•π",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}