{
  "hash": "b6916d6d02b23aa6c59b333ab1e9ed57",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 4\"\ndate: 2023-12-4\ncategories:\n  - R\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/4)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\nThere are a bunch of cards, which get points based on how many winning numbers do they have.\nI have to calculate how many points are the cards worth *in total*.\n\n```\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\n```\n\nNumbers to the right of the vertical bar |  are the winning numbers.\nThe first winning number to the left of the bar makes the card worth 1 point, and each sucesive winning number doubles the points the card is worth.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\nReading the input as a vector\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(here(\"2023/day/4/input\"))\ninput[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Card   1: 69 12 75 19 83 56 73 53 52 91 | 83 63 56 30 77 94 12 81 42 69 52 70  6 97 20 43 61 22 75 19 73 32 74 53 91\"\n [2] \"Card   2: 23 55 24 84 90 10 87 73 74 45 | 20 66 51 78  9 76 86 96 72 70 84 35 74 90 56 55 23 38 58 45 87  2 80  8 10\"\n [3] \"Card   3: 70 32 38 23 86 54 26 16  9  1 | 67 50 39 70 59 77 63 30  3 45 23 16 72  1 86  7  9 32 26 68 38 54 65 34 64\"\n [4] \"Card   4: 33 50 19 63 92  1 58 34 84  8 | 35 61 49 86 40 20 22 71 84 51 64 62 33 85 45  3 54 83  1 29 82 19 92  8 11\"\n [5] \"Card   5: 74  9 54 83 22 15 81 64 47 70 | 21 74 59 85 17 36  5 79 87  7 13 23 47 45 96 29 68 65  3 22  4 34 46 90 40\"\n [6] \"Card   6: 29 55 56 13 58 71 36 30 15 11 | 99 17 90 29 22 68 61 55 11 13 37 94 30 60 56 92 44 71 42 31  8 26 14 51 35\"\n [7] \"Card   7: 92 70 97 62 33 45 85 59 82 73 | 92 35 11 49 88 14 85 42 40 41 69 51 82 73  5 87 60 62 33 97 70 16 59 13 45\"\n [8] \"Card   8:  5 22 64 46 32 90 57 83 37 38 | 87 47 91 35 39 64 73 83 71 22 10 45  1 76 37 13 20 66 67 21 86 92 38 12 52\"\n [9] \"Card   9:  7 49 62 79 37 91  3 58 74 19 | 17  7 58  2 53 95 52 62 83 41 42 36  4 94 64 97 20 32  3 73 81 22 57 37  9\"\n[10] \"Card  10: 84 33 81 45 99 96 76 97 40  2 | 81 26 11 34 83 25 45 76  2 85 33 64 57 99 93 75 96  8 84 44 79 87 97 40 70\"\n```\n\n\n:::\n:::\n\n\nTrying to parse the input as tidy data:\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_data <- tibble(\n  input = input\n) %>%\n  separate(\n    input,\n    into = c(\"id\", \"data\"),\n    sep = \": \"\n  ) %>%\n  mutate(\n    id = as.integer(str_extract(id, \"\\\\d+\"))\n  )\n\ncard_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 212 Ã— 2\n      id data                                                                   \n   <int> <chr>                                                                  \n 1     1 \"69 12 75 19 83 56 73 53 52 91 | 83 63 56 30 77 94 12 81 42 69 52 70  â€¦\n 2     2 \"23 55 24 84 90 10 87 73 74 45 | 20 66 51 78  9 76 86 96 72 70 84 35 7â€¦\n 3     3 \"70 32 38 23 86 54 26 16  9  1 | 67 50 39 70 59 77 63 30  3 45 23 16 7â€¦\n 4     4 \"33 50 19 63 92  1 58 34 84  8 | 35 61 49 86 40 20 22 71 84 51 64 62 3â€¦\n 5     5 \"74  9 54 83 22 15 81 64 47 70 | 21 74 59 85 17 36  5 79 87  7 13 23 4â€¦\n 6     6 \"29 55 56 13 58 71 36 30 15 11 | 99 17 90 29 22 68 61 55 11 13 37 94 3â€¦\n 7     7 \"92 70 97 62 33 45 85 59 82 73 | 92 35 11 49 88 14 85 42 40 41 69 51 8â€¦\n 8     8 \" 5 22 64 46 32 90 57 83 37 38 | 87 47 91 35 39 64 73 83 71 22 10 45  â€¦\n 9     9 \" 7 49 62 79 37 91  3 58 74 19 | 17  7 58  2 53 95 52 62 83 41 42 36  â€¦\n10    10 \"84 33 81 45 99 96 76 97 40  2 | 81 26 11 34 83 25 45 76  2 85 33 64 5â€¦\n# â„¹ 202 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_data_split <- card_data %>%\n  separate(\n    data,\n    into = c(\"my_numbers\", \"winning_numbers\"),\n    sep = \" \\\\| \"\n  )\n\ncard_data_split\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 212 Ã— 3\n      id my_numbers                      winning_numbers                        \n   <int> <chr>                           <chr>                                  \n 1     1 \"69 12 75 19 83 56 73 53 52 91\" 83 63 56 30 77 94 12 81 42 69 52 70  6â€¦\n 2     2 \"23 55 24 84 90 10 87 73 74 45\" 20 66 51 78  9 76 86 96 72 70 84 35 74â€¦\n 3     3 \"70 32 38 23 86 54 26 16  9  1\" 67 50 39 70 59 77 63 30  3 45 23 16 72â€¦\n 4     4 \"33 50 19 63 92  1 58 34 84  8\" 35 61 49 86 40 20 22 71 84 51 64 62 33â€¦\n 5     5 \"74  9 54 83 22 15 81 64 47 70\" 21 74 59 85 17 36  5 79 87  7 13 23 47â€¦\n 6     6 \"29 55 56 13 58 71 36 30 15 11\" 99 17 90 29 22 68 61 55 11 13 37 94 30â€¦\n 7     7 \"92 70 97 62 33 45 85 59 82 73\" 92 35 11 49 88 14 85 42 40 41 69 51 82â€¦\n 8     8 \" 5 22 64 46 32 90 57 83 37 38\" 87 47 91 35 39 64 73 83 71 22 10 45  1â€¦\n 9     9 \" 7 49 62 79 37 91  3 58 74 19\" 17  7 58  2 53 95 52 62 83 41 42 36  4â€¦\n10    10 \"84 33 81 45 99 96 76 97 40  2\" 81 26 11 34 83 25 45 76  2 85 33 64 57â€¦\n# â„¹ 202 more rows\n```\n\n\n:::\n:::\n\n\nCreating a function that parses the sequences of numbers as numeric vectors:\n\n::: {.cell}\n\n```{.r .cell-code}\nto_numbers <- function(x) {\n  str_extract_all(x, \"\\\\d+\") %>%\n  map(as.numeric)\n}\n```\n:::\n\n\n\nFunction that takes two vectors and calcultes how many elements from the first one are in the second one:\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_n_winning <- function(x, y) {\n  keep(x, ~magrittr::is_in(., y)) %>%\n  length()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_data_processed <-\n  card_data_split %>%\n  mutate(across(c(my_numbers, winning_numbers), to_numbers)) %>%\n  mutate(n_winning = map2_dbl(my_numbers, winning_numbers, calculate_n_winning))\n\ncard_data_processed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 212 Ã— 4\n      id my_numbers winning_numbers n_winning\n   <int> <list>     <list>              <dbl>\n 1     1 <dbl [10]> <dbl [25]>             10\n 2     2 <dbl [10]> <dbl [25]>              8\n 3     3 <dbl [10]> <dbl [25]>             10\n 4     4 <dbl [10]> <dbl [25]>              6\n 5     5 <dbl [10]> <dbl [25]>              3\n 6     6 <dbl [10]> <dbl [25]>              7\n 7     7 <dbl [10]> <dbl [25]>             10\n 8     8 <dbl [10]> <dbl [25]>              5\n 9     9 <dbl [10]> <dbl [25]>              5\n10    10 <dbl [10]> <dbl [25]>             10\n# â„¹ 202 more rows\n```\n\n\n:::\n:::\n\n\nNow I need a function that doubles its output for each integer greater than 1. Specifically, the function should behave as follows:\n\n- f(0) = 0\n- f(1) = 1\n- f(2) = 2\n- f(3) = 4\n- f(4) = 8\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_points <- function(x) {\n  if (x == 0) {\n    return(0)\n  } else {\n    return(2^(x-1))\n  }\n}\n```\n:::\n\n\nApplying the function to calculate how many points the cards are worth:\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_data_processed %>%\n  mutate(points = map_dbl(n_winning, calculate_points)) %>%\n  count(wt = points)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 1\n      n\n  <dbl>\n1 25231\n```\n\n\n:::\n:::\n\n\nThe solution is correct ðŸ¥³\n\n## Part 2\n\nHere I think I need to use some form of recursion:\n\n> \"you win copies of the scratchcards below the winning card equal to the number of matches. So, if card 10 were to have 5 matching numbers, you would win one copy each of cards 11, 12, 13, 14, and 15.\"\n\n> \"Copies of scratchcards are scored like normal scratchcards and have the same card number as the card they copied. So, if you win a copy of card 10 and it has 5 matching numbers, it would then win a copy of the same cards that the original card 10 won: cards 11, 12, 13, 14, and 15. This process repeats until none of the copies cause you to win any more cards. (Cards will never make you copy a card past the end of the table.)\"\n\nIt seems that the only column I need is `n_winning`, along with a new column to keep track of how many copies of the cards I have. I'll store the data in a matrix to access and modify it using indices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_data_pt2 <-\n  card_data_processed %>%\n  transmute(\n    n_matches = n_winning,\n    count = 1\n  ) %>%\n  as.matrix()\n\ncard_data_pt2[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  8 10  6  3  7 10  5  5 10\n```\n\n\n:::\n:::\n\n\nNow I need to code a procedure that captures the logic described in the prompt:\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_9ac22e448de35b1b653c2460b513b434'}\n\n```{.r .cell-code}\nn_original_cards <- nrow(card_data_pt2)\n\nfor (i in 1:n_original_cards) {\n  n_matches_i <- card_data_pt2[i, 1]\n  count_i <- card_data_pt2[i, 2]\n\n  if (n_matches_i == 0) next\n\n  # If I have N copies of the current card, I'll win copies of the cards below N times\n  for (n in 1:count_i) {\n    for (j in 1:n_matches_i) {\n      if (i+j <= n_original_cards) {\n        # Adding one copy of each of the j cards below\n        card_data_pt2[i+j, 2] = card_data_pt2[i+j, 2] + 1\n      }\n    }\n  } \n}\n```\n:::\n\n\nAdding up the scratchcards using the `count` column:\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(card_data_pt2[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9721255\n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}