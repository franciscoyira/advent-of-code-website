{
  "hash": "ba17ba0e43387b578c6761df90c55db9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"2023: Day 3\"\ndate: 2023-12-3\ncategories:\n  - python\n  - arrays\ndraft: false\n---\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/3)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\nNotes:\n\n- A part is missing from an engine; we have to figure out which one using the numbers in the engine schematic (puzzle input).\n- Any number adjacent to a symbol, even diagonally, is a \"part number\" and should be included in the sum.\n- Periods do not count as a symbol.\n\nExample\n\n```\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n```\n> In this schematic, two numbers are not part numbers because they are not adjacent to a symbol: 114 (top right) and 58 (middle right). Every other number is adjacent to a symbol and so is a part number; their sum is 4361.\n\nProblems I see:\n\n- The input is a sort of matrix/grid, but we're working with multi-digit numbers that occupy several slots/cells of the matrix.\n- Computations need to span both vertical and horizontal axes (so dataframe-oriented methods and functions may not be suitable here).\n\nAt this moment, I have no idea which data structure to use for this problem.\n\nThe only thing that comes to mind is to put the data in a `numpy` array, then use a nested `for` loop to check certain conditions.\n\n::: {#6e842e79 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n```\n:::\n\n\nImporting the data in a numpy array where each element is a character of the input file.\n\n::: {#64d0b126 .cell execution_count=2}\n``` {.python .cell-code}\n# Inspiration for this: https://stackoverflow.com/a/75643841/7221164\nwith open('input', 'r') as f:\n    input = np.stack([np.fromiter(list(line.strip()), dtype=\"object\") for line in f])\n    print(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']\n ['.' '.' '1' ... '.' '.' '.']\n ...\n ['.' '.' '.' ... '1' '3' '.']\n ['.' '9' '6' ... '.' '.' '.']\n ['.' '.' '.' ... '.' '.' '.']]\n```\n:::\n:::\n\n\n::: {#44284305 .cell execution_count=3}\n``` {.python .cell-code}\ninput.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n(140, 140)\n```\n:::\n:::\n\n\nImplementing my `for` loop\n\n- In `current_number`, I'll add the digits I find as I iterate (will reset when a period or a line break is found).\n- `is_valid` is a flag indicating whether the `current_number` should be counted in the sum (i.e., if any of its digits is adjacent to a symbol).\n- `running_sum` keeps track of the total of all valid numbers.\n\n::: {#5abbb17f .cell execution_count=4}\n``` {.python .cell-code}\ndebugging_array = []\ncurrent_number = None\nis_valid = False\nrunning_sum = 0\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\n# Inspiration for this: https://stackoverflow.com/a/49360371\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n\n    if not value.isdigit() or (ix == 0 and iy > 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        if is_valid:\n          debugging_array.append(str(current_number) + \" is valid\")\n          running_sum += current_number\n          is_valid = False\n        else:\n          debugging_array.append(str(current_number) + \" is NOT valid\")\n\n        # reset current_numner\n        current_number = None\n    \n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n\n      # check the surrounding elements to know if there is a symbol (only if is_valid = False, otherwise it's not necessary)\n      if is_valid is False:\n        for offset_y, offset_x in np.ndindex((3,3)):\n          curr_y=iy+offset_y-1\n          curr_x=ix+offset_x-1\n\n          # Exception when the \"neighbour\" would be out of the array\n          if curr_y < 0 or curr_x < 0 or curr_y > max_y or curr_x > max_x:\n            continue\n\n          # Exception when we're on the same number\n          if curr_y == iy and curr_x == ix:\n            continue\n\n          # The check itself\n          # If one of the surrounding elements is not a dot or a digit, the flag switches to True and the for loop ends\n          if input[curr_y, curr_x] != \".\" and not input[curr_y, curr_x].isdigit():\n            is_valid = True\n            break \n```\n:::\n\n\nInspecting how the first numbers from the input were classified:\n\n::: {#2e5ac173 .cell execution_count=5}\n``` {.python .cell-code}\ndebugging_array[:10]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n['401 is valid',\n '425 is NOT valid',\n '323 is NOT valid',\n '791 is valid',\n '697 is valid',\n '963 is NOT valid',\n '420 is NOT valid',\n '290 is valid',\n '492 is NOT valid',\n '656 is valid']\n```\n:::\n:::\n\n\nChecking my solution:\n\n::: {#f0da2c44 .cell execution_count=6}\n``` {.python .cell-code}\nprint(running_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n543867\n```\n:::\n:::\n\n\nThe code is very ugly (for my taste), but the solution is correct!!\n\n## Part 2\n\n- One of the gears in the engine is malfunctioning. A gear is represented by a '*' symbol, and it must be adjacent to exactly two part numbers. The gear ratio is calculated by multiplying these two numbers together.\n\n- Task is to determine the gear ratio for each gear and then add them up.\n\nExample:\n\n```\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n```\n\n> Here there are two gears. The first one is located in the top left corner, with part numbers 467 and 35, resulting in a gear ratio of 16345. The second gear is in the lower right corner, and its gear ratio is 451490. (Note that the '*' adjacent to 617 is not a gear because it's only adjacent to one part number.)\n\n> To find the total sum of all the gear ratios in your engine schematic, simply add them up.\n\nIdea to solve this part: each time a number is valid, put it in the corresponding position of a new array that has the same dimensions as the input array.\n\nThen, iterate over the input array with a new for loop that searches for \"*\" and counts the N of valid numbers surrounding it. \n\n::: {#4435a621 .cell execution_count=7}\n``` {.python .cell-code}\narr_pt2 = np.zeros(input.shape)\n\ncurrent_number = None\n\nmax_y = input.shape[0] -1\nmax_x = input.shape[1] -1\n\nfor iy, ix in np.ndindex(input.shape):\n    value = input[iy, ix]\n    \n    # Case when the element is a * (potentially a gear)\n    if value == \"*\":\n      arr_pt2[iy, ix] = -1\n\n    # Checking if a number just ended\n    if not value.isdigit() or (ix == 0 and iy > 0):\n      # case when a sequence of digits is ending \n      if current_number is not None:\n        # I need to write the current_number on the previous positions of arr_pt2\n        # Things to take into account:\n        # 1. overflowing across rows\n        # 2. I need to write the number on as many cells as digits the number has \n\n        for i in range(len(str(current_number))):\n          # ex: for a 3 digit number, offset will take values -1, -2 and -3\n          offset = -1 - i\n          # we first try to go back one cell in the x axis\n          # (move to the left across the same row)\n          ix_offset = ix + offset\n          iy_offset = iy\n\n          # case when we overflow the beginning of the row\n          if ix_offset < 0:\n            # we move up in the y-axis\n            iy_offset = iy_offset-1\n\n            # when ix_offset == -1, we add 140 to end up with 139\n            ix_offset=ix_offset+input.shape[1]\n\n            # example\n            # if iy_offset, ix_offset == 10, -1\n            # we end up in 9, 139\n          arr_pt2[iy_offset, ix_offset] = current_number\n\n        # reset current_numner\n        current_number = None\n\n    if value.isdigit():\n      if current_number is None:\n        # case when a sequence of digits is starting\n        current_number = int(value)\n      else:\n        # case when we're in the middle of a sequence of digits\n        current_number = current_number*10 + int(value)\n```\n:::\n\n\nAfter this rather messy `for` loop, I should be able to identify gears by looking at the surrounding cells of all the '-1' values in the array, which represent '*'.\n\n::: {#bd67286d .cell execution_count=8}\n``` {.python .cell-code}\nmax_y = arr_pt2.shape[0] -1\nmax_x = arr_pt2.shape[1] -1\n\nrunning_sum = 0\n\nfor iy, ix in np.ndindex(arr_pt2.shape):\n  value = arr_pt2[iy, ix]\n\n  neighbours = set()\n\n  if value == -1:\n    for offset_y, offset_x in np.ndindex((3,3)):\n      curr_y=iy+offset_y-1\n      curr_x=ix+offset_x-1\n\n      # Exception when the \"neighbour\" would be out of the array\n      if curr_y < 0 or curr_x < 0 or curr_y > max_y or curr_x > max_x:\n        continue\n\n      # Exception when we're on the same number\n      if curr_y == iy and curr_x == ix:\n        continue\n\n      # The check itself\n      # if a surrounding cell is a number, then I'll add it to the `neighbours` set (this data structure handles duplicated numbers automatically)\n      if arr_pt2[curr_y, curr_x] > 0:\n        neighbours.add(arr_pt2[curr_y, curr_x])\n\n  \n  if len(neighbours) == 2:\n    # multiply the neighbours\n    running_sum += neighbours.pop() * neighbours.pop()\n```\n:::\n\n\nChecking my solution:\n\n::: {#ffed9322 .cell execution_count=9}\n``` {.python .cell-code}\nprint(running_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n79613331.0\n```\n:::\n:::\n\n\nIt was correct!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}