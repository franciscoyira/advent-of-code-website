{
  "hash": "c6e1f8aed15197a389b66d9440725a6c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 10 - Pipe Maze\"\ndate: 2023-12-10\ncategories:\n  - R\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/10)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\nThere are a lot of pipes and there is an animal hidden somewhere inside them. Puzzle input is a 2D sketch of all the surface pipes we can see.\n\n- `|` is a vertical pipe connecting north and south.\n- `-` is a horizontal pipe connecting east and west.\n- `L` is a 90-degree bend connecting north and east.\n- `J` is a 90-degree bend connecting north and west.\n- `7` is a 90-degree bend connecting south and west.\n- `F` is a 90-degree bend connecting south and east.\n- `.` is ground; there is no pipe in this tile.\n- `S` is the starting position of the animal; there is a pipe on this tile, but your sketch doesn't show what shape the pipe has.\n\nPrompt suggests that the animal is inside \"one large, continuous loop\". For example, one like this:\n\n```\n.....\n.F-7.\n.|.|.\n.L-J.\n.....\n```\n\nWhich would have looked like this if the animal had entered through the northwest corner:\n```\n.....\n.S-7.\n.|.|.\n.L-J.\n.....\n```\n\nOther key facts:\n\n- The tile where the animal is doesn't show its true shape, but it can be inferred from the surrounding pipes.\n- The pipe with `S` is assummed to connect back to the pipes that conect to it.\n- There are many pipes that don't connect to the main loop.\n\n> If you want to get out ahead of the animal, you should find the tile in the loop that is farthest from the starting position. Because the animal is in the pipe, it doesn't make sense to measure this by direct distance. Instead, you need to find the tile that would take the longest number of steps along the loop to reach from the starting point - regardless of which way around the loop the animal went.\n\nFor example, in the following loop:\n```\n..F7.\n.FJ|.\nSJ.L7\n|F--J\nLJ...\n```\n\nDistances would look like this:\n```\n..45.\n.236.\n01.78\n14567\n23...\n```\nThus, the farthest point is 8 steps away from the start.\n\nThe problem:\n\n> Find the single giant loop starting at S. How many steps along the loop does it take to get from the starting position to the point farthest from the starting position?\n\nDataframe-like data structures don't seem right for this problem. I'll probaby have to use 2D matrices and go through them with nested loops (kind of like the messy code I wrote for [day 3](/2023/day/3/)). There might be a better data structure for approaching this, but unfortunately, I'm not aware of it yet.\n\n(I have a gut feeling that this could be addressed through Object-Oriented Programming? Like, defining each of the pipes as different classes? Anyway, onto the matrices...)\n\nLoading the sketch as a 2D matrix:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n\nsketch <- read_lines(here(\"2023/day/10/input\")) %>%\n  str_split(pattern = \"\", simplify=TRUE)\n\nsketch[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,] \"F\"  \"-\"  \"7\"  \"J\"  \"F\"  \"-\"  \"F\"  \"-\"  \"F\"  \"|\"  \n [2,] \"|\"  \"F\"  \"-\"  \"J\"  \"|\"  \"|\"  \"L\"  \"-\"  \".\"  \"J\"  \n [3,] \"F\"  \"F\"  \"-\"  \"7\"  \"7\"  \"-\"  \"7\"  \"L\"  \"7\"  \"F\"  \n [4,] \"F\"  \"7\"  \"-\"  \"J\"  \"|\"  \"F\"  \"J\"  \".\"  \"-\"  \"-\"  \n [5,] \"|\"  \"|\"  \"F\"  \"J\"  \"7\"  \"F\"  \"7\"  \"F\"  \"L\"  \"7\"  \n [6,] \"F\"  \"7\"  \"7\"  \".\"  \"-\"  \"F\"  \"J\"  \"J\"  \"L\"  \"J\"  \n [7,] \"L\"  \"|\"  \"-\"  \"L\"  \".\"  \"J\"  \"|\"  \".\"  \"|\"  \"L\"  \n [8,] \"F\"  \"|\"  \".\"  \"|\"  \".\"  \"L\"  \"|\"  \"7\"  \"-\"  \"|\"  \n [9,] \"L\"  \"J\"  \"F\"  \"L\"  \"L\"  \"F\"  \"J\"  \"7\"  \"J\"  \"L\"  \n[10,] \"|\"  \"-\"  \"J\"  \"7\"  \".\"  \"J\"  \"J\"  \".\"  \"7\"  \"7\"  \n```\n\n\n:::\n:::\n\n\nNow, how to find the \"big loop\"?\n\nIdea: create a \"twin matrix\" with the same dimensions as `sketch`, intially filled with `NA`s, to represent the distances from the origin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_distances <- matrix(\n  nrow = dim(sketch)[1],\n  ncol = dim(sketch)[2]\n)\n```\n:::\n\n\nThen, look at the 8 tiles surrounding the starting tile (`S`) to start exploring the `sketch` grid.\n\n::: {.cell}\n\n```{.r .cell-code}\nposition_s <- which(sketch == \"S\", arr.ind = TRUE)\nposition_s\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     row col\n[1,]  76  54\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- position_s[1]\nj <- position_s[2]\n\nsurroundings <- sketch[(i-1):(i+1), (j-1):(j+1)]\nsurroundings\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"-\"  \"-\"  \"J\" \n[2,] \"-\"  \"S\"  \"-\" \n[3,] \"7\"  \"F\"  \"-\" \n```\n\n\n:::\n:::\n\n\nLet's create a function that, given the `surroundings` matrix, assigns values of distance to the tiles that are connected to the central tile.\n\nFirst, I'll consider the particular case of the starting tile:\n\n::: {.cell}\n\n```{.r .cell-code}\ndistances <- matrix(nrow = 3, ncol = 3)\ndistances[2,2] <- 0\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsouth_connecting_pipes <- c(\"|\", \"7\", \"F\")\nwest_connecting_pipes <- c(\"-\", \"J\", \"7\")\neast_connecting_pipes <- c(\"-\", \"L\", \"F\")\nnorth_connecting_pipes <- c(\"|\", \"L\", \"J\")\n\nif (surroundings[1, 2] %in% south_connecting_pipes) {\n  distances[1,2] <- 1\n}\n\nif (surroundings[2, 1] %in% east_connecting_pipes) {\n  distances[2, 1] <- 1\n}\n\nif (surroundings[3,2] %in% north_connecting_pipes) {\n  distances[3, 2] <- 1\n}\n\nif (surroundings[2, 3] %in% west_connecting_pipes) {\n  distances[2, 3] <- 1\n}\n\ndistances\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    1    0    1\n[3,]   NA   NA   NA\n```\n\n\n:::\n:::\n\n\nI can now copy these local `distances` back to the `all_distances` twin matrix.\n\nAfter that, I could use `which.max(all_distances)` to find the tiles that are further away from the starting tile and still connected to it.\n\nFinally, I can repeat the distance assignment process, but this time starting from the tiles identified by `which.max`.\n\nCopying the distance values:\n\n::: {.cell}\n\n```{.r .cell-code}\nall_distances[(i-1):(i+1), (j-1):(j+1)] <- distances\n```\n:::\n\n\nFinding the tiles that are further away from the start and still connected to it:\n\n::: {.cell}\n\n```{.r .cell-code}\nfurther_away <- which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE)\nfurther_away\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     row col\n[1,]  76  53\n[2,]  76  55\n```\n\n\n:::\n:::\n\n\nLet's take the coordinates of these points, explore their surroundings, and then assign distance values to the tiles that are connected to them.\n\nTo simplify, I'll first calculate the distances for just one of the `further_away` points:\n\n::: {.cell}\n\n```{.r .cell-code}\ncurrent_tile1 <- further_away[1,]\ni <- current_tile1[1]\nj <- current_tile1[2]\n\ndistances <- all_distances[(i-1):(i+1), (j-1):(j+1)]\n\nsurroundings <- sketch[(i-1):(i+1), (j-1):(j+1)]\nsurroundings\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,] \"F\"  \"-\"  \"-\" \n[2,] \"L\"  \"-\"  \"S\" \n[3,] \"F\"  \"7\"  \"F\" \n```\n\n\n:::\n:::\n\n\nAt this point, the rules for identifying connecting pipes should be extended to include scenarios where none of the tiles are marked with `S`. I'll define the function `is_connected()` for this purpose.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhorizontally_connecting <- \n # first element = left, second element=left\n  list(\n    c(\"-\", \"-\"),\n    c(\"-\", \"7\"),\n    c(\"-\", \"J\"),\n    c(\"L\", \"-\"),\n    c(\"L\", \"7\"),\n    c(\"L\", \"J\"),\n    c(\"F\", \"-\"),\n    c(\"F\", \"J\"),\n    c(\"F\", \"7\"),\n    c(\"S\", \"-\"),\n    c(\"S\", \"J\"),\n    c(\"S\", \"7\"),\n    c(\"-\", \"S\"),\n    c(\"L\", \"S\"),\n    c(\"F\", \"S\")\n  )\n\nvertically_connecting <- \n # first element = top, second element = bottom\n  list(\n    c(\"|\", \"|\"),\n    c(\"F\", \"|\"),\n    c(\"7\", \"|\"),\n    c(\"|\", \"J\"),\n    c(\"F\", \"J\"),\n    c(\"7\", \"J\"),\n    c(\"F\", \"L\"),\n    c(\"7\", \"L\"),\n    c(\"|\", \"L\"),\n    c(\"S\", \"|\"),\n    c(\"S\", \"L\"),\n    c(\"S\", \"J\"),\n    c(\"|\", \"S\"),\n    c(\"7\", \"S\"),\n    c(\"F\", \"S\")\n  )\n\nis_connected <- function(pair_tiles, direction) {\n  # the logic for identifying connecting pipes depends on the direction we're moving to\n  if (direction %in% c(\"N\", \"S\")) {\n    return (list(pair_tiles) %in% vertically_connecting)\n  } else {\n    return (list(pair_tiles) %in% horizontally_connecting)\n  }\n}\n```\n:::\n\n\nUsing a named list to give friendly names to directions in the 3x3 matrices:\n\n::: {.cell}\n\n```{.r .cell-code}\ndirections <- list(\n  \"S\" = c(3, 2),\n  \"N\" = c(1, 2),\n  \"E\" = c(2, 3),\n  \"W\" = c(2, 1)\n)\n```\n:::\n\n\nNow let's use this function to calculate the distances surrounding our current location (`current_tile1`).\n\n::: {.cell}\n\n```{.r .cell-code}\ncentral_tile <- surroundings[2,2]\n\nfor (i_dir in seq_along(directions)) {\n  direction <- names(directions)[i_dir]\n\n  surr_i <- directions[[i_dir]][1]\n  surr_j <- directions[[i_dir]][2]\n\n  cur_surr_tile <- surroundings[surr_i, surr_j]\n\n  if (is.na(distances[surr_i, surr_j])) {\n    # NA in distance means a comparation hasn't been done\n    if (direction %in% c(\"S\", \"E\")) tile_pair <- c(central_tile, cur_surr_tile)\n\n    if (direction %in% c(\"N\", \"W\")) tile_pair <- c(cur_surr_tile, central_tile)\n\n    connected <- is_connected(tile_pair, direction)\n\n    if (connected) {\n      distances[surr_i, surr_j] <- distances[2,2] + 1\n    }\n  \n  }\n} \n\nall_distances[(i-1):(i+1), (j-1):(j+1)] <- distances\n```\n:::\n\n\nSo far, the code is working as expected.\n\nNow it's time to organise the code into functions. I need to start with a function that does the following:\n\n- Receives `sketch`, `all_distances` and a set of coordinates (the output of `which.max`) as inputs.\n- Explores the surroundings of those coordinates.\n- Applies the previously described logic to calculate distance values for tiles connected to those coordinates.\n- Return an updated version of the `all_distances` with the values from the previous step.\n\nThe set of coordinates will be assummed to be a matrix, as per the output of `which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexplore_surroundings <-\n  function(\n    coordinates,\n    this_sketch = sketch,\n    these_distances = all_distances) {\n\n      for (i_coord in seq_along(coordinates[,\"row\"])) {\n        i <- coordinates[i_coord, \"row\"]\n        j <- coordinates[i_coord, \"col\"]\n\n        surroundings <- this_sketch[(i - 1):(i + 1), (j - 1):(j + 1)]\n        distances <- these_distances[(i - 1):(i + 1), (j - 1):(j + 1)]\n\n        central_tile <- surroundings[2, 2]\n\n        for (i_dir in seq_along(directions)) {\n          direction <- names(directions)[i_dir]\n\n          surr_i <- directions[[i_dir]][1]\n          surr_j <- directions[[i_dir]][2]\n\n          cur_surr_tile <- surroundings[surr_i, surr_j]\n\n          if (is.na(distances[surr_i, surr_j])) {\n            # NA in distance means a comparation hasn't been done\n            if (direction %in% c(\"S\", \"E\")) tile_pair <- c(central_tile, cur_surr_tile)\n\n            if (direction %in% c(\"N\", \"W\")) tile_pair <- c(cur_surr_tile, central_tile)\n\n            connected <- is_connected(tile_pair, direction)\n\n            if (connected) {\n              distances[surr_i, surr_j] <- distances[2, 2] + 1\n            }\n          }\n        }\n        these_distances[(i - 1):(i + 1), (j - 1):(j + 1)] <- distances\n      }\n\n    return(these_distances)\n  }\n```\n:::\n\n\nNow, I should be able to navigate through the pipes by repeatedly executing the following code:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example code: not meant to run\nall_distances <- explore_surroundings(further_away)\nfurther_away <- which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE)\n```\n:::\n\n\nI'm considering a `while` loop for this, but I'm not quite sure what the stopping condition should be. Maybe it could stop when it's about to overwrite a cell that already has a distance value. That would mean we're going back to a cell we've already visited, suggesting the loop has come full circle.\n\nLet's try doing that. First, we declare the starting conditions:\n\n::: {.cell}\n\n```{.r .cell-code}\nfurther_away <- which(sketch == \"S\", arr.ind = TRUE)\n\nall_distances <- matrix(\n  nrow = dim(sketch)[1],\n  ncol = dim(sketch)[2]\n)\n\nall_distances[further_away[1, \"row\"], further_away[1, \"col\"]] <- 0\n```\n:::\n\n\nNow onto the loop itself:\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile (TRUE) {\n  new_distances <- explore_surroundings(further_away)\n\n  # Stopping condition\n  if (sum(new_distances > all_distances, na.rm = TRUE) > 0) break\n\n  # Another stopping condition: the amount of NAs is the same (no exploration)\n  if (sum(is.na(new_distances)) == sum(is.na(all_distances))) break \n\n  all_distances <- new_distances\n  further_away <- which(all_distances == max(all_distances, na.rm = TRUE), arr.ind = TRUE)\n}\n```\n:::\n\n\nOnce the code stops, I just need to find the highest value in the `all_distances` matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(all_distances, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6682\n```\n\n\n:::\n:::\n\n\nIt's correct! (I almost can't believe it, given how messy my code is 😅).\n\n## Part 2\n\nNow we have to calculate how many tiles are contained *within* the loop. The definition of being within the loop is quite specific. For example, in the sketch below, the tiles marked with `0` are technically *outside the loop*.\n\n```\n..........\n.S------7.\n.|F----7|.\n.||OOOO||.\n.||OOOO||.\n.|L-7F-J|.\n.|II||II|.\n.L--JL--J.\n..........\n```\n\n> Any tile that isn't part of the main loop can count as being enclosed by the loop.\n\nThe task is to find how many tiles are enclosed by the loop.\n\nBefore trying to solve this, I want to visualize the values in the `all_distances` matrix. This will help me get a better idea of the loop's size and shape.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plot.matrix)\nlibrary(viridis)\nbrk <- 6000\npar(mar=c(5.1, 4.1, 4.1, 4.1))\nsvg(\"all_distances.svg\", height=80, width=80)\n\n# Code of the plot\ndistances <- plot(\n  all_distances,\n  border=NA,\n  breaks=brk,\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(brk), \n  digits=1,\n  text.cell=list(cex=0.5),\n  fmt.cell=\"%.0f\",\n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA)\n\n# Close the graphics device\ndev.off()\n```\n:::\n\n\nThe output of the code above is a giant SVG image that depicts the full `all_distances` matrix, highlighting the tiles that are part of the loop (they're colour-coded based on their distance to the starting tile and they also display the distance value as text on top of them).\n\nThe plot with the text is too big to show it on this page (here is the [full-size version of the plot](all_distances.svg)), so I'll display just a section of it below. \n\n::: {.cell}\n\n```{.r .cell-code}\ni <- position_s[1]\nj <- position_s[2]\n\nplot(\n  all_distances[(i-10):(i+10), (j-10):(j+10)],\n  main=\"Tiles in the loop (and their distances to origin)\",\n  border=NA,\n  breaks=brk,\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(brk), \n  digits=1,\n  text.cell=list(cex=0.5),\n  fmt.cell=\"%.0f\",\n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA,\n  asp=1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nAnd here is a \"miniature version\" without the text (darker colours represent tiles closer to the origin and white represents tiles that are not part of the loop).\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(\n  all_distances,\n  main=NULL,\n  border=NA,\n  breaks=brk,\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(brk), \n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA,\n  asp=1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nBased on the plot, we can see that the loop is really big and has a complex shape, including many twists and turns.\n\nI'm also curious about how many 'arms' or paths branch off from the loop. Are there any that lead to dead-ends and don't reconnect with the main loop? (In that case, there would be distance values I would have to discard before identifying the tiles enclosed by the loop).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistances_values <- 1:max(all_distances, na.rm = TRUE)\n\nn_tiles_distance <- function(distance) {\n  return(sum(all_distances == distance, na.rm=TRUE))\n}\n\ntibble(\n  distances = distances_values,\n  n_paths = map_dbl(distances, n_tiles_distance)\n) %>%\n  count(n_paths)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  n_paths     n\n    <dbl> <int>\n1       1     1\n2       2  6681\n```\n\n\n:::\n:::\n\n\nThere are always only two paths branching off the starting tile, ensuring there are no 'dead-ends' in the loop.\n\nNext steps:\n\n- Traverse the loop in a counter-clockwise direction, inspecting the tiles to the left of the path. Consider tiles with `NA` as distance value as \"enclosed\" by the loop.\n- After identifying these inner loop cells (and verifying via visual inspection that they actually are within the loop), initiate a 'contagion' process. This means marking contiguous non-loop tiles as \"enclosed by the loop\".\n\nImplementing my idea for the \"base case\" (the starting tile `S`):\n\n::: {.cell}\n\n```{.r .cell-code}\nstarting_position <- which(all_distances == 0, arr.ind = TRUE)\ni <- starting_position[1, \"row\"]\nj <- starting_position[1, \"col\"]\n\ndirections <- list(\n  \"S\" = c(3, 2),\n  \"N\" = c(1, 2),\n  \"W\" = c(2, 1),\n  \"E\" = c(2, 3)\n)\n```\n:::\n\n\nThe coordinates for 'the cell to the left' and 'the cell to the right' will vary depending on the direction. E.g. if we go South from the centre tile (2,2 to 3,2), the coordinates of the \"cell to the right\" are going to be 3,1.\n\n::: {.cell}\n\n```{.r .cell-code}\nto_the_right <- list(\n  \"S\" = c(3, 1),\n  \"N\" = c(1, 3),\n  \"E\" = c(3, 3),\n  \"W\" = c(1, 1)\n)\n\nto_the_left <- list(\n  \"S\" = c(3, 3),\n  \"N\" = c(1, 1),\n  \"E\" = c(1, 3),\n  \"W\" = c(3, 1)\n)\n```\n:::\n\n\nI'll use the value -1 in the distances matrix to mark the tiles that are enclosed by the loop.\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_i <- i\nnew_j <- j\nwhile (TRUE) {\n  distances <- all_distances[(new_i-1):(new_i+1), (new_j-1):(new_j+1)]\n\n  # I'll use the `directions` vector which was declared before to check the cardinal coordinates\n  # Given the order of the list `directions`, this loop will go East first\n  for (i_dir in seq_along(directions)) {\n    direction <- names(directions)[i_dir]\n\n    surr_i <- directions[[i_dir]][1]\n    surr_j <- directions[[i_dir]][2]\n\n    surr_dist_val <- replace_na(distances[surr_i, surr_j], 0)\n\n    # Go in the direction of the cell that increments distance by 1\n    if (surr_dist_val - distances[2, 2] == 1) {\n      #  mark the tile to the left as \"inside\"\n      i_left <- to_the_left[[direction]][1]\n      j_left <- to_the_left[[direction]][1]\n\n      if (is.na(distances[i_left, j_left])) {\n        distances[i_left, j_left] <- -1\n      }\n\n      # Updating i and j to reflect that we moved\n      new_i <- i + surr_i - 2\n      new_j <- j + surr_j - 2\n      break\n    }\n  }\n\n  # stopping condition: \n  if (distances[2, 2] == all_distances[new_i, new_j]) break\n\n  all_distances[(i-1):(i+1), (j-1):(j+1)] <- distances\n\n  i <- new_i\n  j <- new_j\n}\n```\n:::\n\n\nCounting the tiles that have been marked as inside the loop until now.\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(all_distances == -1, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 390\n```\n\n\n:::\n:::\n\n\nVisual inspection:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(\n  all_distances,\n  main='Tiles inside the loop (before the contagion process)',\n  sub=\"White = NA / Grey = Part of the loop / Black = enclosed by the loop\",\n  border=NA,\n  breaks=c(-1, 1),\n  na.col=\"grey\",\n  na.cell=FALSE,\n  col=magma(4), \n  key=NULL,\n  polygon.key=NULL,\n  axis.col=NULL,\n  axis.row=NULL,\n  xlab=NA, ylab=NA,\n  asp=1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nAfter looking carefully at [the full-size visualisation](all_distances_part2.svg), it seems there are two issues:\n\n1. I'm not correctly handling the case then the loop takes a turn.\n2. Only one of the loop's 'arms' is being traversed, but there are two.\n\nUnfortunately, the time I've spent on this problem has exceeded my \"time budget\" and I'm not even sure that the algorithm I'm implementing will lead to the correct solution, so I'm deciding to stop here.\n\n![](Thats_all_folks.png \"That's all folks!\")\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}